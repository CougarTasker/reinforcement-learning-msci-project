{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Final Year Project Documentation","text":"<p>This site contains the documentation for this project, please navigate the reference section in the left panel or use the search tool in the top right.</p> <p>The project consists of three main sections:</p> <ul> <li>Model<ul> <li>This package contains the code for the reinforcement learning models such as the agents and dynamics.</li> </ul> </li> <li>View<ul> <li>This package contains the code for the user interface it displays the state of model and allows the user to interact with it.</li> </ul> </li> <li>Controller<ul> <li>This package contains the code that links the Model and View. </li> </ul> </li> </ul> <p>and two entry points:</p> <ul> <li>Main<ul> <li>This is the main usual entrypoint of the application</li> </ul> </li> <li>Profile<ul> <li>This is a secondary entrypoint that sets up a profiler before starting the application</li> </ul> </li> </ul> <p>This documentation site was generated with mkdocs.</p>"},{"location":"#documentation-commands","title":"Documentation Commands","text":"<p>To start a server that will allow you to see the documentation locally.</p> <pre><code>poetry run mkdocs serve -a localhost:3000\n</code></pre> <p>To make a new build of the documentation locally.</p> <pre><code>poetry run mkdocs build\n</code></pre>"},{"location":"SUMMARY/","title":"SUMMARY","text":"<ul> <li>Reference<ul> <li>Controller<ul> <li>Base Bridge</li> <li>Learning System Controller</li> <li>Learning System Controller Factory</li> <li>State Update Bridge</li> <li>User Action Bridge</li> </ul> </li> <li>Main</li> <li>Model<ul> <li>Agents<ul> <li>Base Agent</li> <li>Q Learning<ul> <li>Agent</li> <li>Dynamic Q Table</li> <li>Reward Replay Queue</li> </ul> </li> <li>Value Iteration<ul> <li>Agent</li> <li>Agent Optimised</li> <li>Dynamics Distribution</li> <li>Types</li> </ul> </li> </ul> </li> <li>Config<ul> <li>Agent Section</li> <li>Base Section</li> <li>Grid World Section</li> <li>Gui Section</li> <li>Reader</li> </ul> </li> <li>Dynamics<ul> <li>Actions</li> <li>Base Dynamics</li> <li>Collection Dynamics</li> <li>Grid World</li> </ul> </li> <li>Learning System<ul> <li>Cell Configuration</li> <li>Learning Instance</li> <li>Learning System</li> <li>Options</li> <li>State Description</li> <li>State Description Factory</li> <li>Value Range Normaliser<ul> <li>Normaliser</li> <li>Normaliser Factory</li> <li>Value Range</li> </ul> </li> </ul> </li> <li>State<ul> <li>Cell Entities</li> <li>State Builder</li> <li>State Instance</li> <li>State Pool</li> </ul> </li> </ul> </li> <li>Profile</li> <li>View<ul> <li>App</li> <li>Grid World View<ul> <li>Display State<ul> <li>Cell<ul> <li>Arrow Layer</li> <li>Background Layer</li> <li>Base Layer</li> <li>Cell</li> <li>Cell Layout</li> <li>Main Icon Layer</li> </ul> </li> <li>Display</li> </ul> </li> <li>Grid World</li> </ul> </li> <li>Icons<ul> <li>Load Icon</li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/","title":"Reference","text":"<p>This package contains the source code to the project.</p>"},{"location":"reference/main/","title":"Main","text":""},{"location":"reference/main/#src.main.main","title":"<code>main()</code>","text":"<p>Start the application.</p> <p>The main entry point into the application.</p> Source code in <code>src/main.py</code> <pre><code>def main():\n    \"\"\"Start the application.\n\n    The main entry point into the application.\n    \"\"\"\n    controller = LearningSystemControllerFactory()\n    app = ReinforcementLearningApp(controller)\n    app.mainloop()\n</code></pre>"},{"location":"reference/profile/","title":"Profile","text":""},{"location":"reference/profile/#src.profile.profile","title":"<code>profile()</code>","text":"<p>Entry point for profiling the application.</p> Source code in <code>src/profile.py</code> <pre><code>def profile():\n    \"\"\"Entry point for profiling the application.\"\"\"\n    profiler = cProfile.Profile()\n    profiler.enable()\n    profiled_code()\n    profiler.disable()\n    ps = pstats.Stats(profiler)\n    ps.dump_stats(\"profile_result.prof\")\n</code></pre>"},{"location":"reference/profile/#src.profile.profiled_code","title":"<code>profiled_code()</code>","text":"<p>Run the profiled code.</p> <p>The code in this method will be profiled by the application.</p> Source code in <code>src/profile.py</code> <pre><code>def profiled_code():\n    \"\"\"Run the profiled code.\n\n    The code in this method will be profiled by the application.\n    \"\"\"\n    main()\n</code></pre>"},{"location":"reference/controller/","title":"Controller","text":"<p>This package contains the controllers.</p> <p>These act as the bridge between the view and the model</p>"},{"location":"reference/controller/base_bridge/","title":"Base Bridge","text":""},{"location":"reference/controller/base_bridge/#src.controller.base_bridge.BaseBridge","title":"<code>BaseBridge</code>","text":"<p>             Bases: <code>object</code></p> <p>Bases class that represents a bridge between two processes.</p> Source code in <code>src/controller/base_bridge.py</code> <pre><code>class BaseBridge(object):\n    \"\"\"Bases class that represents a bridge between two processes.\"\"\"\n\n    capacity = 1000\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialise a bridge.\"\"\"\n        manager = Manager()\n        self.queue = manager.Queue(self.capacity)\n        self.count_lock = manager.Lock()\n        self.count = manager.Value(int, 0)\n\n    def get_count(self) -&gt; int:\n        \"\"\"Get the current count of items in the queue.\n\n        Returns:\n            int: the number of items on the queue\n        \"\"\"\n        return self.count.get()\n\n    def has_capacity(self) -&gt; bool:\n        \"\"\"Check the queue has capacity to add more items.\n\n        Returns:\n            bool: true if it is safe to add more to the queue.\n        \"\"\"\n        return self.get_count() &lt; self.capacity\n\n    def add_item(self, queue_item: Any):\n        \"\"\"Add item to the queue, not blocking.\n\n        Args:\n            queue_item (Any): The item to be added.\n        \"\"\"\n        with self.count_lock:\n            self.count.set(self.count.get() + 1)\n            self.queue.put_nowait(queue_item)\n\n    def get_item_blocking(self) -&gt; Any:\n        \"\"\"Get the next item in the queue while blocking.\n\n        Returns:\n            Any: the next item.\n        \"\"\"\n        queue_item = self.queue.get()\n        with self.count_lock:\n            self.count.set(self.count.get() - 1)\n        return queue_item\n\n    def get_latest_item(self) -&gt; Any:\n        \"\"\"Get the latest item on the queue.\n\n        Returns:\n            Any: the latest item. None if the queue is empty\n        \"\"\"\n        if self.get_count() == 0:\n            return None\n        last_queue_item = None\n        # hold onto the lock so not competing with other end to add states\n        with self.count_lock:\n            count = self.count.get()\n            while count &gt; 0:\n                last_queue_item = self.queue.get_nowait()\n                count -= 1\n            self.count.set(count)\n        return last_queue_item\n</code></pre>"},{"location":"reference/controller/base_bridge/#src.controller.base_bridge.BaseBridge.__init__","title":"<code>__init__()</code>","text":"<p>Initialise a bridge.</p> Source code in <code>src/controller/base_bridge.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialise a bridge.\"\"\"\n    manager = Manager()\n    self.queue = manager.Queue(self.capacity)\n    self.count_lock = manager.Lock()\n    self.count = manager.Value(int, 0)\n</code></pre>"},{"location":"reference/controller/base_bridge/#src.controller.base_bridge.BaseBridge.add_item","title":"<code>add_item(queue_item)</code>","text":"<p>Add item to the queue, not blocking.</p> <p>Parameters:</p> Name Type Description Default <code>queue_item</code> <code>Any</code> <p>The item to be added.</p> required Source code in <code>src/controller/base_bridge.py</code> <pre><code>def add_item(self, queue_item: Any):\n    \"\"\"Add item to the queue, not blocking.\n\n    Args:\n        queue_item (Any): The item to be added.\n    \"\"\"\n    with self.count_lock:\n        self.count.set(self.count.get() + 1)\n        self.queue.put_nowait(queue_item)\n</code></pre>"},{"location":"reference/controller/base_bridge/#src.controller.base_bridge.BaseBridge.get_count","title":"<code>get_count()</code>","text":"<p>Get the current count of items in the queue.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>the number of items on the queue</p> Source code in <code>src/controller/base_bridge.py</code> <pre><code>def get_count(self) -&gt; int:\n    \"\"\"Get the current count of items in the queue.\n\n    Returns:\n        int: the number of items on the queue\n    \"\"\"\n    return self.count.get()\n</code></pre>"},{"location":"reference/controller/base_bridge/#src.controller.base_bridge.BaseBridge.get_item_blocking","title":"<code>get_item_blocking()</code>","text":"<p>Get the next item in the queue while blocking.</p> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>the next item.</p> Source code in <code>src/controller/base_bridge.py</code> <pre><code>def get_item_blocking(self) -&gt; Any:\n    \"\"\"Get the next item in the queue while blocking.\n\n    Returns:\n        Any: the next item.\n    \"\"\"\n    queue_item = self.queue.get()\n    with self.count_lock:\n        self.count.set(self.count.get() - 1)\n    return queue_item\n</code></pre>"},{"location":"reference/controller/base_bridge/#src.controller.base_bridge.BaseBridge.get_latest_item","title":"<code>get_latest_item()</code>","text":"<p>Get the latest item on the queue.</p> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>the latest item. None if the queue is empty</p> Source code in <code>src/controller/base_bridge.py</code> <pre><code>def get_latest_item(self) -&gt; Any:\n    \"\"\"Get the latest item on the queue.\n\n    Returns:\n        Any: the latest item. None if the queue is empty\n    \"\"\"\n    if self.get_count() == 0:\n        return None\n    last_queue_item = None\n    # hold onto the lock so not competing with other end to add states\n    with self.count_lock:\n        count = self.count.get()\n        while count &gt; 0:\n            last_queue_item = self.queue.get_nowait()\n            count -= 1\n        self.count.set(count)\n    return last_queue_item\n</code></pre>"},{"location":"reference/controller/base_bridge/#src.controller.base_bridge.BaseBridge.has_capacity","title":"<code>has_capacity()</code>","text":"<p>Check the queue has capacity to add more items.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>true if it is safe to add more to the queue.</p> Source code in <code>src/controller/base_bridge.py</code> <pre><code>def has_capacity(self) -&gt; bool:\n    \"\"\"Check the queue has capacity to add more items.\n\n    Returns:\n        bool: true if it is safe to add more to the queue.\n    \"\"\"\n    return self.get_count() &lt; self.capacity\n</code></pre>"},{"location":"reference/controller/learning_system_controller/","title":"Learning System Controller","text":""},{"location":"reference/controller/learning_system_controller/#src.controller.learning_system_controller.LearningSystemController","title":"<code>LearningSystemController</code>","text":"<p>             Bases: <code>object</code></p> <p>Controller for managing learning systems.</p> Source code in <code>src/controller/learning_system_controller.py</code> <pre><code>class LearningSystemController(object):\n    \"\"\"Controller for managing learning systems.\"\"\"\n\n    def __init__(\n        self,\n        system: LearningSystem,\n    ) -&gt; None:\n        \"\"\"Initialise the learning system controller.\n\n        Args:\n            system (LearningSystem): the learning system to control\n        \"\"\"\n        self.system = system\n\n        self.user_action_bridge = UserActionBridge()\n        self.state_update_bridge = StateUpdateBridge()\n        self.auto = False\n\n    def model_mainloop(\n        self,\n    ):\n        \"\"\"Run the main loop of the model process.\n\n        Raises:\n            RuntimeError: if an unsupported action is made.\n        \"\"\"\n        user_action_bridge = self.user_action_bridge\n        while True:\n            action = user_action_bridge.get_action()\n            match action:\n                case UserActionMessage(action=UserAction.one_step):\n                    self.one_step()\n                    self.send_current_state()\n                case UserActionMessage(action=UserAction.start_auto):\n                    self.auto = True\n\n                case UserActionMessage(action=UserAction.stop_auto):\n                    self.auto = False\n                case UserActionMessage(action=UserAction.reset):\n                    self.system.reset_state()\n                    self.send_current_state()\n                case UserActionMessage(action=UserAction.fetch_current_state):\n                    self.send_current_state()\n                case UserActionMessage(\n                    action=UserAction.set_display_mode, payload=display_mode\n                ):\n                    self.system.set_display_mode(display_mode)\n                    self.send_current_state()\n                case _:\n                    raise RuntimeError(\"Unknown action performed.\")\n\n            while self.__can_auto_step():\n                self.one_step()\n\n    def one_step(self):\n        \"\"\"Perform one step.\"\"\"\n        self.system.perform_action()\n        self.send_current_state()\n\n    def send_current_state(self):\n        \"\"\"Send the current state to the view.\"\"\"\n        current_state = self.system.get_current_state()\n        self.state_update_bridge.update_state(current_state)\n\n    def __can_auto_step(self) -&gt; bool:\n        return (\n            self.auto\n            and not self.user_action_bridge.has_new_action()\n            and self.state_update_bridge.has_capacity()\n        )\n</code></pre>"},{"location":"reference/controller/learning_system_controller/#src.controller.learning_system_controller.LearningSystemController.__init__","title":"<code>__init__(system)</code>","text":"<p>Initialise the learning system controller.</p> <p>Parameters:</p> Name Type Description Default <code>system</code> <code>LearningSystem</code> <p>the learning system to control</p> required Source code in <code>src/controller/learning_system_controller.py</code> <pre><code>def __init__(\n    self,\n    system: LearningSystem,\n) -&gt; None:\n    \"\"\"Initialise the learning system controller.\n\n    Args:\n        system (LearningSystem): the learning system to control\n    \"\"\"\n    self.system = system\n\n    self.user_action_bridge = UserActionBridge()\n    self.state_update_bridge = StateUpdateBridge()\n    self.auto = False\n</code></pre>"},{"location":"reference/controller/learning_system_controller/#src.controller.learning_system_controller.LearningSystemController.model_mainloop","title":"<code>model_mainloop()</code>","text":"<p>Run the main loop of the model process.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if an unsupported action is made.</p> Source code in <code>src/controller/learning_system_controller.py</code> <pre><code>def model_mainloop(\n    self,\n):\n    \"\"\"Run the main loop of the model process.\n\n    Raises:\n        RuntimeError: if an unsupported action is made.\n    \"\"\"\n    user_action_bridge = self.user_action_bridge\n    while True:\n        action = user_action_bridge.get_action()\n        match action:\n            case UserActionMessage(action=UserAction.one_step):\n                self.one_step()\n                self.send_current_state()\n            case UserActionMessage(action=UserAction.start_auto):\n                self.auto = True\n\n            case UserActionMessage(action=UserAction.stop_auto):\n                self.auto = False\n            case UserActionMessage(action=UserAction.reset):\n                self.system.reset_state()\n                self.send_current_state()\n            case UserActionMessage(action=UserAction.fetch_current_state):\n                self.send_current_state()\n            case UserActionMessage(\n                action=UserAction.set_display_mode, payload=display_mode\n            ):\n                self.system.set_display_mode(display_mode)\n                self.send_current_state()\n            case _:\n                raise RuntimeError(\"Unknown action performed.\")\n\n        while self.__can_auto_step():\n            self.one_step()\n</code></pre>"},{"location":"reference/controller/learning_system_controller/#src.controller.learning_system_controller.LearningSystemController.one_step","title":"<code>one_step()</code>","text":"<p>Perform one step.</p> Source code in <code>src/controller/learning_system_controller.py</code> <pre><code>def one_step(self):\n    \"\"\"Perform one step.\"\"\"\n    self.system.perform_action()\n    self.send_current_state()\n</code></pre>"},{"location":"reference/controller/learning_system_controller/#src.controller.learning_system_controller.LearningSystemController.send_current_state","title":"<code>send_current_state()</code>","text":"<p>Send the current state to the view.</p> Source code in <code>src/controller/learning_system_controller.py</code> <pre><code>def send_current_state(self):\n    \"\"\"Send the current state to the view.\"\"\"\n    current_state = self.system.get_current_state()\n    self.state_update_bridge.update_state(current_state)\n</code></pre>"},{"location":"reference/controller/learning_system_controller_factory/","title":"Learning System Controller Factory","text":""},{"location":"reference/controller/learning_system_controller_factory/#src.controller.learning_system_controller_factory.LearningSystemControllerFactory","title":"<code>LearningSystemControllerFactory</code>","text":"<p>             Bases: <code>object</code></p> <p>Factory method for creating LearningSystemControllers.</p> Source code in <code>src/controller/learning_system_controller_factory.py</code> <pre><code>class LearningSystemControllerFactory(object):\n    \"\"\"Factory method for creating LearningSystemControllers.\"\"\"\n\n    def create_controller(\n        self, agent: AgentOptions, dynamics: DynamicsOptions\n    ) -&gt; LearningSystemController:\n        \"\"\"Create a new LearningSystemController.\n\n        Args:\n            agent (AgentOptions): the agent in the learning system.\n            dynamics (DynamicsOptions): the dynamics in the learning system.\n\n        Returns:\n            LearningSystemController: The controller\n        \"\"\"\n        system = LearningSystem(agent, dynamics)\n        controller = LearningSystemController(system)\n\n        model_process = Process(target=controller.model_mainloop, daemon=True)\n        model_process.start()\n\n        return controller\n</code></pre>"},{"location":"reference/controller/learning_system_controller_factory/#src.controller.learning_system_controller_factory.LearningSystemControllerFactory.create_controller","title":"<code>create_controller(agent, dynamics)</code>","text":"<p>Create a new LearningSystemController.</p> <p>Parameters:</p> Name Type Description Default <code>agent</code> <code>AgentOptions</code> <p>the agent in the learning system.</p> required <code>dynamics</code> <code>DynamicsOptions</code> <p>the dynamics in the learning system.</p> required <p>Returns:</p> Name Type Description <code>LearningSystemController</code> <code>LearningSystemController</code> <p>The controller</p> Source code in <code>src/controller/learning_system_controller_factory.py</code> <pre><code>def create_controller(\n    self, agent: AgentOptions, dynamics: DynamicsOptions\n) -&gt; LearningSystemController:\n    \"\"\"Create a new LearningSystemController.\n\n    Args:\n        agent (AgentOptions): the agent in the learning system.\n        dynamics (DynamicsOptions): the dynamics in the learning system.\n\n    Returns:\n        LearningSystemController: The controller\n    \"\"\"\n    system = LearningSystem(agent, dynamics)\n    controller = LearningSystemController(system)\n\n    model_process = Process(target=controller.model_mainloop, daemon=True)\n    model_process.start()\n\n    return controller\n</code></pre>"},{"location":"reference/controller/state_update_bridge/","title":"State Update Bridge","text":""},{"location":"reference/controller/state_update_bridge/#src.controller.state_update_bridge.StateUpdateBridge","title":"<code>StateUpdateBridge</code>","text":"<p>             Bases: <code>BaseBridge</code></p> <p>Bridge for passing state updates to the view.</p> Source code in <code>src/controller/state_update_bridge.py</code> <pre><code>class StateUpdateBridge(BaseBridge):\n    \"\"\"Bridge for passing state updates to the view.\"\"\"\n\n    def update_state(self, state: StateDescription):\n        \"\"\"Set the new state to be displayed.\n\n        Args:\n            state (StateDescription): The new state.\n        \"\"\"\n        self.add_item(state)\n\n    def get_latest_state(self) -&gt; Optional[StateDescription]:\n        \"\"\"Get the last (most recent) new state.\n\n        Returns:\n            Optional[StateDescription]: the new state, none if none has been set\n        \"\"\"\n        return self.get_latest_item()\n</code></pre>"},{"location":"reference/controller/state_update_bridge/#src.controller.state_update_bridge.StateUpdateBridge.get_latest_state","title":"<code>get_latest_state()</code>","text":"<p>Get the last (most recent) new state.</p> <p>Returns:</p> Type Description <code>Optional[StateDescription]</code> <p>Optional[StateDescription]: the new state, none if none has been set</p> Source code in <code>src/controller/state_update_bridge.py</code> <pre><code>def get_latest_state(self) -&gt; Optional[StateDescription]:\n    \"\"\"Get the last (most recent) new state.\n\n    Returns:\n        Optional[StateDescription]: the new state, none if none has been set\n    \"\"\"\n    return self.get_latest_item()\n</code></pre>"},{"location":"reference/controller/state_update_bridge/#src.controller.state_update_bridge.StateUpdateBridge.update_state","title":"<code>update_state(state)</code>","text":"<p>Set the new state to be displayed.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>StateDescription</code> <p>The new state.</p> required Source code in <code>src/controller/state_update_bridge.py</code> <pre><code>def update_state(self, state: StateDescription):\n    \"\"\"Set the new state to be displayed.\n\n    Args:\n        state (StateDescription): The new state.\n    \"\"\"\n    self.add_item(state)\n</code></pre>"},{"location":"reference/controller/user_action_bridge/","title":"User Action Bridge","text":""},{"location":"reference/controller/user_action_bridge/#src.controller.user_action_bridge.UserAction","title":"<code>UserAction</code>","text":"<p>             Bases: <code>Enum</code></p> <p>Enumerate all possible user actions.</p> Source code in <code>src/controller/user_action_bridge.py</code> <pre><code>class UserAction(Enum):\n    \"\"\"Enumerate all possible user actions.\"\"\"\n\n    one_step = 0\n    start_auto = 1\n    stop_auto = 2\n    reset = 3\n    fetch_current_state = 4\n    set_display_mode = 5\n</code></pre>"},{"location":"reference/controller/user_action_bridge/#src.controller.user_action_bridge.UserActionBridge","title":"<code>UserActionBridge</code>","text":"<p>             Bases: <code>BaseBridge</code></p> <p>Bridge for passing the user actions from the view to the model.</p> Source code in <code>src/controller/user_action_bridge.py</code> <pre><code>class UserActionBridge(BaseBridge):\n    \"\"\"Bridge for passing the user actions from the view to the model.\"\"\"\n\n    def submit_action(self, action: UserAction, payload: Any = None):\n        \"\"\"Submit an action to be processed.\n\n        Args:\n            action (UserAction): the action the user has performed.\n            payload (Any): the data to send, defaults to None.\n        \"\"\"\n        self.add_item(UserActionMessage(action, payload))\n\n    def has_new_action(self) -&gt; bool:\n        \"\"\"Is there a new action to process.\n\n        Returns:\n            bool: true when there is another action to consider.\n        \"\"\"\n        return self.get_count() &gt; 0\n\n    def get_action(self) -&gt; UserActionMessage:\n        \"\"\"Get the latest action the user has performed.\n\n        This is blocking.\n\n        Returns:\n            UserActionMessage: the action that has been performed\n        \"\"\"\n        return self.get_item_blocking()\n</code></pre>"},{"location":"reference/controller/user_action_bridge/#src.controller.user_action_bridge.UserActionBridge.get_action","title":"<code>get_action()</code>","text":"<p>Get the latest action the user has performed.</p> <p>This is blocking.</p> <p>Returns:</p> Name Type Description <code>UserActionMessage</code> <code>UserActionMessage</code> <p>the action that has been performed</p> Source code in <code>src/controller/user_action_bridge.py</code> <pre><code>def get_action(self) -&gt; UserActionMessage:\n    \"\"\"Get the latest action the user has performed.\n\n    This is blocking.\n\n    Returns:\n        UserActionMessage: the action that has been performed\n    \"\"\"\n    return self.get_item_blocking()\n</code></pre>"},{"location":"reference/controller/user_action_bridge/#src.controller.user_action_bridge.UserActionBridge.has_new_action","title":"<code>has_new_action()</code>","text":"<p>Is there a new action to process.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>true when there is another action to consider.</p> Source code in <code>src/controller/user_action_bridge.py</code> <pre><code>def has_new_action(self) -&gt; bool:\n    \"\"\"Is there a new action to process.\n\n    Returns:\n        bool: true when there is another action to consider.\n    \"\"\"\n    return self.get_count() &gt; 0\n</code></pre>"},{"location":"reference/controller/user_action_bridge/#src.controller.user_action_bridge.UserActionBridge.submit_action","title":"<code>submit_action(action, payload=None)</code>","text":"<p>Submit an action to be processed.</p> <p>Parameters:</p> Name Type Description Default <code>action</code> <code>UserAction</code> <p>the action the user has performed.</p> required <code>payload</code> <code>Any</code> <p>the data to send, defaults to None.</p> <code>None</code> Source code in <code>src/controller/user_action_bridge.py</code> <pre><code>def submit_action(self, action: UserAction, payload: Any = None):\n    \"\"\"Submit an action to be processed.\n\n    Args:\n        action (UserAction): the action the user has performed.\n        payload (Any): the data to send, defaults to None.\n    \"\"\"\n    self.add_item(UserActionMessage(action, payload))\n</code></pre>"},{"location":"reference/controller/user_action_bridge/#src.controller.user_action_bridge.UserActionMessage","title":"<code>UserActionMessage</code>","text":"<p>             Bases: <code>object</code></p> <p>Encapsulates a user action and its data.</p> Source code in <code>src/controller/user_action_bridge.py</code> <pre><code>class UserActionMessage(object):\n    \"\"\"Encapsulates a user action and its data.\"\"\"\n\n    def __init__(self, action: UserAction, payload: Any = None) -&gt; None:\n        \"\"\"Create a user action object.\n\n        Args:\n            action (UserAction): the action to be performed\n            payload (Any): any related data\n        \"\"\"\n        self.action = action\n        self.payload = payload\n</code></pre>"},{"location":"reference/controller/user_action_bridge/#src.controller.user_action_bridge.UserActionMessage.__init__","title":"<code>__init__(action, payload=None)</code>","text":"<p>Create a user action object.</p> <p>Parameters:</p> Name Type Description Default <code>action</code> <code>UserAction</code> <p>the action to be performed</p> required <code>payload</code> <code>Any</code> <p>any related data</p> <code>None</code> Source code in <code>src/controller/user_action_bridge.py</code> <pre><code>def __init__(self, action: UserAction, payload: Any = None) -&gt; None:\n    \"\"\"Create a user action object.\n\n    Args:\n        action (UserAction): the action to be performed\n        payload (Any): any related data\n    \"\"\"\n    self.action = action\n    self.payload = payload\n</code></pre>"},{"location":"reference/model/","title":"Model","text":"<p>This Package contains the model.</p> <p>The model is the reinforcement learning code</p>"},{"location":"reference/model/agents/","title":"Agents","text":"<p>This package contains the agents.</p> <p>the agents should that will learn and generate policies</p>"},{"location":"reference/model/agents/base_agent/","title":"Base Agent","text":""},{"location":"reference/model/agents/base_agent/#src.model.agents.base_agent.BaseAgent","title":"<code>BaseAgent</code>","text":"<p>             Bases: <code>object</code></p> <p>Provides the common base for different learning agents.</p> Source code in <code>src/model/agents/base_agent.py</code> <pre><code>class BaseAgent(object):\n    \"\"\"Provides the common base for different learning agents.\"\"\"\n\n    def __init__(self, config: AgentConfig) -&gt; None:\n        \"\"\"Initialise an agent.\n\n        Args:\n            config (AgentConfig): the configuration for the agent.\n        \"\"\"\n        self.config = config\n\n    def evaluate_policy(self, state: int) -&gt; Action:\n        \"\"\"Decide on the action this agent would take in a given state.\n\n        Args:\n            state (int): the state the agent is performing this action\n\n        Raises:\n            NotImplementedError: If this method has not been overridden by\n                concrete agent.\n\n        Returns:\n            Action: the action to take in this state\n        \"\"\"\n        self.__throw_not_implemented()\n        return Action.down\n\n    def record_transition(\n        self,\n        previous_state: int,\n        previous_action: Action,\n        new_state: int,\n        reward: float,\n    ) -&gt; None:\n        \"\"\"Provide the agent with the information from a transition.\n\n        Args:\n            previous_state (int): the state before the action was taken\n            previous_action (Action): the action that was taken.\n            new_state (int): The resulting state after the action has been taken\n            reward (float): the reward for performing this action\n\n        Raises:\n            NotImplementedError: If this method has not been overridden by\n                concrete agent.\n        \"\"\"\n        self.__throw_not_implemented()\n\n    def get_state_value(self, state: int) -&gt; float:\n        \"\"\"Get the agents interpretation of the value of this state.\n\n        Args:\n            state (int): the state to evaluate\n\n        Raises:\n            NotImplementedError: If this method has not been overridden by\n                concrete agent.\n\n        Returns:\n            float: the agents interpretation of the value of this state\n        \"\"\"\n        self.__throw_not_implemented()\n        return 0\n\n    def get_state_action_value(self, state: int, action: Action) -&gt; float:\n        \"\"\"Get the agents interpretation of an actions value.\n\n        allows for visualisations to be made\n\n        Args:\n            state (int): the state to perform the action in\n            action (Action): the action to evaluate\n\n        Raises:\n            NotImplementedError: If this method has not been overridden by\n                concrete agent.\n\n        Returns:\n            float: the agents interpretation of the value of this state and\n            action\n        \"\"\"\n        self.__throw_not_implemented()\n        return 0\n\n    def __throw_not_implemented(self):\n        raise NotImplementedError(\n            \"This method must be overridden by concrete agent\"\n        )\n</code></pre>"},{"location":"reference/model/agents/base_agent/#src.model.agents.base_agent.BaseAgent.__init__","title":"<code>__init__(config)</code>","text":"<p>Initialise an agent.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>AgentConfig</code> <p>the configuration for the agent.</p> required Source code in <code>src/model/agents/base_agent.py</code> <pre><code>def __init__(self, config: AgentConfig) -&gt; None:\n    \"\"\"Initialise an agent.\n\n    Args:\n        config (AgentConfig): the configuration for the agent.\n    \"\"\"\n    self.config = config\n</code></pre>"},{"location":"reference/model/agents/base_agent/#src.model.agents.base_agent.BaseAgent.evaluate_policy","title":"<code>evaluate_policy(state)</code>","text":"<p>Decide on the action this agent would take in a given state.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>int</code> <p>the state the agent is performing this action</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If this method has not been overridden by concrete agent.</p> <p>Returns:</p> Name Type Description <code>Action</code> <code>Action</code> <p>the action to take in this state</p> Source code in <code>src/model/agents/base_agent.py</code> <pre><code>def evaluate_policy(self, state: int) -&gt; Action:\n    \"\"\"Decide on the action this agent would take in a given state.\n\n    Args:\n        state (int): the state the agent is performing this action\n\n    Raises:\n        NotImplementedError: If this method has not been overridden by\n            concrete agent.\n\n    Returns:\n        Action: the action to take in this state\n    \"\"\"\n    self.__throw_not_implemented()\n    return Action.down\n</code></pre>"},{"location":"reference/model/agents/base_agent/#src.model.agents.base_agent.BaseAgent.get_state_action_value","title":"<code>get_state_action_value(state, action)</code>","text":"<p>Get the agents interpretation of an actions value.</p> <p>allows for visualisations to be made</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>int</code> <p>the state to perform the action in</p> required <code>action</code> <code>Action</code> <p>the action to evaluate</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If this method has not been overridden by concrete agent.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the agents interpretation of the value of this state and</p> <code>float</code> <p>action</p> Source code in <code>src/model/agents/base_agent.py</code> <pre><code>def get_state_action_value(self, state: int, action: Action) -&gt; float:\n    \"\"\"Get the agents interpretation of an actions value.\n\n    allows for visualisations to be made\n\n    Args:\n        state (int): the state to perform the action in\n        action (Action): the action to evaluate\n\n    Raises:\n        NotImplementedError: If this method has not been overridden by\n            concrete agent.\n\n    Returns:\n        float: the agents interpretation of the value of this state and\n        action\n    \"\"\"\n    self.__throw_not_implemented()\n    return 0\n</code></pre>"},{"location":"reference/model/agents/base_agent/#src.model.agents.base_agent.BaseAgent.get_state_value","title":"<code>get_state_value(state)</code>","text":"<p>Get the agents interpretation of the value of this state.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>int</code> <p>the state to evaluate</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If this method has not been overridden by concrete agent.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the agents interpretation of the value of this state</p> Source code in <code>src/model/agents/base_agent.py</code> <pre><code>def get_state_value(self, state: int) -&gt; float:\n    \"\"\"Get the agents interpretation of the value of this state.\n\n    Args:\n        state (int): the state to evaluate\n\n    Raises:\n        NotImplementedError: If this method has not been overridden by\n            concrete agent.\n\n    Returns:\n        float: the agents interpretation of the value of this state\n    \"\"\"\n    self.__throw_not_implemented()\n    return 0\n</code></pre>"},{"location":"reference/model/agents/base_agent/#src.model.agents.base_agent.BaseAgent.record_transition","title":"<code>record_transition(previous_state, previous_action, new_state, reward)</code>","text":"<p>Provide the agent with the information from a transition.</p> <p>Parameters:</p> Name Type Description Default <code>previous_state</code> <code>int</code> <p>the state before the action was taken</p> required <code>previous_action</code> <code>Action</code> <p>the action that was taken.</p> required <code>new_state</code> <code>int</code> <p>The resulting state after the action has been taken</p> required <code>reward</code> <code>float</code> <p>the reward for performing this action</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If this method has not been overridden by concrete agent.</p> Source code in <code>src/model/agents/base_agent.py</code> <pre><code>def record_transition(\n    self,\n    previous_state: int,\n    previous_action: Action,\n    new_state: int,\n    reward: float,\n) -&gt; None:\n    \"\"\"Provide the agent with the information from a transition.\n\n    Args:\n        previous_state (int): the state before the action was taken\n        previous_action (Action): the action that was taken.\n        new_state (int): The resulting state after the action has been taken\n        reward (float): the reward for performing this action\n\n    Raises:\n        NotImplementedError: If this method has not been overridden by\n            concrete agent.\n    \"\"\"\n    self.__throw_not_implemented()\n</code></pre>"},{"location":"reference/model/agents/q_learning/","title":"Q Learning","text":"<p>This package contains the code for a Q-learning agent.</p>"},{"location":"reference/model/agents/q_learning/agent/","title":"Agent","text":""},{"location":"reference/model/agents/q_learning/agent/#src.model.agents.q_learning.agent.QLearningAgent","title":"<code>QLearningAgent</code>","text":"<p>             Bases: <code>BaseAgent</code></p> <p>Agent that learns q-value table to make decisions.</p> Source code in <code>src/model/agents/q_learning/agent.py</code> <pre><code>class QLearningAgent(BaseAgent):\n    \"\"\"Agent that learns q-value table to make decisions.\"\"\"\n\n    replay_queue_length = 100\n\n    def __init__(\n        self,\n        config: AgentConfig,\n    ) -&gt; None:\n        \"\"\"Initialise the agent.\n\n        Args:\n            config (AgentConfig): the configuration for the agent.\n        \"\"\"\n        super().__init__(config)\n\n        self.table = DynamicQTable(config.learning_rate())\n        self.observation_queue = RewardReplayQueue(\n            self.table, self.replay_queue_length, config.discount_rate()\n        )\n        self.exploration_ratio = config.exploration_ratio()\n\n    def get_state_action_value(self, state: int, action: Action) -&gt; float:\n        \"\"\"Get the agents interpretation value of a given state-action.\n\n        Args:\n            state (int): the state the action is performed in\n            action (Action): the action to get the value of\n\n        Returns:\n            float: the expected value for this state and action\n        \"\"\"\n        return self.table.get_value(state, action)\n\n    def get_state_value(self, state: int) -&gt; float:\n        \"\"\"Get the agents interpretation of the value of this state.\n\n        Args:\n            state (int): the state to evaluate\n\n        Returns:\n            float: the agents interpretation of the value of this state\n        \"\"\"\n        return self.table.calculate_state_value(state)\n\n    def evaluate_policy(self, state: int) -&gt; Action:\n        \"\"\"Decide on the action this agent would take in a given state.\n\n        picks the best action based upon the value table.\n\n        Args:\n            state (int): the state the agent is performing this action\n\n\n        Returns:\n            Action: the action to take in this state\n        \"\"\"\n        best_action = choice(list(Action))\n        if random() &lt; self.exploration_ratio:\n            return best_action\n\n        best_action_value = float(\"-inf\")\n        for action in Action:\n            action_value = self.table.get_value(state, action)\n            if action_value &gt; best_action_value:\n                best_action_value = action_value\n                best_action = action\n        return best_action\n\n    def record_transition(\n        self,\n        previous_state: int,\n        previous_action: Action,\n        new_state: int,\n        reward: float,\n    ) -&gt; None:\n        \"\"\"Provide the agent with the information from a transition.\n\n        Args:\n            previous_state (int): the state before the action was taken\n            previous_action (Action): the action that was taken.\n            new_state (int): The resulting state after the action has been taken\n            reward (float): the reward for performing this action\n\n        \"\"\"\n        self.observation_queue.add_observation(\n            previous_state, previous_action, new_state, reward\n        )\n</code></pre>"},{"location":"reference/model/agents/q_learning/agent/#src.model.agents.q_learning.agent.QLearningAgent.__init__","title":"<code>__init__(config)</code>","text":"<p>Initialise the agent.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>AgentConfig</code> <p>the configuration for the agent.</p> required Source code in <code>src/model/agents/q_learning/agent.py</code> <pre><code>def __init__(\n    self,\n    config: AgentConfig,\n) -&gt; None:\n    \"\"\"Initialise the agent.\n\n    Args:\n        config (AgentConfig): the configuration for the agent.\n    \"\"\"\n    super().__init__(config)\n\n    self.table = DynamicQTable(config.learning_rate())\n    self.observation_queue = RewardReplayQueue(\n        self.table, self.replay_queue_length, config.discount_rate()\n    )\n    self.exploration_ratio = config.exploration_ratio()\n</code></pre>"},{"location":"reference/model/agents/q_learning/agent/#src.model.agents.q_learning.agent.QLearningAgent.evaluate_policy","title":"<code>evaluate_policy(state)</code>","text":"<p>Decide on the action this agent would take in a given state.</p> <p>picks the best action based upon the value table.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>int</code> <p>the state the agent is performing this action</p> required <p>Returns:</p> Name Type Description <code>Action</code> <code>Action</code> <p>the action to take in this state</p> Source code in <code>src/model/agents/q_learning/agent.py</code> <pre><code>def evaluate_policy(self, state: int) -&gt; Action:\n    \"\"\"Decide on the action this agent would take in a given state.\n\n    picks the best action based upon the value table.\n\n    Args:\n        state (int): the state the agent is performing this action\n\n\n    Returns:\n        Action: the action to take in this state\n    \"\"\"\n    best_action = choice(list(Action))\n    if random() &lt; self.exploration_ratio:\n        return best_action\n\n    best_action_value = float(\"-inf\")\n    for action in Action:\n        action_value = self.table.get_value(state, action)\n        if action_value &gt; best_action_value:\n            best_action_value = action_value\n            best_action = action\n    return best_action\n</code></pre>"},{"location":"reference/model/agents/q_learning/agent/#src.model.agents.q_learning.agent.QLearningAgent.get_state_action_value","title":"<code>get_state_action_value(state, action)</code>","text":"<p>Get the agents interpretation value of a given state-action.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>int</code> <p>the state the action is performed in</p> required <code>action</code> <code>Action</code> <p>the action to get the value of</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the expected value for this state and action</p> Source code in <code>src/model/agents/q_learning/agent.py</code> <pre><code>def get_state_action_value(self, state: int, action: Action) -&gt; float:\n    \"\"\"Get the agents interpretation value of a given state-action.\n\n    Args:\n        state (int): the state the action is performed in\n        action (Action): the action to get the value of\n\n    Returns:\n        float: the expected value for this state and action\n    \"\"\"\n    return self.table.get_value(state, action)\n</code></pre>"},{"location":"reference/model/agents/q_learning/agent/#src.model.agents.q_learning.agent.QLearningAgent.get_state_value","title":"<code>get_state_value(state)</code>","text":"<p>Get the agents interpretation of the value of this state.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>int</code> <p>the state to evaluate</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the agents interpretation of the value of this state</p> Source code in <code>src/model/agents/q_learning/agent.py</code> <pre><code>def get_state_value(self, state: int) -&gt; float:\n    \"\"\"Get the agents interpretation of the value of this state.\n\n    Args:\n        state (int): the state to evaluate\n\n    Returns:\n        float: the agents interpretation of the value of this state\n    \"\"\"\n    return self.table.calculate_state_value(state)\n</code></pre>"},{"location":"reference/model/agents/q_learning/agent/#src.model.agents.q_learning.agent.QLearningAgent.record_transition","title":"<code>record_transition(previous_state, previous_action, new_state, reward)</code>","text":"<p>Provide the agent with the information from a transition.</p> <p>Parameters:</p> Name Type Description Default <code>previous_state</code> <code>int</code> <p>the state before the action was taken</p> required <code>previous_action</code> <code>Action</code> <p>the action that was taken.</p> required <code>new_state</code> <code>int</code> <p>The resulting state after the action has been taken</p> required <code>reward</code> <code>float</code> <p>the reward for performing this action</p> required Source code in <code>src/model/agents/q_learning/agent.py</code> <pre><code>def record_transition(\n    self,\n    previous_state: int,\n    previous_action: Action,\n    new_state: int,\n    reward: float,\n) -&gt; None:\n    \"\"\"Provide the agent with the information from a transition.\n\n    Args:\n        previous_state (int): the state before the action was taken\n        previous_action (Action): the action that was taken.\n        new_state (int): The resulting state after the action has been taken\n        reward (float): the reward for performing this action\n\n    \"\"\"\n    self.observation_queue.add_observation(\n        previous_state, previous_action, new_state, reward\n    )\n</code></pre>"},{"location":"reference/model/agents/q_learning/dynamic_q_table/","title":"Dynamic Q Table","text":""},{"location":"reference/model/agents/q_learning/dynamic_q_table/#src.model.agents.q_learning.dynamic_q_table.DynamicQTable","title":"<code>DynamicQTable</code>","text":"<p>             Bases: <code>object</code></p> <p>Class for storing and recalling action-state values.</p> Source code in <code>src/model/agents/q_learning/dynamic_q_table.py</code> <pre><code>class DynamicQTable(object):\n    \"\"\"Class for storing and recalling action-state values.\"\"\"\n\n    def __init__(self, learning_rate: float) -&gt; None:\n        \"\"\"Initialise a new blank Q Table.\n\n        Args:\n            learning_rate (float): the rate at which to change the value with\n                each update.\n        \"\"\"\n        self.table: Dict[Tuple[int, Action], float] = {}\n        self.learning_rate = learning_rate\n\n    def update_value(self, state: int, action: Action, q_value: float):\n        \"\"\"Update the value at state and action based upon some observation.\n\n        the amount the value is changed depends on the magnitude of the learning\n        rate.\n\n        Args:\n            state (int): the state the action is performed in\n            action (Action): the action to update the value for\n            q_value (float): the new observation of the Q value\n        \"\"\"\n        existing_value = self.get_value(state, action)\n        new_value = existing_value + self.learning_rate * (\n            q_value - existing_value\n        )\n        self.set_value(state, action, new_value)\n\n    def set_value(self, state: int, action: Action, q_value: float):\n        \"\"\"Set the value of a given state action pair.\n\n        This will overwrite any existing data.\n\n        Args:\n            state (int): the state the action is performed in\n            action (Action): the action to update the value for\n            q_value (float): the new value of this state action pair.\n        \"\"\"\n        self.table[(state, action)] = q_value\n\n    def get_value(self, state: int, action: Action) -&gt; float:\n        \"\"\"Get the current value of a give state and action.\n\n        if the state and action has no existing value associated with it then a\n          new value in the range 0-1 will be chosen\n\n        Args:\n            state (int): the state the action is performed in\n            action (Action): the action to get the value for\n\n        Returns:\n            float: current stored value at the given state-action pair.\n        \"\"\"\n        key = (state, action)\n        existing_value = self.table.get(key, None)\n        if existing_value is not None:\n            return existing_value\n        new_value = self.__default_value()\n        self.table[key] = new_value\n        return new_value\n\n    def calculate_state_value(self, state: int) -&gt; float:\n        \"\"\"Calculate a state value.\n\n        based upon the current action value table and a policy that picks the\n        most valuable action.\n\n        Args:\n            state (int): the state to get the value for\n\n        Returns:\n            float: the value of the state.\n        \"\"\"\n        best_action_value = float(\"-inf\")\n        for action in Action:\n            action_value = self.get_value(state, action)\n            best_action_value = max(best_action_value, action_value)\n        return best_action_value\n\n    def __default_value(self) -&gt; float:\n        return np.random.rand() * self.learning_rate\n</code></pre>"},{"location":"reference/model/agents/q_learning/dynamic_q_table/#src.model.agents.q_learning.dynamic_q_table.DynamicQTable.__init__","title":"<code>__init__(learning_rate)</code>","text":"<p>Initialise a new blank Q Table.</p> <p>Parameters:</p> Name Type Description Default <code>learning_rate</code> <code>float</code> <p>the rate at which to change the value with each update.</p> required Source code in <code>src/model/agents/q_learning/dynamic_q_table.py</code> <pre><code>def __init__(self, learning_rate: float) -&gt; None:\n    \"\"\"Initialise a new blank Q Table.\n\n    Args:\n        learning_rate (float): the rate at which to change the value with\n            each update.\n    \"\"\"\n    self.table: Dict[Tuple[int, Action], float] = {}\n    self.learning_rate = learning_rate\n</code></pre>"},{"location":"reference/model/agents/q_learning/dynamic_q_table/#src.model.agents.q_learning.dynamic_q_table.DynamicQTable.calculate_state_value","title":"<code>calculate_state_value(state)</code>","text":"<p>Calculate a state value.</p> <p>based upon the current action value table and a policy that picks the most valuable action.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>int</code> <p>the state to get the value for</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the value of the state.</p> Source code in <code>src/model/agents/q_learning/dynamic_q_table.py</code> <pre><code>def calculate_state_value(self, state: int) -&gt; float:\n    \"\"\"Calculate a state value.\n\n    based upon the current action value table and a policy that picks the\n    most valuable action.\n\n    Args:\n        state (int): the state to get the value for\n\n    Returns:\n        float: the value of the state.\n    \"\"\"\n    best_action_value = float(\"-inf\")\n    for action in Action:\n        action_value = self.get_value(state, action)\n        best_action_value = max(best_action_value, action_value)\n    return best_action_value\n</code></pre>"},{"location":"reference/model/agents/q_learning/dynamic_q_table/#src.model.agents.q_learning.dynamic_q_table.DynamicQTable.get_value","title":"<code>get_value(state, action)</code>","text":"<p>Get the current value of a give state and action.</p> <p>if the state and action has no existing value associated with it then a   new value in the range 0-1 will be chosen</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>int</code> <p>the state the action is performed in</p> required <code>action</code> <code>Action</code> <p>the action to get the value for</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>current stored value at the given state-action pair.</p> Source code in <code>src/model/agents/q_learning/dynamic_q_table.py</code> <pre><code>def get_value(self, state: int, action: Action) -&gt; float:\n    \"\"\"Get the current value of a give state and action.\n\n    if the state and action has no existing value associated with it then a\n      new value in the range 0-1 will be chosen\n\n    Args:\n        state (int): the state the action is performed in\n        action (Action): the action to get the value for\n\n    Returns:\n        float: current stored value at the given state-action pair.\n    \"\"\"\n    key = (state, action)\n    existing_value = self.table.get(key, None)\n    if existing_value is not None:\n        return existing_value\n    new_value = self.__default_value()\n    self.table[key] = new_value\n    return new_value\n</code></pre>"},{"location":"reference/model/agents/q_learning/dynamic_q_table/#src.model.agents.q_learning.dynamic_q_table.DynamicQTable.set_value","title":"<code>set_value(state, action, q_value)</code>","text":"<p>Set the value of a given state action pair.</p> <p>This will overwrite any existing data.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>int</code> <p>the state the action is performed in</p> required <code>action</code> <code>Action</code> <p>the action to update the value for</p> required <code>q_value</code> <code>float</code> <p>the new value of this state action pair.</p> required Source code in <code>src/model/agents/q_learning/dynamic_q_table.py</code> <pre><code>def set_value(self, state: int, action: Action, q_value: float):\n    \"\"\"Set the value of a given state action pair.\n\n    This will overwrite any existing data.\n\n    Args:\n        state (int): the state the action is performed in\n        action (Action): the action to update the value for\n        q_value (float): the new value of this state action pair.\n    \"\"\"\n    self.table[(state, action)] = q_value\n</code></pre>"},{"location":"reference/model/agents/q_learning/dynamic_q_table/#src.model.agents.q_learning.dynamic_q_table.DynamicQTable.update_value","title":"<code>update_value(state, action, q_value)</code>","text":"<p>Update the value at state and action based upon some observation.</p> <p>the amount the value is changed depends on the magnitude of the learning rate.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>int</code> <p>the state the action is performed in</p> required <code>action</code> <code>Action</code> <p>the action to update the value for</p> required <code>q_value</code> <code>float</code> <p>the new observation of the Q value</p> required Source code in <code>src/model/agents/q_learning/dynamic_q_table.py</code> <pre><code>def update_value(self, state: int, action: Action, q_value: float):\n    \"\"\"Update the value at state and action based upon some observation.\n\n    the amount the value is changed depends on the magnitude of the learning\n    rate.\n\n    Args:\n        state (int): the state the action is performed in\n        action (Action): the action to update the value for\n        q_value (float): the new observation of the Q value\n    \"\"\"\n    existing_value = self.get_value(state, action)\n    new_value = existing_value + self.learning_rate * (\n        q_value - existing_value\n    )\n    self.set_value(state, action, new_value)\n</code></pre>"},{"location":"reference/model/agents/q_learning/reward_replay_queue/","title":"Reward Replay Queue","text":""},{"location":"reference/model/agents/q_learning/reward_replay_queue/#src.model.agents.q_learning.reward_replay_queue.RewardReplayQueue","title":"<code>RewardReplayQueue</code>","text":"<p>             Bases: <code>object</code></p> <p>A Queue for recording previous actions and replaying them.</p> <p>To allow for faster convergence and backwards propagation of value.</p> Source code in <code>src/model/agents/q_learning/reward_replay_queue.py</code> <pre><code>class RewardReplayQueue(object):\n    \"\"\"A Queue for recording previous actions and replaying them.\n\n    To allow for faster convergence and backwards propagation of value.\n    \"\"\"\n\n    def __init__(\n        self, q_table: DynamicQTable, queue_length: int, discount_rate: float\n    ) -&gt; None:\n        \"\"\"Create a new replay queue.\n\n        Args:\n            q_table (DynamicQTable): the q value table to update\n            queue_length (int): the maximum length of the queue.\n            discount_rate (float): the amount to discount future rewards.\n        \"\"\"\n        self.max_queue_length = queue_length\n        self.table = q_table\n        self.queue: List[observation_type] = []\n        self.discount_rate = discount_rate\n\n    def add_observation(\n        self,\n        previous_state: int,\n        previous_action: Action,\n        new_state: int,\n        reward: float,\n    ):\n        \"\"\"Add a new observation to the end of the queue.\n\n        Args:\n            previous_state (int): the state before the action was taken\n            previous_action (Action): the action that was taken.\n            new_state (int): The resulting state after the action has been taken\n            reward (float): the reward for performing this action\n        \"\"\"\n        self.__add_item((previous_state, previous_action, new_state, reward))\n        for observation in reversed(self.queue):\n            self.__update_q_value(observation)\n\n    def __update_q_value(self, observation: observation_type):\n        (previous_state, previous_action, new_state, reward) = observation\n\n        observed_value = (\n            reward\n            + self.discount_rate * self.table.calculate_state_value(new_state)\n        )\n        self.table.update_value(previous_state, previous_action, observed_value)\n\n    def __add_item(self, observation: observation_type):\n        self.queue.append(observation)\n        if len(self.queue) &gt; self.max_queue_length:\n            self.queue.pop(0)\n</code></pre>"},{"location":"reference/model/agents/q_learning/reward_replay_queue/#src.model.agents.q_learning.reward_replay_queue.RewardReplayQueue.__init__","title":"<code>__init__(q_table, queue_length, discount_rate)</code>","text":"<p>Create a new replay queue.</p> <p>Parameters:</p> Name Type Description Default <code>q_table</code> <code>DynamicQTable</code> <p>the q value table to update</p> required <code>queue_length</code> <code>int</code> <p>the maximum length of the queue.</p> required <code>discount_rate</code> <code>float</code> <p>the amount to discount future rewards.</p> required Source code in <code>src/model/agents/q_learning/reward_replay_queue.py</code> <pre><code>def __init__(\n    self, q_table: DynamicQTable, queue_length: int, discount_rate: float\n) -&gt; None:\n    \"\"\"Create a new replay queue.\n\n    Args:\n        q_table (DynamicQTable): the q value table to update\n        queue_length (int): the maximum length of the queue.\n        discount_rate (float): the amount to discount future rewards.\n    \"\"\"\n    self.max_queue_length = queue_length\n    self.table = q_table\n    self.queue: List[observation_type] = []\n    self.discount_rate = discount_rate\n</code></pre>"},{"location":"reference/model/agents/q_learning/reward_replay_queue/#src.model.agents.q_learning.reward_replay_queue.RewardReplayQueue.add_observation","title":"<code>add_observation(previous_state, previous_action, new_state, reward)</code>","text":"<p>Add a new observation to the end of the queue.</p> <p>Parameters:</p> Name Type Description Default <code>previous_state</code> <code>int</code> <p>the state before the action was taken</p> required <code>previous_action</code> <code>Action</code> <p>the action that was taken.</p> required <code>new_state</code> <code>int</code> <p>The resulting state after the action has been taken</p> required <code>reward</code> <code>float</code> <p>the reward for performing this action</p> required Source code in <code>src/model/agents/q_learning/reward_replay_queue.py</code> <pre><code>def add_observation(\n    self,\n    previous_state: int,\n    previous_action: Action,\n    new_state: int,\n    reward: float,\n):\n    \"\"\"Add a new observation to the end of the queue.\n\n    Args:\n        previous_state (int): the state before the action was taken\n        previous_action (Action): the action that was taken.\n        new_state (int): The resulting state after the action has been taken\n        reward (float): the reward for performing this action\n    \"\"\"\n    self.__add_item((previous_state, previous_action, new_state, reward))\n    for observation in reversed(self.queue):\n        self.__update_q_value(observation)\n</code></pre>"},{"location":"reference/model/agents/value_iteration/","title":"Value Iteration","text":"<p>This package contains the implementation of value iteration.</p> <p>This value iteration is used to drive an optimal agent.</p>"},{"location":"reference/model/agents/value_iteration/agent/","title":"Agent","text":""},{"location":"reference/model/agents/value_iteration/agent/#src.model.agents.value_iteration.agent.ValueIterationAgent","title":"<code>ValueIterationAgent</code>","text":"<p>             Bases: <code>BaseAgent</code></p> <p>Computes the optimal value table for a given dynamics.</p> <p>This agent uses that table with the dynamics to pick optimal actions.</p> Source code in <code>src/model/agents/value_iteration/agent.py</code> <pre><code>class ValueIterationAgent(BaseAgent):\n    \"\"\"Computes the optimal value table for a given dynamics.\n\n    This agent uses that table with the dynamics to pick optimal actions.\n    \"\"\"\n\n    def __init__(\n        self,\n        config: AgentConfig,\n        dynamics: BaseDynamics,\n    ) -&gt; None:\n        \"\"\"Initialise the agent.\n\n        Args:\n            config (AgentConfig): the configuration for the agent.\n            dynamics (BaseDynamics): the dynamics function used to build the\n                value table and pick optimal actions\n        \"\"\"\n        super().__init__(config)\n        self.dynamics = dynamics\n        self.dynamics_distribution = DynamicsDistribution(\n            config.sample_count(), dynamics\n        )\n        self.stopping_epsilon = config.stopping_epsilon()\n        self.discount_rate = config.discount_rate()\n        self.value_table: Optional[value_table_type] = None\n\n    def get_value_table(self) -&gt; value_table_type:\n        \"\"\"Get the value table for the provided dynamics.\n\n        If the value table has already been computed it will provide that. if\n        not it will compute a new value table, this can be quite costly based\n        upon the epsilon, number of states and discount rate.\n\n        Returns:\n            value_table_type: the value table for this mdp\n        \"\"\"\n        if self.value_table is not None:\n            return self.value_table\n\n        if not self.dynamics_distribution.has_compiled():\n            self.dynamics_distribution.compile()\n\n        self.value_table = self.compute_value_table()\n\n        return self.value_table\n\n    def compute_value_table(self) -&gt; value_table_type:\n        \"\"\"Compute the optimal value table with value iteration.\n\n        Returns:\n            value_table_type: the value table for the dynamics\n        \"\"\"\n        state_list = self.dynamics_distribution.list_states()\n        value_table = np.random.rand(len(state_list))\n        stopping_epsilon = self.stopping_epsilon\n        maximum_epsilon: float = 1\n        while maximum_epsilon &gt; stopping_epsilon:\n            maximum_epsilon = float(0)\n            for state in state_list:\n                new_value = self.compute_updated_value(value_table, state)\n                epsilon = abs(float(value_table[state]) - new_value)\n                value_table[state] = new_value\n                maximum_epsilon = max(epsilon, maximum_epsilon)\n        return value_table\n\n    def compute_updated_value(\n        self,\n        value_table: value_table_type,\n        state: int,\n    ) -&gt; float:\n        \"\"\"Compute the new value of the state based upon the latest value table.\n\n        Args:\n            value_table (value_table_type): our current expectation of value in\n                future states to base our estimate.\n            state (int): the state to calculate the value for.\n\n\n        Returns:\n            float: the new value for this state.\n        \"\"\"\n        action_observations = self.dynamics_distribution.observations[state]\n        state_value = float(0)\n        for action in Action:\n            state_value = max(\n                state_value,\n                self.distribution_value(\n                    action_observations[action.value],\n                    value_table,\n                ),\n            )\n        return state_value\n\n    def distribution_value(\n        self,\n        distribution: distribution_result,\n        value_table: value_table_type,\n    ) -&gt; float:\n        \"\"\"Compute the expected action-value from its distribution.\n\n        Args:\n            distribution (distribution_result): the distribution of\n                results to weight the rewards\n            value_table (value_table_type): our current expectation of value in\n                future states to base our estimate.\n\n        Returns:\n            float: the expected value for this state and action\n        \"\"\"\n        expected_value = 0\n        discount_rate = self.discount_rate\n        for next_state, (reward, frequency) in distribution.items():\n            expected_value += frequency * (\n                reward + discount_rate * value_table[next_state]\n            )\n        return expected_value\n\n    def get_state_action_value(self, state: int, action: Action) -&gt; float:\n        \"\"\"Compute the expected action-value of a given state.\n\n        Args:\n            state (int): the state the action is performed in\n            action (Action): the action to get the value of\n\n        Returns:\n            float: the expected value for this state and action\n        \"\"\"\n        value_table = self.get_value_table()\n        return self.distribution_value(\n            self.dynamics_distribution.observations[state][action.value],\n            value_table,\n        )\n\n    def get_state_value(self, state: int) -&gt; float:\n        \"\"\"Get the agents interpretation of the value of this state.\n\n        Args:\n            state (int): the state to evaluate\n\n        Returns:\n            float: the agents interpretation of the value of this state\n        \"\"\"\n        return self.get_value_table()[state]\n\n    def evaluate_policy(self, state: int) -&gt; Action:\n        \"\"\"Decide on the action this agent would take in a given state.\n\n        picks the best action based upon the value table.\n\n        Args:\n            state (int): the state the agent is performing this action\n\n\n        Returns:\n            Action: the action to take in this state\n        \"\"\"\n        best_action = random.choice(list(Action))\n        best_value = self.get_state_action_value(state, best_action)\n        # random default action to help break ties evenly\n        for action in Action:\n            if action is best_action:\n                continue\n            action_value = self.get_state_action_value(state, action)\n            if action_value &gt; best_value:\n                best_value = action_value\n                best_action = action\n\n        return best_action\n\n    def record_transition(\n        self,\n        previous_state: int,\n        previous_action: Action,\n        new_state: int,\n        reward: float,\n    ) -&gt; None:\n        \"\"\"Provide the agent with the information from a transition.\n\n        (not used by this agent)\n\n        Args:\n            previous_state (int): the state before the action was taken\n            previous_action (Action): the action that was taken.\n            new_state (int): The resulting state after the action has been taken\n            reward (float): the reward for performing this action\n\n        \"\"\"\n</code></pre>"},{"location":"reference/model/agents/value_iteration/agent/#src.model.agents.value_iteration.agent.ValueIterationAgent.__init__","title":"<code>__init__(config, dynamics)</code>","text":"<p>Initialise the agent.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>AgentConfig</code> <p>the configuration for the agent.</p> required <code>dynamics</code> <code>BaseDynamics</code> <p>the dynamics function used to build the value table and pick optimal actions</p> required Source code in <code>src/model/agents/value_iteration/agent.py</code> <pre><code>def __init__(\n    self,\n    config: AgentConfig,\n    dynamics: BaseDynamics,\n) -&gt; None:\n    \"\"\"Initialise the agent.\n\n    Args:\n        config (AgentConfig): the configuration for the agent.\n        dynamics (BaseDynamics): the dynamics function used to build the\n            value table and pick optimal actions\n    \"\"\"\n    super().__init__(config)\n    self.dynamics = dynamics\n    self.dynamics_distribution = DynamicsDistribution(\n        config.sample_count(), dynamics\n    )\n    self.stopping_epsilon = config.stopping_epsilon()\n    self.discount_rate = config.discount_rate()\n    self.value_table: Optional[value_table_type] = None\n</code></pre>"},{"location":"reference/model/agents/value_iteration/agent/#src.model.agents.value_iteration.agent.ValueIterationAgent.compute_updated_value","title":"<code>compute_updated_value(value_table, state)</code>","text":"<p>Compute the new value of the state based upon the latest value table.</p> <p>Parameters:</p> Name Type Description Default <code>value_table</code> <code>value_table_type</code> <p>our current expectation of value in future states to base our estimate.</p> required <code>state</code> <code>int</code> <p>the state to calculate the value for.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the new value for this state.</p> Source code in <code>src/model/agents/value_iteration/agent.py</code> <pre><code>def compute_updated_value(\n    self,\n    value_table: value_table_type,\n    state: int,\n) -&gt; float:\n    \"\"\"Compute the new value of the state based upon the latest value table.\n\n    Args:\n        value_table (value_table_type): our current expectation of value in\n            future states to base our estimate.\n        state (int): the state to calculate the value for.\n\n\n    Returns:\n        float: the new value for this state.\n    \"\"\"\n    action_observations = self.dynamics_distribution.observations[state]\n    state_value = float(0)\n    for action in Action:\n        state_value = max(\n            state_value,\n            self.distribution_value(\n                action_observations[action.value],\n                value_table,\n            ),\n        )\n    return state_value\n</code></pre>"},{"location":"reference/model/agents/value_iteration/agent/#src.model.agents.value_iteration.agent.ValueIterationAgent.compute_value_table","title":"<code>compute_value_table()</code>","text":"<p>Compute the optimal value table with value iteration.</p> <p>Returns:</p> Name Type Description <code>value_table_type</code> <code>value_table_type</code> <p>the value table for the dynamics</p> Source code in <code>src/model/agents/value_iteration/agent.py</code> <pre><code>def compute_value_table(self) -&gt; value_table_type:\n    \"\"\"Compute the optimal value table with value iteration.\n\n    Returns:\n        value_table_type: the value table for the dynamics\n    \"\"\"\n    state_list = self.dynamics_distribution.list_states()\n    value_table = np.random.rand(len(state_list))\n    stopping_epsilon = self.stopping_epsilon\n    maximum_epsilon: float = 1\n    while maximum_epsilon &gt; stopping_epsilon:\n        maximum_epsilon = float(0)\n        for state in state_list:\n            new_value = self.compute_updated_value(value_table, state)\n            epsilon = abs(float(value_table[state]) - new_value)\n            value_table[state] = new_value\n            maximum_epsilon = max(epsilon, maximum_epsilon)\n    return value_table\n</code></pre>"},{"location":"reference/model/agents/value_iteration/agent/#src.model.agents.value_iteration.agent.ValueIterationAgent.distribution_value","title":"<code>distribution_value(distribution, value_table)</code>","text":"<p>Compute the expected action-value from its distribution.</p> <p>Parameters:</p> Name Type Description Default <code>distribution</code> <code>distribution_result</code> <p>the distribution of results to weight the rewards</p> required <code>value_table</code> <code>value_table_type</code> <p>our current expectation of value in future states to base our estimate.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the expected value for this state and action</p> Source code in <code>src/model/agents/value_iteration/agent.py</code> <pre><code>def distribution_value(\n    self,\n    distribution: distribution_result,\n    value_table: value_table_type,\n) -&gt; float:\n    \"\"\"Compute the expected action-value from its distribution.\n\n    Args:\n        distribution (distribution_result): the distribution of\n            results to weight the rewards\n        value_table (value_table_type): our current expectation of value in\n            future states to base our estimate.\n\n    Returns:\n        float: the expected value for this state and action\n    \"\"\"\n    expected_value = 0\n    discount_rate = self.discount_rate\n    for next_state, (reward, frequency) in distribution.items():\n        expected_value += frequency * (\n            reward + discount_rate * value_table[next_state]\n        )\n    return expected_value\n</code></pre>"},{"location":"reference/model/agents/value_iteration/agent/#src.model.agents.value_iteration.agent.ValueIterationAgent.evaluate_policy","title":"<code>evaluate_policy(state)</code>","text":"<p>Decide on the action this agent would take in a given state.</p> <p>picks the best action based upon the value table.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>int</code> <p>the state the agent is performing this action</p> required <p>Returns:</p> Name Type Description <code>Action</code> <code>Action</code> <p>the action to take in this state</p> Source code in <code>src/model/agents/value_iteration/agent.py</code> <pre><code>def evaluate_policy(self, state: int) -&gt; Action:\n    \"\"\"Decide on the action this agent would take in a given state.\n\n    picks the best action based upon the value table.\n\n    Args:\n        state (int): the state the agent is performing this action\n\n\n    Returns:\n        Action: the action to take in this state\n    \"\"\"\n    best_action = random.choice(list(Action))\n    best_value = self.get_state_action_value(state, best_action)\n    # random default action to help break ties evenly\n    for action in Action:\n        if action is best_action:\n            continue\n        action_value = self.get_state_action_value(state, action)\n        if action_value &gt; best_value:\n            best_value = action_value\n            best_action = action\n\n    return best_action\n</code></pre>"},{"location":"reference/model/agents/value_iteration/agent/#src.model.agents.value_iteration.agent.ValueIterationAgent.get_state_action_value","title":"<code>get_state_action_value(state, action)</code>","text":"<p>Compute the expected action-value of a given state.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>int</code> <p>the state the action is performed in</p> required <code>action</code> <code>Action</code> <p>the action to get the value of</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the expected value for this state and action</p> Source code in <code>src/model/agents/value_iteration/agent.py</code> <pre><code>def get_state_action_value(self, state: int, action: Action) -&gt; float:\n    \"\"\"Compute the expected action-value of a given state.\n\n    Args:\n        state (int): the state the action is performed in\n        action (Action): the action to get the value of\n\n    Returns:\n        float: the expected value for this state and action\n    \"\"\"\n    value_table = self.get_value_table()\n    return self.distribution_value(\n        self.dynamics_distribution.observations[state][action.value],\n        value_table,\n    )\n</code></pre>"},{"location":"reference/model/agents/value_iteration/agent/#src.model.agents.value_iteration.agent.ValueIterationAgent.get_state_value","title":"<code>get_state_value(state)</code>","text":"<p>Get the agents interpretation of the value of this state.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>int</code> <p>the state to evaluate</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the agents interpretation of the value of this state</p> Source code in <code>src/model/agents/value_iteration/agent.py</code> <pre><code>def get_state_value(self, state: int) -&gt; float:\n    \"\"\"Get the agents interpretation of the value of this state.\n\n    Args:\n        state (int): the state to evaluate\n\n    Returns:\n        float: the agents interpretation of the value of this state\n    \"\"\"\n    return self.get_value_table()[state]\n</code></pre>"},{"location":"reference/model/agents/value_iteration/agent/#src.model.agents.value_iteration.agent.ValueIterationAgent.get_value_table","title":"<code>get_value_table()</code>","text":"<p>Get the value table for the provided dynamics.</p> <p>If the value table has already been computed it will provide that. if not it will compute a new value table, this can be quite costly based upon the epsilon, number of states and discount rate.</p> <p>Returns:</p> Name Type Description <code>value_table_type</code> <code>value_table_type</code> <p>the value table for this mdp</p> Source code in <code>src/model/agents/value_iteration/agent.py</code> <pre><code>def get_value_table(self) -&gt; value_table_type:\n    \"\"\"Get the value table for the provided dynamics.\n\n    If the value table has already been computed it will provide that. if\n    not it will compute a new value table, this can be quite costly based\n    upon the epsilon, number of states and discount rate.\n\n    Returns:\n        value_table_type: the value table for this mdp\n    \"\"\"\n    if self.value_table is not None:\n        return self.value_table\n\n    if not self.dynamics_distribution.has_compiled():\n        self.dynamics_distribution.compile()\n\n    self.value_table = self.compute_value_table()\n\n    return self.value_table\n</code></pre>"},{"location":"reference/model/agents/value_iteration/agent/#src.model.agents.value_iteration.agent.ValueIterationAgent.record_transition","title":"<code>record_transition(previous_state, previous_action, new_state, reward)</code>","text":"<p>Provide the agent with the information from a transition.</p> <p>(not used by this agent)</p> <p>Parameters:</p> Name Type Description Default <code>previous_state</code> <code>int</code> <p>the state before the action was taken</p> required <code>previous_action</code> <code>Action</code> <p>the action that was taken.</p> required <code>new_state</code> <code>int</code> <p>The resulting state after the action has been taken</p> required <code>reward</code> <code>float</code> <p>the reward for performing this action</p> required Source code in <code>src/model/agents/value_iteration/agent.py</code> <pre><code>def record_transition(\n    self,\n    previous_state: int,\n    previous_action: Action,\n    new_state: int,\n    reward: float,\n) -&gt; None:\n    \"\"\"Provide the agent with the information from a transition.\n\n    (not used by this agent)\n\n    Args:\n        previous_state (int): the state before the action was taken\n        previous_action (Action): the action that was taken.\n        new_state (int): The resulting state after the action has been taken\n        reward (float): the reward for performing this action\n\n    \"\"\"\n</code></pre>"},{"location":"reference/model/agents/value_iteration/agent_optimised/","title":"Agent Optimised","text":""},{"location":"reference/model/agents/value_iteration/agent_optimised/#src.model.agents.value_iteration.agent_optimised.ValueIterationAgentOptimised","title":"<code>ValueIterationAgentOptimised</code>","text":"<p>             Bases: <code>ValueIterationAgent</code></p> <p>Computes the optimal value table for a given dynamics.</p> <p>This agent uses that table with the dynamics to pick optimal actions.</p> Source code in <code>src/model/agents/value_iteration/agent_optimised.py</code> <pre><code>class ValueIterationAgentOptimised(ValueIterationAgent):\n    \"\"\"Computes the optimal value table for a given dynamics.\n\n    This agent uses that table with the dynamics to pick optimal actions.\n    \"\"\"\n\n    def compute_value_table(self) -&gt; value_table_type:\n        \"\"\"Compute the optimal value table with value iteration.\n\n        Uses numba to improve performance\n\n        Returns:\n            value_table_type: the value table for the dynamics\n        \"\"\"\n        (\n            lookup_table,\n            next_state,\n            expected_reward,\n            frequency,\n        ) = self.dynamics_distribution.get_array_representation()\n        return compute_value_table(\n            self.discount_rate,\n            self.stopping_epsilon,\n            lookup_table,\n            next_state,\n            expected_reward,\n            frequency,\n        )\n</code></pre>"},{"location":"reference/model/agents/value_iteration/agent_optimised/#src.model.agents.value_iteration.agent_optimised.ValueIterationAgentOptimised.compute_value_table","title":"<code>compute_value_table()</code>","text":"<p>Compute the optimal value table with value iteration.</p> <p>Uses numba to improve performance</p> <p>Returns:</p> Name Type Description <code>value_table_type</code> <code>value_table_type</code> <p>the value table for the dynamics</p> Source code in <code>src/model/agents/value_iteration/agent_optimised.py</code> <pre><code>def compute_value_table(self) -&gt; value_table_type:\n    \"\"\"Compute the optimal value table with value iteration.\n\n    Uses numba to improve performance\n\n    Returns:\n        value_table_type: the value table for the dynamics\n    \"\"\"\n    (\n        lookup_table,\n        next_state,\n        expected_reward,\n        frequency,\n    ) = self.dynamics_distribution.get_array_representation()\n    return compute_value_table(\n        self.discount_rate,\n        self.stopping_epsilon,\n        lookup_table,\n        next_state,\n        expected_reward,\n        frequency,\n    )\n</code></pre>"},{"location":"reference/model/agents/value_iteration/agent_optimised/#src.model.agents.value_iteration.agent_optimised.compute_updated_value","title":"<code>compute_updated_value(value_table, state, discount_rate, lookup_table, next_state, expected_reward, frequency)</code>","text":"<p>Compute the new value of the state based upon the latest value table.</p> <p>Parameters:</p> Name Type Description Default <code>value_table</code> <code>value_table_type</code> <p>our current expectation of value in future states to base our estimate.</p> required <code>state</code> <code>int</code> <p>the state to calculate the value for.</p> required <code>discount_rate</code> <code>float</code> <p>The rate to discount future rewards</p> required <code>lookup_table</code> <code>numpy_int</code> <p>maps state and actions to observed transitions</p> required <code>next_state</code> <code>numpy_int</code> <p>the following state after some state and action</p> required <code>expected_reward</code> <code>numpy_float</code> <p>the average reward after completing some action.</p> required <code>frequency</code> <code>numpy_float</code> <p>The relative frequency of this transition compared to others under the same initial state and action.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the new value for this state.</p> Source code in <code>src/model/agents/value_iteration/agent_optimised.py</code> <pre><code>@jit(nopython=True, cache=True, fastmath=True)\ndef compute_updated_value(  # noqa: WPS211\n    value_table: value_table_type,\n    state: int,\n    discount_rate: float,\n    lookup_table: numpy_int,\n    next_state: numpy_int,\n    expected_reward: numpy_float,\n    frequency: numpy_float,\n) -&gt; float:\n    \"\"\"Compute the new value of the state based upon the latest value table.\n\n    Args:\n        value_table (value_table_type): our current expectation of value in\n            future states to base our estimate.\n        state (int): the state to calculate the value for.\n        discount_rate (float): The rate to discount future rewards\n        lookup_table (numpy_int): maps state and actions to observed transitions\n        next_state (numpy_int): the following state after some state and action\n        expected_reward (numpy_float): the average reward after completing some\n            action.\n        frequency (numpy_float): The relative frequency of this transition\n            compared to others under the same initial state and action.\n\n\n    Returns:\n        float: the new value for this state.\n    \"\"\"\n    state_value = -math.inf\n    for observation_range in lookup_table[state]:\n        start = observation_range[0]\n        end = observation_range[1]\n\n        subsequent_values = discount_rate * value_table[next_state[start:end]]\n        weighted_rewards = frequency[start:end] * (\n            expected_reward[start:end] + subsequent_values\n        )\n\n        state_value = max(state_value, weighted_rewards.mean())\n    return state_value\n</code></pre>"},{"location":"reference/model/agents/value_iteration/agent_optimised/#src.model.agents.value_iteration.agent_optimised.compute_value_table","title":"<code>compute_value_table(discount_rate, stopping_epsilon, lookup_table, next_state, expected_reward, frequency)</code>","text":"<p>Compute the optimal value table with value iteration.</p> <p>Parameters:</p> Name Type Description Default <code>discount_rate</code> <code>float</code> <p>The rate to discount future rewards</p> required <code>stopping_epsilon</code> <code>float</code> <p>The error amount that is acceptable.</p> required <code>lookup_table</code> <code>numpy_int</code> <p>maps state and actions to observed transitions</p> required <code>next_state</code> <code>numpy_int</code> <p>the following state after some state and action</p> required <code>expected_reward</code> <code>numpy_float</code> <p>the average reward after completing some action.</p> required <code>frequency</code> <code>numpy_float</code> <p>The relative frequency of this transition compared to others under the same initial state and action.</p> required <p>Returns:</p> Name Type Description <code>value_table_type</code> <code>value_table_type</code> <p>the value table for the dynamics</p> Source code in <code>src/model/agents/value_iteration/agent_optimised.py</code> <pre><code>@jit(nopython=True, cache=True, fastmath=True)\ndef compute_value_table(  # noqa: WPS211\n    discount_rate: float,\n    stopping_epsilon: float,\n    lookup_table: numpy_int,\n    next_state: numpy_int,\n    expected_reward: numpy_float,\n    frequency: numpy_float,\n) -&gt; value_table_type:\n    \"\"\"Compute the optimal value table with value iteration.\n\n    Args:\n        discount_rate (float): The rate to discount future rewards\n        stopping_epsilon (float): The error amount that is acceptable.\n        lookup_table (numpy_int): maps state and actions to observed transitions\n        next_state (numpy_int): the following state after some state and action\n        expected_reward (numpy_float): the average reward after completing some\n            action.\n        frequency (numpy_float): The relative frequency of this transition\n            compared to others under the same initial state and action.\n\n    Returns:\n        value_table_type: the value table for the dynamics\n    \"\"\"\n    number_of_states = lookup_table.shape[0]\n    value_table = np.random.rand(number_of_states)\n    maximum_epsilon: float = 1\n    while maximum_epsilon &gt; stopping_epsilon:\n        maximum_epsilon = 0\n        for state in range(number_of_states):\n            new_value = compute_updated_value(\n                value_table,\n                state,\n                discount_rate,\n                lookup_table,\n                next_state,\n                expected_reward,\n                frequency,\n            )\n            epsilon = abs(value_table[state] - new_value)\n            value_table[state] = new_value\n            maximum_epsilon = max(epsilon, maximum_epsilon)\n    return value_table\n</code></pre>"},{"location":"reference/model/agents/value_iteration/dynamics_distribution/","title":"Dynamics Distribution","text":""},{"location":"reference/model/agents/value_iteration/dynamics_distribution/#src.model.agents.value_iteration.dynamics_distribution.DynamicsDistribution","title":"<code>DynamicsDistribution</code>","text":"<p>             Bases: <code>object</code></p> <p>Calculates a dynamics distribution.</p> Source code in <code>src/model/agents/value_iteration/dynamics_distribution.py</code> <pre><code>class DynamicsDistribution(object):\n    \"\"\"Calculates a dynamics distribution.\"\"\"\n\n    def __init__(\n        self, per_state_sample_count: int, dynamics: BaseDynamics\n    ) -&gt; None:\n        \"\"\"Initialise the dynamics distribution.\n\n        Args:\n            per_state_sample_count (int): the number of samples to collect from\n                each state, for deterministic dynamics only one is needed.\n            dynamics (BaseDynamics): the dynamics to get the distribution for.\n        \"\"\"\n        self.sample_count = (\n            per_state_sample_count if dynamics.is_stochastic() else 1\n        )\n        self.dynamics = dynamics\n\n        # state, action, new_state -&gt; reward, freq\n        self.observations: observations_type = {}\n\n    def compute_state_action_distribution(\n        self, state: int, action: Action\n    ) -&gt; distribution_result:\n        \"\"\"Compute the subsequent distribution for a given action and state.\n\n        Args:\n            state (int): the state to to get the distribution for.\n            action (Action): the action to get the distribution for.\n\n        Returns:\n            distribution_result: the distribution of states and their\n            expected immediate rewards.\n        \"\"\"\n        observed_states: DefaultDict[int, List[float]] = defaultdict(list)\n\n        for _iteration in range(self.sample_count):  # noqa: WPS122\n            next_id, reward = self.dynamics.next_state_id(state, action)\n            observed_states[next_id].append(reward)\n\n        reduced_output: distribution_result = {}\n        for new_state, observations in observed_states.items():\n            frequency = len(observations) / self.sample_count\n            average_reward = np.array(observations).mean()\n            reduced_output[new_state] = (average_reward, frequency)\n        return reduced_output\n\n    def compile(self):\n        \"\"\"Compile the dynamics state distribution for analysis.\n\n        for some dynamics certain states are not reachable from the initial\n        state. if the initial state was changed to be one of these unreachable\n        states the distribution would need to be recalculated, and thus the\n        value table. The existing value table and distributions could be reused\n        but this is not within scope.\n        \"\"\"\n        frontier: List[int] = [self.dynamics.initial_state_id()]\n        seen_states: Set[int] = set(frontier)\n\n        seen_add = seen_states.add  # performance tweak\n        frontier_add = frontier.append\n\n        def add_states(states: Iterable[int]):\n            for state in states:\n                if state not in seen_states:\n                    seen_add(state)\n                    frontier_add(state)\n\n        while frontier:\n            current_state = frontier.pop(0)\n            current_state_observations = {}\n            self.observations[current_state] = current_state_observations\n            for action in Action:\n                distribution = self.compute_state_action_distribution(\n                    current_state, action\n                )\n                current_state_observations[action.value] = distribution\n                add_states(distribution.keys())\n\n    def has_compiled(self) -&gt; bool:\n        \"\"\"Check weather the observations have been compiled yet.\n\n        Returns:\n            bool: true when the distribution has been compiled.\n        \"\"\"\n        return bool(self.observations)\n\n    def check_compiled(self) -&gt; None:\n        \"\"\"Throw error if not compiled yet.\n\n        Raises:\n            RuntimeError: Thrown if the class has not compiled the observations.\n        \"\"\"\n        if not self.has_compiled():\n            raise RuntimeError(\"not yet compiled\")\n\n    def get_state_count(self) -&gt; int:\n        \"\"\"Get the number of states in the MDP.\n\n        Returns:\n            int: the number of states\n        \"\"\"\n        self.check_compiled()\n        return len(self.observations)\n\n    def list_states(self) -&gt; np.ndarray[Any, np.dtype[np.integer]]:\n        \"\"\"Get array of all the states.\n\n        Returns:\n            np.ndarray[Any, np.dtype[np.integer]]: all possible states as an\n            array.\n        \"\"\"\n        return np.array(list(self.observations.keys()))\n\n    def get_array_representation(\n        self,\n    ) -&gt; numpy_distribution_information_type:\n        \"\"\"Convert the observations data to an array representation.\n\n        lookup table -&gt; maps a state and action to a range of observations\n\n        the lookup table provides the start and end of a range of observed\n        subsequent states.\n\n        next state -&gt; the observed next state\n        expected_reward -&gt; the expected reward for transitioning to this state\n        frequency -&gt; how often under these state and action do we perform this\n        transition\n\n        Returns:\n            numpy_distribution_information_type: lookup_table, next_state,\n            expected_reward, frequency\n        \"\"\"\n        # 3d array state action to index the start and end of the observations\n        # states index to ranges in the corresponding arrays\n\n        empty_list_item = [None]\n\n        lookup_table: List[Any] = empty_list_item * len(self.observations)\n\n        next_state: List[Any] = []\n        expected_reward: List[Any] = []\n        frequency: List[Any] = []\n\n        for state, actions in self.observations.items():\n            state_lookup_table: List[Any] = empty_list_item * len(actions)\n            for action, observations in actions.items():\n                start = len(next_state)\n                end = start + len(observations)\n                state_lookup_table[action - 1] = [start, end]\n\n                next_state.extend(empty_list_item * len(observations))\n                expected_reward.extend(empty_list_item * len(observations))\n                frequency.extend(empty_list_item * len(observations))\n\n                for raw_index, observation in enumerate(observations.items()):\n                    (\n                        next_state_observation,\n                        (reward_observation, frequency_observation),\n                    ) = observation\n                    index = start + raw_index\n                    next_state[index] = next_state_observation\n                    expected_reward[index] = reward_observation\n                    frequency[index] = frequency_observation\n            lookup_table[state] = state_lookup_table\n\n        return (\n            np.array(lookup_table, dtype=np.int64),\n            np.array(next_state, dtype=np.int64),\n            np.array(expected_reward, dtype=np.float64),\n            np.array(frequency, dtype=np.float64),\n        )\n</code></pre>"},{"location":"reference/model/agents/value_iteration/dynamics_distribution/#src.model.agents.value_iteration.dynamics_distribution.DynamicsDistribution.__init__","title":"<code>__init__(per_state_sample_count, dynamics)</code>","text":"<p>Initialise the dynamics distribution.</p> <p>Parameters:</p> Name Type Description Default <code>per_state_sample_count</code> <code>int</code> <p>the number of samples to collect from each state, for deterministic dynamics only one is needed.</p> required <code>dynamics</code> <code>BaseDynamics</code> <p>the dynamics to get the distribution for.</p> required Source code in <code>src/model/agents/value_iteration/dynamics_distribution.py</code> <pre><code>def __init__(\n    self, per_state_sample_count: int, dynamics: BaseDynamics\n) -&gt; None:\n    \"\"\"Initialise the dynamics distribution.\n\n    Args:\n        per_state_sample_count (int): the number of samples to collect from\n            each state, for deterministic dynamics only one is needed.\n        dynamics (BaseDynamics): the dynamics to get the distribution for.\n    \"\"\"\n    self.sample_count = (\n        per_state_sample_count if dynamics.is_stochastic() else 1\n    )\n    self.dynamics = dynamics\n\n    # state, action, new_state -&gt; reward, freq\n    self.observations: observations_type = {}\n</code></pre>"},{"location":"reference/model/agents/value_iteration/dynamics_distribution/#src.model.agents.value_iteration.dynamics_distribution.DynamicsDistribution.check_compiled","title":"<code>check_compiled()</code>","text":"<p>Throw error if not compiled yet.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>Thrown if the class has not compiled the observations.</p> Source code in <code>src/model/agents/value_iteration/dynamics_distribution.py</code> <pre><code>def check_compiled(self) -&gt; None:\n    \"\"\"Throw error if not compiled yet.\n\n    Raises:\n        RuntimeError: Thrown if the class has not compiled the observations.\n    \"\"\"\n    if not self.has_compiled():\n        raise RuntimeError(\"not yet compiled\")\n</code></pre>"},{"location":"reference/model/agents/value_iteration/dynamics_distribution/#src.model.agents.value_iteration.dynamics_distribution.DynamicsDistribution.compile","title":"<code>compile()</code>","text":"<p>Compile the dynamics state distribution for analysis.</p> <p>for some dynamics certain states are not reachable from the initial state. if the initial state was changed to be one of these unreachable states the distribution would need to be recalculated, and thus the value table. The existing value table and distributions could be reused but this is not within scope.</p> Source code in <code>src/model/agents/value_iteration/dynamics_distribution.py</code> <pre><code>def compile(self):\n    \"\"\"Compile the dynamics state distribution for analysis.\n\n    for some dynamics certain states are not reachable from the initial\n    state. if the initial state was changed to be one of these unreachable\n    states the distribution would need to be recalculated, and thus the\n    value table. The existing value table and distributions could be reused\n    but this is not within scope.\n    \"\"\"\n    frontier: List[int] = [self.dynamics.initial_state_id()]\n    seen_states: Set[int] = set(frontier)\n\n    seen_add = seen_states.add  # performance tweak\n    frontier_add = frontier.append\n\n    def add_states(states: Iterable[int]):\n        for state in states:\n            if state not in seen_states:\n                seen_add(state)\n                frontier_add(state)\n\n    while frontier:\n        current_state = frontier.pop(0)\n        current_state_observations = {}\n        self.observations[current_state] = current_state_observations\n        for action in Action:\n            distribution = self.compute_state_action_distribution(\n                current_state, action\n            )\n            current_state_observations[action.value] = distribution\n            add_states(distribution.keys())\n</code></pre>"},{"location":"reference/model/agents/value_iteration/dynamics_distribution/#src.model.agents.value_iteration.dynamics_distribution.DynamicsDistribution.compute_state_action_distribution","title":"<code>compute_state_action_distribution(state, action)</code>","text":"<p>Compute the subsequent distribution for a given action and state.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>int</code> <p>the state to to get the distribution for.</p> required <code>action</code> <code>Action</code> <p>the action to get the distribution for.</p> required <p>Returns:</p> Name Type Description <code>distribution_result</code> <code>distribution_result</code> <p>the distribution of states and their</p> <code>distribution_result</code> <p>expected immediate rewards.</p> Source code in <code>src/model/agents/value_iteration/dynamics_distribution.py</code> <pre><code>def compute_state_action_distribution(\n    self, state: int, action: Action\n) -&gt; distribution_result:\n    \"\"\"Compute the subsequent distribution for a given action and state.\n\n    Args:\n        state (int): the state to to get the distribution for.\n        action (Action): the action to get the distribution for.\n\n    Returns:\n        distribution_result: the distribution of states and their\n        expected immediate rewards.\n    \"\"\"\n    observed_states: DefaultDict[int, List[float]] = defaultdict(list)\n\n    for _iteration in range(self.sample_count):  # noqa: WPS122\n        next_id, reward = self.dynamics.next_state_id(state, action)\n        observed_states[next_id].append(reward)\n\n    reduced_output: distribution_result = {}\n    for new_state, observations in observed_states.items():\n        frequency = len(observations) / self.sample_count\n        average_reward = np.array(observations).mean()\n        reduced_output[new_state] = (average_reward, frequency)\n    return reduced_output\n</code></pre>"},{"location":"reference/model/agents/value_iteration/dynamics_distribution/#src.model.agents.value_iteration.dynamics_distribution.DynamicsDistribution.get_array_representation","title":"<code>get_array_representation()</code>","text":"<p>Convert the observations data to an array representation.</p> <p>lookup table -&gt; maps a state and action to a range of observations</p> <p>the lookup table provides the start and end of a range of observed subsequent states.</p> <p>next state -&gt; the observed next state expected_reward -&gt; the expected reward for transitioning to this state frequency -&gt; how often under these state and action do we perform this transition</p> <p>Returns:</p> Name Type Description <code>numpy_distribution_information_type</code> <code>numpy_distribution_information_type</code> <p>lookup_table, next_state,</p> <code>numpy_distribution_information_type</code> <p>expected_reward, frequency</p> Source code in <code>src/model/agents/value_iteration/dynamics_distribution.py</code> <pre><code>def get_array_representation(\n    self,\n) -&gt; numpy_distribution_information_type:\n    \"\"\"Convert the observations data to an array representation.\n\n    lookup table -&gt; maps a state and action to a range of observations\n\n    the lookup table provides the start and end of a range of observed\n    subsequent states.\n\n    next state -&gt; the observed next state\n    expected_reward -&gt; the expected reward for transitioning to this state\n    frequency -&gt; how often under these state and action do we perform this\n    transition\n\n    Returns:\n        numpy_distribution_information_type: lookup_table, next_state,\n        expected_reward, frequency\n    \"\"\"\n    # 3d array state action to index the start and end of the observations\n    # states index to ranges in the corresponding arrays\n\n    empty_list_item = [None]\n\n    lookup_table: List[Any] = empty_list_item * len(self.observations)\n\n    next_state: List[Any] = []\n    expected_reward: List[Any] = []\n    frequency: List[Any] = []\n\n    for state, actions in self.observations.items():\n        state_lookup_table: List[Any] = empty_list_item * len(actions)\n        for action, observations in actions.items():\n            start = len(next_state)\n            end = start + len(observations)\n            state_lookup_table[action - 1] = [start, end]\n\n            next_state.extend(empty_list_item * len(observations))\n            expected_reward.extend(empty_list_item * len(observations))\n            frequency.extend(empty_list_item * len(observations))\n\n            for raw_index, observation in enumerate(observations.items()):\n                (\n                    next_state_observation,\n                    (reward_observation, frequency_observation),\n                ) = observation\n                index = start + raw_index\n                next_state[index] = next_state_observation\n                expected_reward[index] = reward_observation\n                frequency[index] = frequency_observation\n        lookup_table[state] = state_lookup_table\n\n    return (\n        np.array(lookup_table, dtype=np.int64),\n        np.array(next_state, dtype=np.int64),\n        np.array(expected_reward, dtype=np.float64),\n        np.array(frequency, dtype=np.float64),\n    )\n</code></pre>"},{"location":"reference/model/agents/value_iteration/dynamics_distribution/#src.model.agents.value_iteration.dynamics_distribution.DynamicsDistribution.get_state_count","title":"<code>get_state_count()</code>","text":"<p>Get the number of states in the MDP.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>the number of states</p> Source code in <code>src/model/agents/value_iteration/dynamics_distribution.py</code> <pre><code>def get_state_count(self) -&gt; int:\n    \"\"\"Get the number of states in the MDP.\n\n    Returns:\n        int: the number of states\n    \"\"\"\n    self.check_compiled()\n    return len(self.observations)\n</code></pre>"},{"location":"reference/model/agents/value_iteration/dynamics_distribution/#src.model.agents.value_iteration.dynamics_distribution.DynamicsDistribution.has_compiled","title":"<code>has_compiled()</code>","text":"<p>Check weather the observations have been compiled yet.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>true when the distribution has been compiled.</p> Source code in <code>src/model/agents/value_iteration/dynamics_distribution.py</code> <pre><code>def has_compiled(self) -&gt; bool:\n    \"\"\"Check weather the observations have been compiled yet.\n\n    Returns:\n        bool: true when the distribution has been compiled.\n    \"\"\"\n    return bool(self.observations)\n</code></pre>"},{"location":"reference/model/agents/value_iteration/dynamics_distribution/#src.model.agents.value_iteration.dynamics_distribution.DynamicsDistribution.list_states","title":"<code>list_states()</code>","text":"<p>Get array of all the states.</p> <p>Returns:</p> Type Description <code>ndarray[Any, dtype[integer]]</code> <p>np.ndarray[Any, np.dtype[np.integer]]: all possible states as an</p> <code>ndarray[Any, dtype[integer]]</code> <p>array.</p> Source code in <code>src/model/agents/value_iteration/dynamics_distribution.py</code> <pre><code>def list_states(self) -&gt; np.ndarray[Any, np.dtype[np.integer]]:\n    \"\"\"Get array of all the states.\n\n    Returns:\n        np.ndarray[Any, np.dtype[np.integer]]: all possible states as an\n        array.\n    \"\"\"\n    return np.array(list(self.observations.keys()))\n</code></pre>"},{"location":"reference/model/agents/value_iteration/types/","title":"Types","text":""},{"location":"reference/model/config/","title":"Config","text":"<p>Configuration Reader.</p> <p>This package contains the functionality for reading and validating the configuration.</p>"},{"location":"reference/model/config/agent_section/","title":"Agent Section","text":""},{"location":"reference/model/config/agent_section/#src.model.config.agent_section.AgentConfig","title":"<code>AgentConfig</code>","text":"<p>             Bases: <code>BaseConfigSection</code></p> <p>Gets configuration related to the GUI.</p> Source code in <code>src/model/config/agent_section.py</code> <pre><code>class AgentConfig(BaseConfigSection):\n    \"\"\"Gets configuration related to the GUI.\"\"\"\n\n    discount_rate_property = \"discount_rate\"\n    stopping_epsilon_property = \"stopping_epsilon\"\n    learning_rate_property = \"learning_rate\"\n    sample_count_property = \"sample_count\"\n    exploration_ratio_property = \"exploration_ratio\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Instantiate Grid world section config.\"\"\"\n        data_schema = Schema(\n            {\n                self.discount_rate_property: float,\n                self.stopping_epsilon_property: float,\n                self.learning_rate_property: float,\n                self.sample_count_property: int,\n                self.exploration_ratio_property: float,\n            }\n        )\n        super().__init__(\"agent\", data_schema)\n\n    def discount_rate(self) -&gt; float:\n        \"\"\"Get the discount rate.\n\n        Returns:\n            float: the amount to discount future reward\n        \"\"\"\n        return self.configuration[self.discount_rate_property]\n\n    def stopping_epsilon(self) -&gt; float:\n        \"\"\"Get the stopping epsilon.\n\n        Returns:\n            float: the maximum error allowable in a value table\n        \"\"\"\n        return self.configuration[self.stopping_epsilon_property]\n\n    def learning_rate(self) -&gt; float:\n        \"\"\"Get the learning rate.\n\n        Returns:\n            float: the amount to update the value table with each observation\n        \"\"\"\n        return self.configuration[self.learning_rate_property]\n\n    def sample_count(self) -&gt; int:\n        \"\"\"Get the sample count.\n\n        Returns:\n            int: the number of samples to use for distribution analysis.\n        \"\"\"\n        return self.configuration[self.sample_count_property]\n\n    def exploration_ratio(self) -&gt; float:\n        \"\"\"Get the ratio the agent should explore vs exploit.\n\n        also known as epsilon in epsilon greedy and soft strategies\n\n        Returns:\n            float: the ratio for exploring, 1 represents always exploring. 0\n            never exploring.\n        \"\"\"\n        return self.configuration[self.exploration_ratio_property]\n</code></pre>"},{"location":"reference/model/config/agent_section/#src.model.config.agent_section.AgentConfig.__init__","title":"<code>__init__()</code>","text":"<p>Instantiate Grid world section config.</p> Source code in <code>src/model/config/agent_section.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Instantiate Grid world section config.\"\"\"\n    data_schema = Schema(\n        {\n            self.discount_rate_property: float,\n            self.stopping_epsilon_property: float,\n            self.learning_rate_property: float,\n            self.sample_count_property: int,\n            self.exploration_ratio_property: float,\n        }\n    )\n    super().__init__(\"agent\", data_schema)\n</code></pre>"},{"location":"reference/model/config/agent_section/#src.model.config.agent_section.AgentConfig.discount_rate","title":"<code>discount_rate()</code>","text":"<p>Get the discount rate.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the amount to discount future reward</p> Source code in <code>src/model/config/agent_section.py</code> <pre><code>def discount_rate(self) -&gt; float:\n    \"\"\"Get the discount rate.\n\n    Returns:\n        float: the amount to discount future reward\n    \"\"\"\n    return self.configuration[self.discount_rate_property]\n</code></pre>"},{"location":"reference/model/config/agent_section/#src.model.config.agent_section.AgentConfig.exploration_ratio","title":"<code>exploration_ratio()</code>","text":"<p>Get the ratio the agent should explore vs exploit.</p> <p>also known as epsilon in epsilon greedy and soft strategies</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the ratio for exploring, 1 represents always exploring. 0</p> <code>float</code> <p>never exploring.</p> Source code in <code>src/model/config/agent_section.py</code> <pre><code>def exploration_ratio(self) -&gt; float:\n    \"\"\"Get the ratio the agent should explore vs exploit.\n\n    also known as epsilon in epsilon greedy and soft strategies\n\n    Returns:\n        float: the ratio for exploring, 1 represents always exploring. 0\n        never exploring.\n    \"\"\"\n    return self.configuration[self.exploration_ratio_property]\n</code></pre>"},{"location":"reference/model/config/agent_section/#src.model.config.agent_section.AgentConfig.learning_rate","title":"<code>learning_rate()</code>","text":"<p>Get the learning rate.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the amount to update the value table with each observation</p> Source code in <code>src/model/config/agent_section.py</code> <pre><code>def learning_rate(self) -&gt; float:\n    \"\"\"Get the learning rate.\n\n    Returns:\n        float: the amount to update the value table with each observation\n    \"\"\"\n    return self.configuration[self.learning_rate_property]\n</code></pre>"},{"location":"reference/model/config/agent_section/#src.model.config.agent_section.AgentConfig.sample_count","title":"<code>sample_count()</code>","text":"<p>Get the sample count.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>the number of samples to use for distribution analysis.</p> Source code in <code>src/model/config/agent_section.py</code> <pre><code>def sample_count(self) -&gt; int:\n    \"\"\"Get the sample count.\n\n    Returns:\n        int: the number of samples to use for distribution analysis.\n    \"\"\"\n    return self.configuration[self.sample_count_property]\n</code></pre>"},{"location":"reference/model/config/agent_section/#src.model.config.agent_section.AgentConfig.stopping_epsilon","title":"<code>stopping_epsilon()</code>","text":"<p>Get the stopping epsilon.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the maximum error allowable in a value table</p> Source code in <code>src/model/config/agent_section.py</code> <pre><code>def stopping_epsilon(self) -&gt; float:\n    \"\"\"Get the stopping epsilon.\n\n    Returns:\n        float: the maximum error allowable in a value table\n    \"\"\"\n    return self.configuration[self.stopping_epsilon_property]\n</code></pre>"},{"location":"reference/model/config/base_section/","title":"Base Section","text":""},{"location":"reference/model/config/base_section/#src.model.config.base_section.BaseConfigSection","title":"<code>BaseConfigSection</code>","text":"<p>             Bases: <code>object</code></p> <p>Base class for all config section views.</p> Source code in <code>src/model/config/base_section.py</code> <pre><code>class BaseConfigSection(object):\n    \"\"\"Base class for all config section views.\"\"\"\n\n    def __init__(\n        self,\n        section_name: str,\n        schema: Schema,\n    ) -&gt; None:\n        \"\"\"Instantiate the basic data required for a config section.\n\n        Args:\n            section_name (str): the name of the section as it should appear in\n                the config file\n            schema (Schema): the schema to validate the data within this\n                section.\n        \"\"\"\n        self.schema = schema\n        self.section_name = section_name\n\n    def initialise(self, configuration: Any) -&gt; None:\n        \"\"\"Populate section with data.\n\n        This method lets the configuration reader to populate the view with\n        data, it also performs validation at this stage, it will through an\n        error if the data is not valid for this section\n\n        Raises:\n            Exception: thrown when the configuration file data is incorrect\n\n        Args:\n            configuration (Any): the raw configuration data to be used thought\n                the application\n        \"\"\"\n        self.configuration = self.schema.validate(configuration)\n</code></pre>"},{"location":"reference/model/config/base_section/#src.model.config.base_section.BaseConfigSection.__init__","title":"<code>__init__(section_name, schema)</code>","text":"<p>Instantiate the basic data required for a config section.</p> <p>Parameters:</p> Name Type Description Default <code>section_name</code> <code>str</code> <p>the name of the section as it should appear in the config file</p> required <code>schema</code> <code>Schema</code> <p>the schema to validate the data within this section.</p> required Source code in <code>src/model/config/base_section.py</code> <pre><code>def __init__(\n    self,\n    section_name: str,\n    schema: Schema,\n) -&gt; None:\n    \"\"\"Instantiate the basic data required for a config section.\n\n    Args:\n        section_name (str): the name of the section as it should appear in\n            the config file\n        schema (Schema): the schema to validate the data within this\n            section.\n    \"\"\"\n    self.schema = schema\n    self.section_name = section_name\n</code></pre>"},{"location":"reference/model/config/base_section/#src.model.config.base_section.BaseConfigSection.initialise","title":"<code>initialise(configuration)</code>","text":"<p>Populate section with data.</p> <p>This method lets the configuration reader to populate the view with data, it also performs validation at this stage, it will through an error if the data is not valid for this section</p> <p>Raises:</p> Type Description <code>Exception</code> <p>thrown when the configuration file data is incorrect</p> <p>Parameters:</p> Name Type Description Default <code>configuration</code> <code>Any</code> <p>the raw configuration data to be used thought the application</p> required Source code in <code>src/model/config/base_section.py</code> <pre><code>def initialise(self, configuration: Any) -&gt; None:\n    \"\"\"Populate section with data.\n\n    This method lets the configuration reader to populate the view with\n    data, it also performs validation at this stage, it will through an\n    error if the data is not valid for this section\n\n    Raises:\n        Exception: thrown when the configuration file data is incorrect\n\n    Args:\n        configuration (Any): the raw configuration data to be used thought\n            the application\n    \"\"\"\n    self.configuration = self.schema.validate(configuration)\n</code></pre>"},{"location":"reference/model/config/grid_world_section/","title":"Grid World Section","text":""},{"location":"reference/model/config/grid_world_section/#src.model.config.grid_world_section.GridWorldConfig","title":"<code>GridWorldConfig</code>","text":"<p>             Bases: <code>BaseConfigSection</code></p> <p>Gets configuration related to the environment.</p> Source code in <code>src/model/config/grid_world_section.py</code> <pre><code>class GridWorldConfig(BaseConfigSection):\n    \"\"\"Gets configuration related to the environment.\"\"\"\n\n    width_property = \"width\"\n    height_property = \"height\"\n    entity_count_property = \"entity_count\"\n    energy_section = \"energy\"\n    energy_capacity_property = \"energy_capacity\"\n    initial_energy_property = \"initial_energy\"\n    location_section = \"agent_location\"\n    location_x_property = \"x\"\n    location_y_property = \"y\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Instantiate Grid world section config.\"\"\"\n        data_schema = Schema(\n            {\n                self.width_property: int,\n                self.height_property: int,\n                self.entity_count_property: int,\n                self.energy_section: {\n                    self.energy_capacity_property: int,\n                    self.initial_energy_property: int,\n                },\n                self.location_section: {\n                    self.location_x_property: int,\n                    self.location_y_property: int,\n                },\n            }\n        )\n        super().__init__(\"grid_world\", data_schema)\n\n    def width(self) -&gt; int:\n        \"\"\"Get the default width of the grid world.\n\n        Returns:\n            int: the requested width\n        \"\"\"\n        return self.configuration[self.width_property]\n\n    def height(self) -&gt; int:\n        \"\"\"Get the default height of the grid world.\n\n        Returns:\n            int: the requested height\n        \"\"\"\n        return self.configuration[self.height_property]\n\n    def agent_location(self) -&gt; tuple[int, int]:\n        \"\"\"Get the default agent location.\n\n        Returns:\n            tuple[int, int]: the agents location x,y\n        \"\"\"\n        pos_x = self.configuration[self.location_section][\n            self.location_x_property\n        ]\n        pos_y = self.configuration[self.location_section][\n            self.location_y_property\n        ]\n        return pos_x, pos_y\n\n    def entity_count(self) -&gt; int:\n        \"\"\"Get the number of entities to be spawned on the grid.\n\n        Returns:\n            int: The default number of entities to be spawned\n        \"\"\"\n        return self.configuration[self.entity_count_property]\n\n    def energy_capacity(self) -&gt; int:\n        \"\"\"Get the energy capacity.\n\n        Returns:\n            int: the default energy capacity\n        \"\"\"\n        return self.configuration[self.energy_section][\n            self.energy_capacity_property\n        ]\n\n    def initial_energy(self) -&gt; int:\n        \"\"\"Get the initial energy for the agent.\n\n        Returns:\n            int: the default initial energy\n        \"\"\"\n        return self.configuration[self.energy_section][\n            self.initial_energy_property\n        ]\n</code></pre>"},{"location":"reference/model/config/grid_world_section/#src.model.config.grid_world_section.GridWorldConfig.__init__","title":"<code>__init__()</code>","text":"<p>Instantiate Grid world section config.</p> Source code in <code>src/model/config/grid_world_section.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Instantiate Grid world section config.\"\"\"\n    data_schema = Schema(\n        {\n            self.width_property: int,\n            self.height_property: int,\n            self.entity_count_property: int,\n            self.energy_section: {\n                self.energy_capacity_property: int,\n                self.initial_energy_property: int,\n            },\n            self.location_section: {\n                self.location_x_property: int,\n                self.location_y_property: int,\n            },\n        }\n    )\n    super().__init__(\"grid_world\", data_schema)\n</code></pre>"},{"location":"reference/model/config/grid_world_section/#src.model.config.grid_world_section.GridWorldConfig.agent_location","title":"<code>agent_location()</code>","text":"<p>Get the default agent location.</p> <p>Returns:</p> Type Description <code>tuple[int, int]</code> <p>tuple[int, int]: the agents location x,y</p> Source code in <code>src/model/config/grid_world_section.py</code> <pre><code>def agent_location(self) -&gt; tuple[int, int]:\n    \"\"\"Get the default agent location.\n\n    Returns:\n        tuple[int, int]: the agents location x,y\n    \"\"\"\n    pos_x = self.configuration[self.location_section][\n        self.location_x_property\n    ]\n    pos_y = self.configuration[self.location_section][\n        self.location_y_property\n    ]\n    return pos_x, pos_y\n</code></pre>"},{"location":"reference/model/config/grid_world_section/#src.model.config.grid_world_section.GridWorldConfig.energy_capacity","title":"<code>energy_capacity()</code>","text":"<p>Get the energy capacity.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>the default energy capacity</p> Source code in <code>src/model/config/grid_world_section.py</code> <pre><code>def energy_capacity(self) -&gt; int:\n    \"\"\"Get the energy capacity.\n\n    Returns:\n        int: the default energy capacity\n    \"\"\"\n    return self.configuration[self.energy_section][\n        self.energy_capacity_property\n    ]\n</code></pre>"},{"location":"reference/model/config/grid_world_section/#src.model.config.grid_world_section.GridWorldConfig.entity_count","title":"<code>entity_count()</code>","text":"<p>Get the number of entities to be spawned on the grid.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The default number of entities to be spawned</p> Source code in <code>src/model/config/grid_world_section.py</code> <pre><code>def entity_count(self) -&gt; int:\n    \"\"\"Get the number of entities to be spawned on the grid.\n\n    Returns:\n        int: The default number of entities to be spawned\n    \"\"\"\n    return self.configuration[self.entity_count_property]\n</code></pre>"},{"location":"reference/model/config/grid_world_section/#src.model.config.grid_world_section.GridWorldConfig.height","title":"<code>height()</code>","text":"<p>Get the default height of the grid world.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>the requested height</p> Source code in <code>src/model/config/grid_world_section.py</code> <pre><code>def height(self) -&gt; int:\n    \"\"\"Get the default height of the grid world.\n\n    Returns:\n        int: the requested height\n    \"\"\"\n    return self.configuration[self.height_property]\n</code></pre>"},{"location":"reference/model/config/grid_world_section/#src.model.config.grid_world_section.GridWorldConfig.initial_energy","title":"<code>initial_energy()</code>","text":"<p>Get the initial energy for the agent.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>the default initial energy</p> Source code in <code>src/model/config/grid_world_section.py</code> <pre><code>def initial_energy(self) -&gt; int:\n    \"\"\"Get the initial energy for the agent.\n\n    Returns:\n        int: the default initial energy\n    \"\"\"\n    return self.configuration[self.energy_section][\n        self.initial_energy_property\n    ]\n</code></pre>"},{"location":"reference/model/config/grid_world_section/#src.model.config.grid_world_section.GridWorldConfig.width","title":"<code>width()</code>","text":"<p>Get the default width of the grid world.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>the requested width</p> Source code in <code>src/model/config/grid_world_section.py</code> <pre><code>def width(self) -&gt; int:\n    \"\"\"Get the default width of the grid world.\n\n    Returns:\n        int: the requested width\n    \"\"\"\n    return self.configuration[self.width_property]\n</code></pre>"},{"location":"reference/model/config/gui_section/","title":"Gui Section","text":""},{"location":"reference/model/config/gui_section/#src.model.config.gui_section.GUIConfig","title":"<code>GUIConfig</code>","text":"<p>             Bases: <code>BaseConfigSection</code></p> <p>Gets configuration related to the GUI.</p> Source code in <code>src/model/config/gui_section.py</code> <pre><code>class GUIConfig(BaseConfigSection):\n    \"\"\"Gets configuration related to the GUI.\"\"\"\n\n    appearance_mode_property = \"appearance_mode\"\n    color_theme_property = \"color_theme\"\n    initial_size_property = \"initial_size\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Instantiate Grid world section config.\"\"\"\n        data_schema = Schema(\n            {\n                self.appearance_mode_property: str,\n                self.color_theme_property: str,\n                self.initial_size_property: str,\n            }\n        )\n        super().__init__(\"gui\", data_schema)\n\n    def appearance_mode(self) -&gt; str:\n        \"\"\"Get the theme style, e.g. light or dark.\n\n        Returns:\n            str: The theme style.\n        \"\"\"\n        return self.configuration[self.appearance_mode_property]\n\n    def color_theme(self) -&gt; str:\n        \"\"\"Get the theme color.\n\n        e.g \"blue\" (standard), \"green\", \"dark-blue\"\n\n\n        Returns:\n            str: The palate color.\n        \"\"\"\n        return self.configuration[self.color_theme_property]\n\n    def initial_size(self) -&gt; str:\n        \"\"\"Get the initial size of the window.\n\n        Returns:\n            str: the width and hight formatted as \"100x100\"\n        \"\"\"\n        return self.configuration[self.initial_size_property]\n</code></pre>"},{"location":"reference/model/config/gui_section/#src.model.config.gui_section.GUIConfig.__init__","title":"<code>__init__()</code>","text":"<p>Instantiate Grid world section config.</p> Source code in <code>src/model/config/gui_section.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Instantiate Grid world section config.\"\"\"\n    data_schema = Schema(\n        {\n            self.appearance_mode_property: str,\n            self.color_theme_property: str,\n            self.initial_size_property: str,\n        }\n    )\n    super().__init__(\"gui\", data_schema)\n</code></pre>"},{"location":"reference/model/config/gui_section/#src.model.config.gui_section.GUIConfig.appearance_mode","title":"<code>appearance_mode()</code>","text":"<p>Get the theme style, e.g. light or dark.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The theme style.</p> Source code in <code>src/model/config/gui_section.py</code> <pre><code>def appearance_mode(self) -&gt; str:\n    \"\"\"Get the theme style, e.g. light or dark.\n\n    Returns:\n        str: The theme style.\n    \"\"\"\n    return self.configuration[self.appearance_mode_property]\n</code></pre>"},{"location":"reference/model/config/gui_section/#src.model.config.gui_section.GUIConfig.color_theme","title":"<code>color_theme()</code>","text":"<p>Get the theme color.</p> <p>e.g \"blue\" (standard), \"green\", \"dark-blue\"</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The palate color.</p> Source code in <code>src/model/config/gui_section.py</code> <pre><code>def color_theme(self) -&gt; str:\n    \"\"\"Get the theme color.\n\n    e.g \"blue\" (standard), \"green\", \"dark-blue\"\n\n\n    Returns:\n        str: The palate color.\n    \"\"\"\n    return self.configuration[self.color_theme_property]\n</code></pre>"},{"location":"reference/model/config/gui_section/#src.model.config.gui_section.GUIConfig.initial_size","title":"<code>initial_size()</code>","text":"<p>Get the initial size of the window.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>the width and hight formatted as \"100x100\"</p> Source code in <code>src/model/config/gui_section.py</code> <pre><code>def initial_size(self) -&gt; str:\n    \"\"\"Get the initial size of the window.\n\n    Returns:\n        str: the width and hight formatted as \"100x100\"\n    \"\"\"\n    return self.configuration[self.initial_size_property]\n</code></pre>"},{"location":"reference/model/config/reader/","title":"Reader","text":""},{"location":"reference/model/config/reader/#src.model.config.reader.ConfigReader","title":"<code>ConfigReader</code>","text":"<p>             Bases: <code>object</code></p> <p>Configuration Reader.</p> <p>loads the program's configuration into memory and provides access to the sections of variables within. This class is a singleton to avoid redundant loading</p> Source code in <code>src/model/config/reader.py</code> <pre><code>class ConfigReader(object):\n    \"\"\"\n    Configuration Reader.\n\n    loads the program's configuration into memory and provides access to the\n    sections of variables within. This class is a singleton to avoid redundant\n    loading\n    \"\"\"\n\n    config_file_name = \"config.toml\"\n    _instance = None\n\n    def __new__(cls) -&gt; Self:\n        \"\"\"Create a config object.\n\n        Overridden to provide the singleton patten, there must only be one\n        config object. to avoid redundant loading\n\n        Returns:\n            Self: The config object with the loaded data\n        \"\"\"\n        # https://python-patterns.guide/gang-of-four/singleton/\n        if cls._instance is None:\n            cls._instance = super().__new__(cls)\n            cls._instance.load_config()\n        return cls._instance\n\n    def load_config(self):\n        \"\"\"Load or reload the configuration from the disk.\"\"\"\n        config_file_path = path.abspath(\n            path.join(path.dirname(__file__), \"..\", \"..\", self.config_file_name)\n        )\n\n        with open(config_file_path, \"r\") as config_file:\n            self.__raw_config = toml.load(config_file)\n\n    def grid_world(self) -&gt; GridWorldConfig:\n        \"\"\"Get the configuration for the environment.\n\n        Returns:\n            GridWorldConfig: an object that describes the environment\n            configuration\n        \"\"\"\n        return self.__initialise_section(GridWorldConfig())\n\n    def gui(self) -&gt; GUIConfig:\n        \"\"\"Get the configuration for the GUI.\n\n        Returns:\n            GUIConfig: an object that describes the gui\n            configuration\n        \"\"\"\n        return self.__initialise_section(GUIConfig())\n\n    def agent(self) -&gt; AgentConfig:\n        \"\"\"Get the configuration for agents.\n\n        Returns:\n            AgentConfig: an object that describes the agent\n            configuration\n        \"\"\"\n        return self.__initialise_section(AgentConfig())\n\n    def __initialise_section(self, section: BaseConfigSection) -&gt; Any:\n        \"\"\"Populate a section object with data.\n\n        This is an internal method\n\n        Args:\n            section (BaseConfigSection): the section to populate\n\n        Returns:\n            Any: the section object that has been populated\n        \"\"\"\n        section_raw_data = self.__raw_config[section.section_name]\n        section.initialise(section_raw_data)\n        return section\n</code></pre>"},{"location":"reference/model/config/reader/#src.model.config.reader.ConfigReader.__initialise_section","title":"<code>__initialise_section(section)</code>","text":"<p>Populate a section object with data.</p> <p>This is an internal method</p> <p>Parameters:</p> Name Type Description Default <code>section</code> <code>BaseConfigSection</code> <p>the section to populate</p> required <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>the section object that has been populated</p> Source code in <code>src/model/config/reader.py</code> <pre><code>def __initialise_section(self, section: BaseConfigSection) -&gt; Any:\n    \"\"\"Populate a section object with data.\n\n    This is an internal method\n\n    Args:\n        section (BaseConfigSection): the section to populate\n\n    Returns:\n        Any: the section object that has been populated\n    \"\"\"\n    section_raw_data = self.__raw_config[section.section_name]\n    section.initialise(section_raw_data)\n    return section\n</code></pre>"},{"location":"reference/model/config/reader/#src.model.config.reader.ConfigReader.__new__","title":"<code>__new__()</code>","text":"<p>Create a config object.</p> <p>Overridden to provide the singleton patten, there must only be one config object. to avoid redundant loading</p> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The config object with the loaded data</p> Source code in <code>src/model/config/reader.py</code> <pre><code>def __new__(cls) -&gt; Self:\n    \"\"\"Create a config object.\n\n    Overridden to provide the singleton patten, there must only be one\n    config object. to avoid redundant loading\n\n    Returns:\n        Self: The config object with the loaded data\n    \"\"\"\n    # https://python-patterns.guide/gang-of-four/singleton/\n    if cls._instance is None:\n        cls._instance = super().__new__(cls)\n        cls._instance.load_config()\n    return cls._instance\n</code></pre>"},{"location":"reference/model/config/reader/#src.model.config.reader.ConfigReader.agent","title":"<code>agent()</code>","text":"<p>Get the configuration for agents.</p> <p>Returns:</p> Name Type Description <code>AgentConfig</code> <code>AgentConfig</code> <p>an object that describes the agent</p> <code>AgentConfig</code> <p>configuration</p> Source code in <code>src/model/config/reader.py</code> <pre><code>def agent(self) -&gt; AgentConfig:\n    \"\"\"Get the configuration for agents.\n\n    Returns:\n        AgentConfig: an object that describes the agent\n        configuration\n    \"\"\"\n    return self.__initialise_section(AgentConfig())\n</code></pre>"},{"location":"reference/model/config/reader/#src.model.config.reader.ConfigReader.grid_world","title":"<code>grid_world()</code>","text":"<p>Get the configuration for the environment.</p> <p>Returns:</p> Name Type Description <code>GridWorldConfig</code> <code>GridWorldConfig</code> <p>an object that describes the environment</p> <code>GridWorldConfig</code> <p>configuration</p> Source code in <code>src/model/config/reader.py</code> <pre><code>def grid_world(self) -&gt; GridWorldConfig:\n    \"\"\"Get the configuration for the environment.\n\n    Returns:\n        GridWorldConfig: an object that describes the environment\n        configuration\n    \"\"\"\n    return self.__initialise_section(GridWorldConfig())\n</code></pre>"},{"location":"reference/model/config/reader/#src.model.config.reader.ConfigReader.gui","title":"<code>gui()</code>","text":"<p>Get the configuration for the GUI.</p> <p>Returns:</p> Name Type Description <code>GUIConfig</code> <code>GUIConfig</code> <p>an object that describes the gui</p> <code>GUIConfig</code> <p>configuration</p> Source code in <code>src/model/config/reader.py</code> <pre><code>def gui(self) -&gt; GUIConfig:\n    \"\"\"Get the configuration for the GUI.\n\n    Returns:\n        GUIConfig: an object that describes the gui\n        configuration\n    \"\"\"\n    return self.__initialise_section(GUIConfig())\n</code></pre>"},{"location":"reference/model/config/reader/#src.model.config.reader.ConfigReader.load_config","title":"<code>load_config()</code>","text":"<p>Load or reload the configuration from the disk.</p> Source code in <code>src/model/config/reader.py</code> <pre><code>def load_config(self):\n    \"\"\"Load or reload the configuration from the disk.\"\"\"\n    config_file_path = path.abspath(\n        path.join(path.dirname(__file__), \"..\", \"..\", self.config_file_name)\n    )\n\n    with open(config_file_path, \"r\") as config_file:\n        self.__raw_config = toml.load(config_file)\n</code></pre>"},{"location":"reference/model/dynamics/","title":"Dynamics","text":"<p>This package provides different dynamics models.</p>"},{"location":"reference/model/dynamics/actions/","title":"Actions","text":""},{"location":"reference/model/dynamics/actions/#src.model.dynamics.actions.Action","title":"<code>Action</code>","text":"<p>             Bases: <code>Enum</code></p> <p>Enumerates all possible actions.</p> Source code in <code>src/model/dynamics/actions.py</code> <pre><code>class Action(Enum):\n    \"\"\"Enumerates all possible actions.\"\"\"\n\n    up = 1\n    down = 2\n    left = 3\n    right = 4\n</code></pre>"},{"location":"reference/model/dynamics/base_dynamics/","title":"Base Dynamics","text":""},{"location":"reference/model/dynamics/base_dynamics/#src.model.dynamics.base_dynamics.BaseDynamics","title":"<code>BaseDynamics</code>","text":"<p>             Bases: <code>object</code></p> <p>The abstract base class for dynamics classes.</p> <p>This class provides the basic methods a dynamics class is expected to implement and some common functionality</p> Source code in <code>src/model/dynamics/base_dynamics.py</code> <pre><code>class BaseDynamics(object):\n    \"\"\"The abstract base class for dynamics classes.\n\n    This class provides the basic methods a dynamics class is expected to\n    implement and some common functionality\n    \"\"\"\n\n    def __init__(self, config: GridWorldConfig) -&gt; None:\n        \"\"\"Instantiate a dynamics, provides the minimal required properties.\n\n        Args:\n            config (GridWorldConfig): the config used by this dynamics such as\n                the size of the grid world.\n        \"\"\"\n        self.state_pool = StatePool()\n        self.config = config\n        self.grid_world = GridWorld(config.width(), config.height())\n\n    def is_stochastic(self) -&gt; bool:\n        \"\"\"Determine weather the dynamics behave stochastically.\n\n        If stochastic then there is random variability in the output of `next`.\n        However variability distribution must still be markovian.\n\n        Raises:\n            NotImplementedError: If this method has not been overridden\n\n        Should Return:\n            bool: weather this dynamics behaves stochastically.\n\n        \"\"\"\n        raise NotImplementedError(\n            \"This method must be overridden by concrete dynamics classes\"\n        )\n\n    def initial_state(self) -&gt; StateInstance:\n        \"\"\"Provide the initial state of this environment.\n\n        Raises:\n            NotImplementedError: If this method has not been overridden\n\n        Should Return:\n            StateInstance: the starting state.\n        \"\"\"\n        raise NotImplementedError(\n            \"This method must be overridden by concrete dynamics classes\"\n        )\n\n    def next(\n        self, current_state: StateInstance, action: Action\n    ) -&gt; tuple[StateInstance, float]:\n        \"\"\"Compute the next state and reward.\n\n        Must only compute the next reward and state based on only the provided\n        current state and reward to obey the markov property.\n\n        Args:\n            current_state (StateInstance): the state that the action is\n                performed in\n            action (Action): the action the agent has chosen\n\n\n        Raises:\n            NotImplementedError: If this method has not been overridden\n\n        Should Return:\n            tuple[StateInstance, float]: the resulting state after the action\n            has been performed and the reward from this action\n        \"\"\"\n        raise NotImplementedError(\n            \"This method must be overridden by concrete dynamics classes\"\n        )\n\n    def initial_state_id(self) -&gt; int:\n        \"\"\"Provide the initial state id of this environment.\n\n        Raises:\n            NotImplementedError: If this method has not been overridden\n\n        Returns:\n            int: the starting state id.\n        \"\"\"\n        return self.state_pool.get_state_id(self.initial_state())\n\n    def next_state_id(\n        self, current_state_id: int, action: Action\n    ) -&gt; tuple[int, float]:\n        \"\"\"Compute the next state and reward.\n\n        Must only compute the next reward and state based on only the provided\n        current state and reward to obey the markov property.\n\n        Args:\n            current_state_id (int): the state that the action is\n                performed in\n            action (Action): the action the agent has chosen\n\n\n        Raises:\n            NotImplementedError: If this method has not been overridden\n\n        Returns:\n            tuple[int, float]: the resulting state after the action has been\n            performed and the reward from this action\n        \"\"\"\n        current_state = self.state_pool.get_state_from_id(current_state_id)\n        next_state, reward = self.next(current_state, action)\n        return self.state_pool.get_state_id(next_state), reward\n</code></pre>"},{"location":"reference/model/dynamics/base_dynamics/#src.model.dynamics.base_dynamics.BaseDynamics.__init__","title":"<code>__init__(config)</code>","text":"<p>Instantiate a dynamics, provides the minimal required properties.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>GridWorldConfig</code> <p>the config used by this dynamics such as the size of the grid world.</p> required Source code in <code>src/model/dynamics/base_dynamics.py</code> <pre><code>def __init__(self, config: GridWorldConfig) -&gt; None:\n    \"\"\"Instantiate a dynamics, provides the minimal required properties.\n\n    Args:\n        config (GridWorldConfig): the config used by this dynamics such as\n            the size of the grid world.\n    \"\"\"\n    self.state_pool = StatePool()\n    self.config = config\n    self.grid_world = GridWorld(config.width(), config.height())\n</code></pre>"},{"location":"reference/model/dynamics/base_dynamics/#src.model.dynamics.base_dynamics.BaseDynamics.initial_state","title":"<code>initial_state()</code>","text":"<p>Provide the initial state of this environment.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If this method has not been overridden</p> Should Return <p>StateInstance: the starting state.</p> Source code in <code>src/model/dynamics/base_dynamics.py</code> <pre><code>def initial_state(self) -&gt; StateInstance:\n    \"\"\"Provide the initial state of this environment.\n\n    Raises:\n        NotImplementedError: If this method has not been overridden\n\n    Should Return:\n        StateInstance: the starting state.\n    \"\"\"\n    raise NotImplementedError(\n        \"This method must be overridden by concrete dynamics classes\"\n    )\n</code></pre>"},{"location":"reference/model/dynamics/base_dynamics/#src.model.dynamics.base_dynamics.BaseDynamics.initial_state_id","title":"<code>initial_state_id()</code>","text":"<p>Provide the initial state id of this environment.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If this method has not been overridden</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>the starting state id.</p> Source code in <code>src/model/dynamics/base_dynamics.py</code> <pre><code>def initial_state_id(self) -&gt; int:\n    \"\"\"Provide the initial state id of this environment.\n\n    Raises:\n        NotImplementedError: If this method has not been overridden\n\n    Returns:\n        int: the starting state id.\n    \"\"\"\n    return self.state_pool.get_state_id(self.initial_state())\n</code></pre>"},{"location":"reference/model/dynamics/base_dynamics/#src.model.dynamics.base_dynamics.BaseDynamics.is_stochastic","title":"<code>is_stochastic()</code>","text":"<p>Determine weather the dynamics behave stochastically.</p> <p>If stochastic then there is random variability in the output of <code>next</code>. However variability distribution must still be markovian.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If this method has not been overridden</p> Should Return <p>bool: weather this dynamics behaves stochastically.</p> Source code in <code>src/model/dynamics/base_dynamics.py</code> <pre><code>def is_stochastic(self) -&gt; bool:\n    \"\"\"Determine weather the dynamics behave stochastically.\n\n    If stochastic then there is random variability in the output of `next`.\n    However variability distribution must still be markovian.\n\n    Raises:\n        NotImplementedError: If this method has not been overridden\n\n    Should Return:\n        bool: weather this dynamics behaves stochastically.\n\n    \"\"\"\n    raise NotImplementedError(\n        \"This method must be overridden by concrete dynamics classes\"\n    )\n</code></pre>"},{"location":"reference/model/dynamics/base_dynamics/#src.model.dynamics.base_dynamics.BaseDynamics.next","title":"<code>next(current_state, action)</code>","text":"<p>Compute the next state and reward.</p> <p>Must only compute the next reward and state based on only the provided current state and reward to obey the markov property.</p> <p>Parameters:</p> Name Type Description Default <code>current_state</code> <code>StateInstance</code> <p>the state that the action is performed in</p> required <code>action</code> <code>Action</code> <p>the action the agent has chosen</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If this method has not been overridden</p> Should Return <p>tuple[StateInstance, float]: the resulting state after the action has been performed and the reward from this action</p> Source code in <code>src/model/dynamics/base_dynamics.py</code> <pre><code>def next(\n    self, current_state: StateInstance, action: Action\n) -&gt; tuple[StateInstance, float]:\n    \"\"\"Compute the next state and reward.\n\n    Must only compute the next reward and state based on only the provided\n    current state and reward to obey the markov property.\n\n    Args:\n        current_state (StateInstance): the state that the action is\n            performed in\n        action (Action): the action the agent has chosen\n\n\n    Raises:\n        NotImplementedError: If this method has not been overridden\n\n    Should Return:\n        tuple[StateInstance, float]: the resulting state after the action\n        has been performed and the reward from this action\n    \"\"\"\n    raise NotImplementedError(\n        \"This method must be overridden by concrete dynamics classes\"\n    )\n</code></pre>"},{"location":"reference/model/dynamics/base_dynamics/#src.model.dynamics.base_dynamics.BaseDynamics.next_state_id","title":"<code>next_state_id(current_state_id, action)</code>","text":"<p>Compute the next state and reward.</p> <p>Must only compute the next reward and state based on only the provided current state and reward to obey the markov property.</p> <p>Parameters:</p> Name Type Description Default <code>current_state_id</code> <code>int</code> <p>the state that the action is performed in</p> required <code>action</code> <code>Action</code> <p>the action the agent has chosen</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If this method has not been overridden</p> <p>Returns:</p> Type Description <code>int</code> <p>tuple[int, float]: the resulting state after the action has been</p> <code>float</code> <p>performed and the reward from this action</p> Source code in <code>src/model/dynamics/base_dynamics.py</code> <pre><code>def next_state_id(\n    self, current_state_id: int, action: Action\n) -&gt; tuple[int, float]:\n    \"\"\"Compute the next state and reward.\n\n    Must only compute the next reward and state based on only the provided\n    current state and reward to obey the markov property.\n\n    Args:\n        current_state_id (int): the state that the action is\n            performed in\n        action (Action): the action the agent has chosen\n\n\n    Raises:\n        NotImplementedError: If this method has not been overridden\n\n    Returns:\n        tuple[int, float]: the resulting state after the action has been\n        performed and the reward from this action\n    \"\"\"\n    current_state = self.state_pool.get_state_from_id(current_state_id)\n    next_state, reward = self.next(current_state, action)\n    return self.state_pool.get_state_id(next_state), reward\n</code></pre>"},{"location":"reference/model/dynamics/collection_dynamics/","title":"Collection Dynamics","text":""},{"location":"reference/model/dynamics/collection_dynamics/#src.model.dynamics.collection_dynamics.CollectionDynamics","title":"<code>CollectionDynamics</code>","text":"<p>             Bases: <code>BaseDynamics</code></p> <p>Simple Dynamics where the agent can move to cells to collect goals.</p> Source code in <code>src/model/dynamics/collection_dynamics.py</code> <pre><code>class CollectionDynamics(BaseDynamics):\n    \"\"\"Simple Dynamics where the agent can move to cells to collect goals.\"\"\"\n\n    def __init__(self, config: GridWorldConfig) -&gt; None:\n        \"\"\"Initialise collection dynamics.\n\n        Args:\n            config (GridWorldConfig): the configuration used by this dynamics.\n        \"\"\"\n        super().__init__(config)\n        self.spawn_positions: Optional[spawn_positions_type] = None\n\n    def is_stochastic(self) -&gt; bool:\n        \"\"\"Determine weather the dynamics behave stochastically.\n\n        Returns:\n            bool: false, this dynamics is deterministic\n        \"\"\"\n        return False\n\n    def get_spawn_positions(self) -&gt; spawn_positions_type:\n        \"\"\"Get the positions where flags can be spawned.\n\n        these will be a number of unique positions in the grid world bounds.\n        Initially chosen at random but then fixed for subsequent calls\n\n        Returns:\n            spawn_positions_type: the set of positions where goals can be\n            spawned.\n        \"\"\"\n        if self.spawn_positions is not None:\n            return self.spawn_positions\n        agent_location = self.config.agent_location()\n        self.spawn_positions = set()\n        while len(self.spawn_positions) &lt; self.config.entity_count():\n            location = self.grid_world.random_in_bounds_cell()\n            if location != agent_location:\n                self.spawn_positions.add(location)\n        return self.spawn_positions\n\n    def initial_state(self) -&gt; StateInstance:\n        \"\"\"Provide the initial state of this environment.\n\n        Raises:\n            ValueError: if the config specifies an invalid state. such as the\n                agent location being outside the bounds of the grid.\n\n        Returns:\n            StateInstance: the starting state.\n\n        \"\"\"\n        if not self.grid_world.is_in_bounds(self.config.agent_location()):\n            raise ValueError(\"config agent location outside of map bounds\")\n\n        initial_state_builder = (\n            StateBuilder()\n            .set_agent_location(self.config.agent_location())\n            .set_energy(self.config.initial_energy())\n        )\n\n        for goal in self.get_spawn_positions():\n            initial_state_builder.set_entity(goal, CellEntity.goal)\n\n        return initial_state_builder.build()\n\n    def next(\n        self, current_state: StateInstance, action: Action\n    ) -&gt; tuple[StateInstance, float]:\n        \"\"\"Compute the next state and reward.\n\n        Must only compute the next reward and state based on only the provided\n        current state and reward to obey the markov property.\n\n        Args:\n            current_state (StateInstance): the state that the action is\n                performed in\n            action (Action): the action the agent has chosen\n\n\n        Returns:\n            tuple[StateInstance, float]: the resulting state after the action\n            has been performed and the reward from this action\n        \"\"\"\n        next_state_builder = StateBuilder(current_state)\n        next_agent_location = self.grid_world.movement_action(\n            current_state.agent_location, action\n        )\n        if not self.grid_world.is_in_bounds(next_agent_location):\n            return current_state, 0\n\n        next_state_builder.set_agent_location(next_agent_location)\n\n        if next_agent_location not in current_state.entities:\n            return next_state_builder.build(), 0\n\n        next_state_builder.remove_entity(next_agent_location)\n\n        if not next_state_builder.entities:\n            # Terminal state all goals have been collected, loop to beginning to\n            # make task continuous\n            return self.initial_state(), 1\n        return next_state_builder.build(), 1\n</code></pre>"},{"location":"reference/model/dynamics/collection_dynamics/#src.model.dynamics.collection_dynamics.CollectionDynamics.__init__","title":"<code>__init__(config)</code>","text":"<p>Initialise collection dynamics.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>GridWorldConfig</code> <p>the configuration used by this dynamics.</p> required Source code in <code>src/model/dynamics/collection_dynamics.py</code> <pre><code>def __init__(self, config: GridWorldConfig) -&gt; None:\n    \"\"\"Initialise collection dynamics.\n\n    Args:\n        config (GridWorldConfig): the configuration used by this dynamics.\n    \"\"\"\n    super().__init__(config)\n    self.spawn_positions: Optional[spawn_positions_type] = None\n</code></pre>"},{"location":"reference/model/dynamics/collection_dynamics/#src.model.dynamics.collection_dynamics.CollectionDynamics.get_spawn_positions","title":"<code>get_spawn_positions()</code>","text":"<p>Get the positions where flags can be spawned.</p> <p>these will be a number of unique positions in the grid world bounds. Initially chosen at random but then fixed for subsequent calls</p> <p>Returns:</p> Name Type Description <code>spawn_positions_type</code> <code>spawn_positions_type</code> <p>the set of positions where goals can be</p> <code>spawn_positions_type</code> <p>spawned.</p> Source code in <code>src/model/dynamics/collection_dynamics.py</code> <pre><code>def get_spawn_positions(self) -&gt; spawn_positions_type:\n    \"\"\"Get the positions where flags can be spawned.\n\n    these will be a number of unique positions in the grid world bounds.\n    Initially chosen at random but then fixed for subsequent calls\n\n    Returns:\n        spawn_positions_type: the set of positions where goals can be\n        spawned.\n    \"\"\"\n    if self.spawn_positions is not None:\n        return self.spawn_positions\n    agent_location = self.config.agent_location()\n    self.spawn_positions = set()\n    while len(self.spawn_positions) &lt; self.config.entity_count():\n        location = self.grid_world.random_in_bounds_cell()\n        if location != agent_location:\n            self.spawn_positions.add(location)\n    return self.spawn_positions\n</code></pre>"},{"location":"reference/model/dynamics/collection_dynamics/#src.model.dynamics.collection_dynamics.CollectionDynamics.initial_state","title":"<code>initial_state()</code>","text":"<p>Provide the initial state of this environment.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if the config specifies an invalid state. such as the agent location being outside the bounds of the grid.</p> <p>Returns:</p> Name Type Description <code>StateInstance</code> <code>StateInstance</code> <p>the starting state.</p> Source code in <code>src/model/dynamics/collection_dynamics.py</code> <pre><code>def initial_state(self) -&gt; StateInstance:\n    \"\"\"Provide the initial state of this environment.\n\n    Raises:\n        ValueError: if the config specifies an invalid state. such as the\n            agent location being outside the bounds of the grid.\n\n    Returns:\n        StateInstance: the starting state.\n\n    \"\"\"\n    if not self.grid_world.is_in_bounds(self.config.agent_location()):\n        raise ValueError(\"config agent location outside of map bounds\")\n\n    initial_state_builder = (\n        StateBuilder()\n        .set_agent_location(self.config.agent_location())\n        .set_energy(self.config.initial_energy())\n    )\n\n    for goal in self.get_spawn_positions():\n        initial_state_builder.set_entity(goal, CellEntity.goal)\n\n    return initial_state_builder.build()\n</code></pre>"},{"location":"reference/model/dynamics/collection_dynamics/#src.model.dynamics.collection_dynamics.CollectionDynamics.is_stochastic","title":"<code>is_stochastic()</code>","text":"<p>Determine weather the dynamics behave stochastically.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>false, this dynamics is deterministic</p> Source code in <code>src/model/dynamics/collection_dynamics.py</code> <pre><code>def is_stochastic(self) -&gt; bool:\n    \"\"\"Determine weather the dynamics behave stochastically.\n\n    Returns:\n        bool: false, this dynamics is deterministic\n    \"\"\"\n    return False\n</code></pre>"},{"location":"reference/model/dynamics/collection_dynamics/#src.model.dynamics.collection_dynamics.CollectionDynamics.next","title":"<code>next(current_state, action)</code>","text":"<p>Compute the next state and reward.</p> <p>Must only compute the next reward and state based on only the provided current state and reward to obey the markov property.</p> <p>Parameters:</p> Name Type Description Default <code>current_state</code> <code>StateInstance</code> <p>the state that the action is performed in</p> required <code>action</code> <code>Action</code> <p>the action the agent has chosen</p> required <p>Returns:</p> Type Description <code>StateInstance</code> <p>tuple[StateInstance, float]: the resulting state after the action</p> <code>float</code> <p>has been performed and the reward from this action</p> Source code in <code>src/model/dynamics/collection_dynamics.py</code> <pre><code>def next(\n    self, current_state: StateInstance, action: Action\n) -&gt; tuple[StateInstance, float]:\n    \"\"\"Compute the next state and reward.\n\n    Must only compute the next reward and state based on only the provided\n    current state and reward to obey the markov property.\n\n    Args:\n        current_state (StateInstance): the state that the action is\n            performed in\n        action (Action): the action the agent has chosen\n\n\n    Returns:\n        tuple[StateInstance, float]: the resulting state after the action\n        has been performed and the reward from this action\n    \"\"\"\n    next_state_builder = StateBuilder(current_state)\n    next_agent_location = self.grid_world.movement_action(\n        current_state.agent_location, action\n    )\n    if not self.grid_world.is_in_bounds(next_agent_location):\n        return current_state, 0\n\n    next_state_builder.set_agent_location(next_agent_location)\n\n    if next_agent_location not in current_state.entities:\n        return next_state_builder.build(), 0\n\n    next_state_builder.remove_entity(next_agent_location)\n\n    if not next_state_builder.entities:\n        # Terminal state all goals have been collected, loop to beginning to\n        # make task continuous\n        return self.initial_state(), 1\n    return next_state_builder.build(), 1\n</code></pre>"},{"location":"reference/model/dynamics/grid_world/","title":"Grid World","text":""},{"location":"reference/model/dynamics/grid_world/#src.model.dynamics.grid_world.GridWorld","title":"<code>GridWorld</code>","text":"<p>             Bases: <code>object</code></p> <p>Provide common functionality for working with a grid world.</p> Source code in <code>src/model/dynamics/grid_world.py</code> <pre><code>class GridWorld(object):\n    \"\"\"Provide common functionality for working with a grid world.\"\"\"\n\n    def __init__(self, width: int, height: int) -&gt; None:\n        \"\"\"Initialise a grid world with a given size.\n\n        Raises:\n            TypeError: If the width or height are not integers\n            ValueError: if the width or height are not positive integer\n\n        Args:\n            width (int): The width of the grid world.\n            height (int): The height of the gird world.\n        \"\"\"\n        if not isinstance(width, int) or not isinstance(height, int):\n            raise TypeError(\"width and height must be valid integers\")\n        elif width &lt; 1 or height &lt; 1:\n            raise ValueError(\"width and height must be positive integers\")\n\n        self.width = width\n        self.height = height\n\n    def is_in_bounds(self, position: tuple[int, int]) -&gt; bool:\n        \"\"\"Detect either a position is within the bounds of the grid.\n\n        Args:\n            position (tuple[int, int]): the position to test\n\n        Returns:\n            bool: true where the position is within the bounds of the grid\n            world.\n        \"\"\"\n        x_pos, y_pos = position\n        return 0 &lt;= x_pos &lt; self.width and 0 &lt;= y_pos &lt; self.height\n\n    def random_in_bounds_cell(self) -&gt; tuple[int, int]:\n        \"\"\"Generate a random cell position that is within bounds.\n\n        Returns:\n            tuple[int, int]: the cell position within the grid.\n        \"\"\"\n        dimensions = np.array([self.width, self.height])\n        position_float = np.random.rand(2) * dimensions\n        position_integer = np.floor(position_float).astype(int)\n        return (position_integer[0], position_integer[1])\n\n    action_direction: Dict[Action, Tuple[int, int]] = {\n        Action.up: (0, -1),\n        Action.down: (0, 1),\n        Action.right: (1, 0),\n        Action.left: (-1, 0),\n    }\n\n    def movement_action(\n        self,\n        current_position: integer_position,\n        action: Action,\n        distance: int = 1,\n    ) -&gt; integer_position:\n        \"\"\"Calculate the adjacent cell in a given direction.\n\n        The direction is provided from the up,down,left and right actions. This\n        method calculates the next position assuming the origin is at the top\n        left of the grid.\n\n        note this may compute a cell that is out of bounds, to check and handel\n        this please use `is_in_bounds` method.\n\n        Args:\n            current_position (integer_position): the position to start from.\n            action (Action): provides the direction to move in.\n            distance (int): the amount of cells to move. Defaults to 1.\n\n        Raises:\n            ValueError: If the action provided is not a known movement action.\n\n        Returns:\n            integer_position: The position after moving.\n        \"\"\"\n        if action not in self.action_direction:\n            raise ValueError(\n                f\"Action {action.name} is not a known movement action\"\n            )\n        x_pos, y_pos = current_position\n        dir_x, dir_y = self.action_direction[action]\n        return (x_pos + dir_x * distance, y_pos + dir_y * distance)\n\n    def list_cells(self) -&gt; Generator[integer_position, None, None]:\n        \"\"\"Generate all cells in the grid world.\n\n        Yields:\n            Generator[integer_position, None, None]: each cell location\n        \"\"\"\n        for y_pos in range(self.height):\n            yield from ((x_pos, y_pos) for x_pos in range(self.width))\n\n    def get_cell_sizing(\n        self, width: int, height: int, relative_margins: float\n    ) -&gt; Tuple[int, int]:\n        \"\"\"Get the sizing of a cell in the given rectangle and margins.\n\n        Args:\n            width (int): the width of the containing rectangle\n            height (int): the hight of the containing rectangle\n            relative_margins (float): how large should the gap between cells be.\n                relative to the size of a cell with no margins\n\n        Returns:\n            Tuple[int, int]: the cell size and the margin size\n        \"\"\"\n        rows = self.height\n        columns = self.width\n\n        content_ratio = rows / columns\n        container_ratio = height / width\n\n        cell_spacing = int(\n            width / columns\n            if container_ratio &gt; content_ratio\n            else height / rows\n        )\n        margins = int(max(cell_spacing * relative_margins, 1))\n        return cell_spacing, margins\n\n    def list_cell_positions(\n        self, width: int, height: int, relative_margins: float\n    ) -&gt; location_generator:\n        \"\"\"Generate the cell locations in a given rectangle.\n\n        the cells will be centred if there is the aspect ratio's are not aligned\n\n        returns the cell position in gird world coordinates, the location of\n        corner that is closest to the origin then the corner that is the\n        furthest.\n\n        assumes cells should be square.\n\n        Args:\n            width (int): the width of the containing rectangle\n            height (int): the hight of the containing rectangle\n            relative_margins (float): how large should the gap between cells be.\n                relative to the size of a cell with no margins\n\n        Yields:\n            Iterator[location_generator]: the coordinates\n        \"\"\"\n        rows = self.height\n        columns = self.width\n\n        cell_spacing, margins = self.get_cell_sizing(\n            width, height, relative_margins\n        )\n\n        offset_min_x = int((width - columns * cell_spacing) / 2)\n        offset_min_y = int((height - rows * cell_spacing) / 2)\n\n        offset_min_x += margins // 2\n        offset_min_y += margins // 2\n\n        offset_max_x = offset_min_x + cell_spacing - margins\n        offset_max_y = offset_min_y + cell_spacing - margins\n\n        for pos in self.list_cells():\n            bounding_box = (\n                offset_min_x + cell_spacing * pos[0],\n                offset_min_y + cell_spacing * pos[1],\n                offset_max_x + cell_spacing * pos[0],\n                offset_max_y + cell_spacing * pos[1],\n            )\n            yield pos, bounding_box\n</code></pre>"},{"location":"reference/model/dynamics/grid_world/#src.model.dynamics.grid_world.GridWorld.__init__","title":"<code>__init__(width, height)</code>","text":"<p>Initialise a grid world with a given size.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If the width or height are not integers</p> <code>ValueError</code> <p>if the width or height are not positive integer</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>The width of the grid world.</p> required <code>height</code> <code>int</code> <p>The height of the gird world.</p> required Source code in <code>src/model/dynamics/grid_world.py</code> <pre><code>def __init__(self, width: int, height: int) -&gt; None:\n    \"\"\"Initialise a grid world with a given size.\n\n    Raises:\n        TypeError: If the width or height are not integers\n        ValueError: if the width or height are not positive integer\n\n    Args:\n        width (int): The width of the grid world.\n        height (int): The height of the gird world.\n    \"\"\"\n    if not isinstance(width, int) or not isinstance(height, int):\n        raise TypeError(\"width and height must be valid integers\")\n    elif width &lt; 1 or height &lt; 1:\n        raise ValueError(\"width and height must be positive integers\")\n\n    self.width = width\n    self.height = height\n</code></pre>"},{"location":"reference/model/dynamics/grid_world/#src.model.dynamics.grid_world.GridWorld.get_cell_sizing","title":"<code>get_cell_sizing(width, height, relative_margins)</code>","text":"<p>Get the sizing of a cell in the given rectangle and margins.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>the width of the containing rectangle</p> required <code>height</code> <code>int</code> <p>the hight of the containing rectangle</p> required <code>relative_margins</code> <code>float</code> <p>how large should the gap between cells be. relative to the size of a cell with no margins</p> required <p>Returns:</p> Type Description <code>Tuple[int, int]</code> <p>Tuple[int, int]: the cell size and the margin size</p> Source code in <code>src/model/dynamics/grid_world.py</code> <pre><code>def get_cell_sizing(\n    self, width: int, height: int, relative_margins: float\n) -&gt; Tuple[int, int]:\n    \"\"\"Get the sizing of a cell in the given rectangle and margins.\n\n    Args:\n        width (int): the width of the containing rectangle\n        height (int): the hight of the containing rectangle\n        relative_margins (float): how large should the gap between cells be.\n            relative to the size of a cell with no margins\n\n    Returns:\n        Tuple[int, int]: the cell size and the margin size\n    \"\"\"\n    rows = self.height\n    columns = self.width\n\n    content_ratio = rows / columns\n    container_ratio = height / width\n\n    cell_spacing = int(\n        width / columns\n        if container_ratio &gt; content_ratio\n        else height / rows\n    )\n    margins = int(max(cell_spacing * relative_margins, 1))\n    return cell_spacing, margins\n</code></pre>"},{"location":"reference/model/dynamics/grid_world/#src.model.dynamics.grid_world.GridWorld.is_in_bounds","title":"<code>is_in_bounds(position)</code>","text":"<p>Detect either a position is within the bounds of the grid.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>tuple[int, int]</code> <p>the position to test</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>true where the position is within the bounds of the grid</p> <code>bool</code> <p>world.</p> Source code in <code>src/model/dynamics/grid_world.py</code> <pre><code>def is_in_bounds(self, position: tuple[int, int]) -&gt; bool:\n    \"\"\"Detect either a position is within the bounds of the grid.\n\n    Args:\n        position (tuple[int, int]): the position to test\n\n    Returns:\n        bool: true where the position is within the bounds of the grid\n        world.\n    \"\"\"\n    x_pos, y_pos = position\n    return 0 &lt;= x_pos &lt; self.width and 0 &lt;= y_pos &lt; self.height\n</code></pre>"},{"location":"reference/model/dynamics/grid_world/#src.model.dynamics.grid_world.GridWorld.list_cell_positions","title":"<code>list_cell_positions(width, height, relative_margins)</code>","text":"<p>Generate the cell locations in a given rectangle.</p> <p>the cells will be centred if there is the aspect ratio's are not aligned</p> <p>returns the cell position in gird world coordinates, the location of corner that is closest to the origin then the corner that is the furthest.</p> <p>assumes cells should be square.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>the width of the containing rectangle</p> required <code>height</code> <code>int</code> <p>the hight of the containing rectangle</p> required <code>relative_margins</code> <code>float</code> <p>how large should the gap between cells be. relative to the size of a cell with no margins</p> required <p>Yields:</p> Type Description <code>location_generator</code> <p>Iterator[location_generator]: the coordinates</p> Source code in <code>src/model/dynamics/grid_world.py</code> <pre><code>def list_cell_positions(\n    self, width: int, height: int, relative_margins: float\n) -&gt; location_generator:\n    \"\"\"Generate the cell locations in a given rectangle.\n\n    the cells will be centred if there is the aspect ratio's are not aligned\n\n    returns the cell position in gird world coordinates, the location of\n    corner that is closest to the origin then the corner that is the\n    furthest.\n\n    assumes cells should be square.\n\n    Args:\n        width (int): the width of the containing rectangle\n        height (int): the hight of the containing rectangle\n        relative_margins (float): how large should the gap between cells be.\n            relative to the size of a cell with no margins\n\n    Yields:\n        Iterator[location_generator]: the coordinates\n    \"\"\"\n    rows = self.height\n    columns = self.width\n\n    cell_spacing, margins = self.get_cell_sizing(\n        width, height, relative_margins\n    )\n\n    offset_min_x = int((width - columns * cell_spacing) / 2)\n    offset_min_y = int((height - rows * cell_spacing) / 2)\n\n    offset_min_x += margins // 2\n    offset_min_y += margins // 2\n\n    offset_max_x = offset_min_x + cell_spacing - margins\n    offset_max_y = offset_min_y + cell_spacing - margins\n\n    for pos in self.list_cells():\n        bounding_box = (\n            offset_min_x + cell_spacing * pos[0],\n            offset_min_y + cell_spacing * pos[1],\n            offset_max_x + cell_spacing * pos[0],\n            offset_max_y + cell_spacing * pos[1],\n        )\n        yield pos, bounding_box\n</code></pre>"},{"location":"reference/model/dynamics/grid_world/#src.model.dynamics.grid_world.GridWorld.list_cells","title":"<code>list_cells()</code>","text":"<p>Generate all cells in the grid world.</p> <p>Yields:</p> Type Description <code>integer_position</code> <p>Generator[integer_position, None, None]: each cell location</p> Source code in <code>src/model/dynamics/grid_world.py</code> <pre><code>def list_cells(self) -&gt; Generator[integer_position, None, None]:\n    \"\"\"Generate all cells in the grid world.\n\n    Yields:\n        Generator[integer_position, None, None]: each cell location\n    \"\"\"\n    for y_pos in range(self.height):\n        yield from ((x_pos, y_pos) for x_pos in range(self.width))\n</code></pre>"},{"location":"reference/model/dynamics/grid_world/#src.model.dynamics.grid_world.GridWorld.movement_action","title":"<code>movement_action(current_position, action, distance=1)</code>","text":"<p>Calculate the adjacent cell in a given direction.</p> <p>The direction is provided from the up,down,left and right actions. This method calculates the next position assuming the origin is at the top left of the grid.</p> <p>note this may compute a cell that is out of bounds, to check and handel this please use <code>is_in_bounds</code> method.</p> <p>Parameters:</p> Name Type Description Default <code>current_position</code> <code>integer_position</code> <p>the position to start from.</p> required <code>action</code> <code>Action</code> <p>provides the direction to move in.</p> required <code>distance</code> <code>int</code> <p>the amount of cells to move. Defaults to 1.</p> <code>1</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the action provided is not a known movement action.</p> <p>Returns:</p> Name Type Description <code>integer_position</code> <code>integer_position</code> <p>The position after moving.</p> Source code in <code>src/model/dynamics/grid_world.py</code> <pre><code>def movement_action(\n    self,\n    current_position: integer_position,\n    action: Action,\n    distance: int = 1,\n) -&gt; integer_position:\n    \"\"\"Calculate the adjacent cell in a given direction.\n\n    The direction is provided from the up,down,left and right actions. This\n    method calculates the next position assuming the origin is at the top\n    left of the grid.\n\n    note this may compute a cell that is out of bounds, to check and handel\n    this please use `is_in_bounds` method.\n\n    Args:\n        current_position (integer_position): the position to start from.\n        action (Action): provides the direction to move in.\n        distance (int): the amount of cells to move. Defaults to 1.\n\n    Raises:\n        ValueError: If the action provided is not a known movement action.\n\n    Returns:\n        integer_position: The position after moving.\n    \"\"\"\n    if action not in self.action_direction:\n        raise ValueError(\n            f\"Action {action.name} is not a known movement action\"\n        )\n    x_pos, y_pos = current_position\n    dir_x, dir_y = self.action_direction[action]\n    return (x_pos + dir_x * distance, y_pos + dir_y * distance)\n</code></pre>"},{"location":"reference/model/dynamics/grid_world/#src.model.dynamics.grid_world.GridWorld.random_in_bounds_cell","title":"<code>random_in_bounds_cell()</code>","text":"<p>Generate a random cell position that is within bounds.</p> <p>Returns:</p> Type Description <code>tuple[int, int]</code> <p>tuple[int, int]: the cell position within the grid.</p> Source code in <code>src/model/dynamics/grid_world.py</code> <pre><code>def random_in_bounds_cell(self) -&gt; tuple[int, int]:\n    \"\"\"Generate a random cell position that is within bounds.\n\n    Returns:\n        tuple[int, int]: the cell position within the grid.\n    \"\"\"\n    dimensions = np.array([self.width, self.height])\n    position_float = np.random.rand(2) * dimensions\n    position_integer = np.floor(position_float).astype(int)\n    return (position_integer[0], position_integer[1])\n</code></pre>"},{"location":"reference/model/learning_system/","title":"Learning System","text":"<p>This package connects agents and dynamics.</p> <p>It provides methods for progressing the current state and visualising it.</p>"},{"location":"reference/model/learning_system/cell_configuration/","title":"Cell Configuration","text":""},{"location":"reference/model/learning_system/cell_configuration/#src.model.learning_system.cell_configuration.CellConfiguration","title":"<code>CellConfiguration</code>","text":"<p>             Bases: <code>object</code></p> <p>Class to represent the configuration of a cell in a given state.</p> Source code in <code>src/model/learning_system/cell_configuration.py</code> <pre><code>class CellConfiguration(object):  # noqa: WPS230 TODO refactor this\n    \"\"\"Class to represent the configuration of a cell in a given state.\"\"\"\n\n    def __init__(  # noqa: WPS211 TODO refactor this\n        self,\n        cell_value_normalised: Optional[float],\n        action_values_normalised: action_value_description,\n        cell_value_raw: Optional[float],\n        action_values_raw: action_value_description,\n        location: Tuple[int, int],\n        cell_entity: CellEntity,\n        display_mode: DisplayMode,\n    ) -&gt; None:\n        \"\"\"Create cell configuration.\n\n        Args:\n            cell_value_normalised (float): the value the cell should represent\n                in its background.\n            action_values_normalised (action_value_description): the value of\n                different actions in this cell. normalised globally 0-1\n            cell_value_raw (Optional[float]): the value the cell should report\n                in the tooltip.\n            action_values_raw (action_value_description): the value of\n                different actions in this cell. un-normalised for use in the\n                tooltip.\n            location (Tuple[int, int]): where the cell is in the grid.\n            cell_entity (CellEntity): the entity to display in this cell\n            display_mode (DisplayMode): how the cell should display its\n                information.\n        \"\"\"\n        self.cell_value_normalised = cell_value_normalised\n        self.action_values_normalised = action_values_normalised\n        self.cell_value_raw = cell_value_raw\n        self.action_values_raw = action_values_raw\n        self.location = location\n        self.cell_entity = cell_entity\n        self.display_mode = display_mode\n</code></pre>"},{"location":"reference/model/learning_system/cell_configuration/#src.model.learning_system.cell_configuration.CellConfiguration.__init__","title":"<code>__init__(cell_value_normalised, action_values_normalised, cell_value_raw, action_values_raw, location, cell_entity, display_mode)</code>","text":"<p>Create cell configuration.</p> <p>Parameters:</p> Name Type Description Default <code>cell_value_normalised</code> <code>float</code> <p>the value the cell should represent in its background.</p> required <code>action_values_normalised</code> <code>action_value_description</code> <p>the value of different actions in this cell. normalised globally 0-1</p> required <code>cell_value_raw</code> <code>Optional[float]</code> <p>the value the cell should report in the tooltip.</p> required <code>action_values_raw</code> <code>action_value_description</code> <p>the value of different actions in this cell. un-normalised for use in the tooltip.</p> required <code>location</code> <code>Tuple[int, int]</code> <p>where the cell is in the grid.</p> required <code>cell_entity</code> <code>CellEntity</code> <p>the entity to display in this cell</p> required <code>display_mode</code> <code>DisplayMode</code> <p>how the cell should display its information.</p> required Source code in <code>src/model/learning_system/cell_configuration.py</code> <pre><code>def __init__(  # noqa: WPS211 TODO refactor this\n    self,\n    cell_value_normalised: Optional[float],\n    action_values_normalised: action_value_description,\n    cell_value_raw: Optional[float],\n    action_values_raw: action_value_description,\n    location: Tuple[int, int],\n    cell_entity: CellEntity,\n    display_mode: DisplayMode,\n) -&gt; None:\n    \"\"\"Create cell configuration.\n\n    Args:\n        cell_value_normalised (float): the value the cell should represent\n            in its background.\n        action_values_normalised (action_value_description): the value of\n            different actions in this cell. normalised globally 0-1\n        cell_value_raw (Optional[float]): the value the cell should report\n            in the tooltip.\n        action_values_raw (action_value_description): the value of\n            different actions in this cell. un-normalised for use in the\n            tooltip.\n        location (Tuple[int, int]): where the cell is in the grid.\n        cell_entity (CellEntity): the entity to display in this cell\n        display_mode (DisplayMode): how the cell should display its\n            information.\n    \"\"\"\n    self.cell_value_normalised = cell_value_normalised\n    self.action_values_normalised = action_values_normalised\n    self.cell_value_raw = cell_value_raw\n    self.action_values_raw = action_values_raw\n    self.location = location\n    self.cell_entity = cell_entity\n    self.display_mode = display_mode\n</code></pre>"},{"location":"reference/model/learning_system/cell_configuration/#src.model.learning_system.cell_configuration.DisplayMode","title":"<code>DisplayMode</code>","text":"<p>             Bases: <code>Enum</code></p> <p>Enumerates the different possible display styles.</p> Source code in <code>src/model/learning_system/cell_configuration.py</code> <pre><code>class DisplayMode(Enum):\n    \"\"\"Enumerates the different possible display styles.\"\"\"\n\n    default = 0\n    state_value = 1\n    action_value_global = 2\n    action_value_local = 3\n    best_action = 4\n</code></pre>"},{"location":"reference/model/learning_system/learning_instance/","title":"Learning Instance","text":""},{"location":"reference/model/learning_system/learning_instance/#src.model.learning_system.learning_instance.LearningInstance","title":"<code>LearningInstance</code>","text":"<p>             Bases: <code>object</code></p> <p>An instance of an agent interacting with the environment.</p> Source code in <code>src/model/learning_system/learning_instance.py</code> <pre><code>class LearningInstance(object):\n    \"\"\"An instance of an agent interacting with the environment.\"\"\"\n\n    def __init__(self, agent: BaseAgent, dynamics: BaseDynamics) -&gt; None:\n        \"\"\"Create the learning instance.\n\n        Args:\n            agent (BaseAgent): The agent to learn.\n            dynamics (BaseDynamics): The dynamics the agent is learning.\n        \"\"\"\n        self.agent = agent\n        self.dynamics = dynamics\n        self._current_state: Optional[int] = None\n\n    def get_current_state(self) -&gt; int:\n        \"\"\"Get the current state ID.\n\n        Returns:\n            int: the current state ID\n        \"\"\"\n        if self._current_state is not None:\n            return self._current_state\n        self._current_state = self.dynamics.initial_state_id()\n        return self._current_state\n\n    def reset_state(self) -&gt; int:\n        \"\"\"Reset the current state to the initial state.\n\n        Returns:\n            int: the initial state id\n        \"\"\"\n        self._current_state = self.dynamics.initial_state_id()\n        return self._current_state\n\n    def perform_action(\n        self,\n    ) -&gt; Tuple[int, Action, int, float]:\n        \"\"\"Perform one action chosen by the agent.\n\n        Returns:\n            Tuple[int, Action, int, float]: the transition information, the last\n            state, the action chosen, the next state, the reward received for\n            this action.\n        \"\"\"\n        last_state = self.get_current_state()\n\n        action = self.agent.evaluate_policy(last_state)\n        next_state, reward = self.dynamics.next_state_id(last_state, action)\n        self.agent.record_transition(last_state, action, next_state, reward)\n        self._current_state = next_state\n        return (\n            last_state,\n            action,\n            next_state,\n            reward,\n        )\n</code></pre>"},{"location":"reference/model/learning_system/learning_instance/#src.model.learning_system.learning_instance.LearningInstance.__init__","title":"<code>__init__(agent, dynamics)</code>","text":"<p>Create the learning instance.</p> <p>Parameters:</p> Name Type Description Default <code>agent</code> <code>BaseAgent</code> <p>The agent to learn.</p> required <code>dynamics</code> <code>BaseDynamics</code> <p>The dynamics the agent is learning.</p> required Source code in <code>src/model/learning_system/learning_instance.py</code> <pre><code>def __init__(self, agent: BaseAgent, dynamics: BaseDynamics) -&gt; None:\n    \"\"\"Create the learning instance.\n\n    Args:\n        agent (BaseAgent): The agent to learn.\n        dynamics (BaseDynamics): The dynamics the agent is learning.\n    \"\"\"\n    self.agent = agent\n    self.dynamics = dynamics\n    self._current_state: Optional[int] = None\n</code></pre>"},{"location":"reference/model/learning_system/learning_instance/#src.model.learning_system.learning_instance.LearningInstance.get_current_state","title":"<code>get_current_state()</code>","text":"<p>Get the current state ID.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>the current state ID</p> Source code in <code>src/model/learning_system/learning_instance.py</code> <pre><code>def get_current_state(self) -&gt; int:\n    \"\"\"Get the current state ID.\n\n    Returns:\n        int: the current state ID\n    \"\"\"\n    if self._current_state is not None:\n        return self._current_state\n    self._current_state = self.dynamics.initial_state_id()\n    return self._current_state\n</code></pre>"},{"location":"reference/model/learning_system/learning_instance/#src.model.learning_system.learning_instance.LearningInstance.perform_action","title":"<code>perform_action()</code>","text":"<p>Perform one action chosen by the agent.</p> <p>Returns:</p> Type Description <code>int</code> <p>Tuple[int, Action, int, float]: the transition information, the last</p> <code>Action</code> <p>state, the action chosen, the next state, the reward received for</p> <code>int</code> <p>this action.</p> Source code in <code>src/model/learning_system/learning_instance.py</code> <pre><code>def perform_action(\n    self,\n) -&gt; Tuple[int, Action, int, float]:\n    \"\"\"Perform one action chosen by the agent.\n\n    Returns:\n        Tuple[int, Action, int, float]: the transition information, the last\n        state, the action chosen, the next state, the reward received for\n        this action.\n    \"\"\"\n    last_state = self.get_current_state()\n\n    action = self.agent.evaluate_policy(last_state)\n    next_state, reward = self.dynamics.next_state_id(last_state, action)\n    self.agent.record_transition(last_state, action, next_state, reward)\n    self._current_state = next_state\n    return (\n        last_state,\n        action,\n        next_state,\n        reward,\n    )\n</code></pre>"},{"location":"reference/model/learning_system/learning_instance/#src.model.learning_system.learning_instance.LearningInstance.reset_state","title":"<code>reset_state()</code>","text":"<p>Reset the current state to the initial state.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>the initial state id</p> Source code in <code>src/model/learning_system/learning_instance.py</code> <pre><code>def reset_state(self) -&gt; int:\n    \"\"\"Reset the current state to the initial state.\n\n    Returns:\n        int: the initial state id\n    \"\"\"\n    self._current_state = self.dynamics.initial_state_id()\n    return self._current_state\n</code></pre>"},{"location":"reference/model/learning_system/learning_system/","title":"Learning System","text":""},{"location":"reference/model/learning_system/learning_system/#src.model.learning_system.learning_system.LearningSystem","title":"<code>LearningSystem</code>","text":"<p>             Bases: <code>object</code></p> <p>Controller for managing one pair of agent and dynamics.</p> Source code in <code>src/model/learning_system/learning_system.py</code> <pre><code>class LearningSystem(object):\n    \"\"\"Controller for managing one pair of agent and dynamics.\"\"\"\n\n    def __init__(\n        self,\n        agent: AgentOptions,\n        dynamics: DynamicsOptions,\n    ) -&gt; None:\n        \"\"\"Create the controller.\n\n        each instance can only build instance to keep consistency, as\n        each dynamics will have its own state numbering system and each agent\n        will depend on that.\n\n        Args:\n            agent (AgentOptions): which agent to create\n            dynamics (DynamicsOptions): which dynamics to create\n        \"\"\"\n        self._agent_option = agent\n        self._dynamics_option = dynamics\n        self._agent: Optional[BaseAgent] = None\n        self._dynamics: Optional[BaseDynamics] = None\n\n        self._main_learning_instance: Optional[LearningInstance] = None\n        self._state_description_factory: Optional[\n            StateDescriptionFactory\n        ] = None\n        self._display_mode = DisplayMode.default\n\n        self._agent_config = ConfigReader().agent()\n\n    def get_dynamics(self) -&gt; BaseDynamics:\n        \"\"\"Get the dynamics.\n\n        Raises:\n            ValueError: if the dynamics option specified is unknown.\n\n        Returns:\n            BaseDynamics: the dynamics instance, the returned class will be a\n            concrete instance that extends `BaseDynamics`\n        \"\"\"\n        if self._dynamics is not None:\n            # reuse existing dynamics to avoid inconsistencies\n            return self._dynamics\n\n        dynamics_config = ConfigReader().grid_world()\n\n        match self._dynamics_option:\n            case DynamicsOptions.collection:\n                self._dynamics = CollectionDynamics(dynamics_config)\n            case _:\n                raise ValueError(\n                    f\"unknown dynamics {self._dynamics_option.name}\"\n                )\n\n        return self._dynamics\n\n    def get_agent(self) -&gt; BaseAgent:\n        \"\"\"Get the agent.\n\n        this will perform any necessary setup, this may take time consider\n        offloading this to another thread\n\n        Raises:\n            ValueError: if the agent specified is not known\n\n        Returns:\n            BaseAgent: the agent to instance. this agent is to be used with the\n            dynamics provided to avoid inconsistencies.\n        \"\"\"\n        if self._agent is not None:\n            return self._agent\n\n        match self._agent_option:\n            case AgentOptions.value_iteration:\n                self._agent = ValueIterationAgent(\n                    self._agent_config, self.get_dynamics()\n                )\n            case AgentOptions.value_iteration_optimised:\n                self._agent = ValueIterationAgentOptimised(\n                    self._agent_config, self.get_dynamics()\n                )\n            case AgentOptions.q_learning:\n                self._agent = QLearningAgent(self._agent_config)\n            case _:\n                raise ValueError(f\"unknown agent {self._agent_option.name}\")\n\n        return self._agent\n\n    def get_current_state(self) -&gt; StateDescription:\n        \"\"\"Get the current state of the learning instance.\n\n        Returns:\n            StateDescription: the current configuration for this state.\n        \"\"\"\n        instance = self.__get_learning_instance()\n        return self.__state_id_to_description(instance.get_current_state())\n\n    def perform_action(\n        self,\n    ):\n        \"\"\"Perform one action chosen by the agent.\"\"\"\n        self.__get_learning_instance().perform_action()\n\n    def reset_state(self):\n        \"\"\"Reset the current state to the initial state.\"\"\"\n        instance = self.__get_learning_instance()\n        instance.reset_state()\n\n    def set_display_mode(self, display_mode: DisplayMode):\n        \"\"\"Set the learning instance's display mode.\n\n        Args:\n            display_mode (DisplayMode): how to display the learning instance\n        \"\"\"\n        self._display_mode = display_mode\n\n    def __state_id_to_description(self, state_id: int) -&gt; StateDescription:\n        if self._state_description_factory is None:\n            self._state_description_factory = StateDescriptionFactory(\n                self.get_agent(), self.get_dynamics(), self._display_mode\n            )\n        self._state_description_factory.display_mode = self._display_mode\n        return self._state_description_factory.create_state_description(\n            state_id\n        )\n\n    def __get_learning_instance(self):\n        if self._main_learning_instance is not None:\n            return self._main_learning_instance\n        self._main_learning_instance = LearningInstance(\n            self.get_agent(), self.get_dynamics()\n        )\n        return self._main_learning_instance\n</code></pre>"},{"location":"reference/model/learning_system/learning_system/#src.model.learning_system.learning_system.LearningSystem.__init__","title":"<code>__init__(agent, dynamics)</code>","text":"<p>Create the controller.</p> <p>each instance can only build instance to keep consistency, as each dynamics will have its own state numbering system and each agent will depend on that.</p> <p>Parameters:</p> Name Type Description Default <code>agent</code> <code>AgentOptions</code> <p>which agent to create</p> required <code>dynamics</code> <code>DynamicsOptions</code> <p>which dynamics to create</p> required Source code in <code>src/model/learning_system/learning_system.py</code> <pre><code>def __init__(\n    self,\n    agent: AgentOptions,\n    dynamics: DynamicsOptions,\n) -&gt; None:\n    \"\"\"Create the controller.\n\n    each instance can only build instance to keep consistency, as\n    each dynamics will have its own state numbering system and each agent\n    will depend on that.\n\n    Args:\n        agent (AgentOptions): which agent to create\n        dynamics (DynamicsOptions): which dynamics to create\n    \"\"\"\n    self._agent_option = agent\n    self._dynamics_option = dynamics\n    self._agent: Optional[BaseAgent] = None\n    self._dynamics: Optional[BaseDynamics] = None\n\n    self._main_learning_instance: Optional[LearningInstance] = None\n    self._state_description_factory: Optional[\n        StateDescriptionFactory\n    ] = None\n    self._display_mode = DisplayMode.default\n\n    self._agent_config = ConfigReader().agent()\n</code></pre>"},{"location":"reference/model/learning_system/learning_system/#src.model.learning_system.learning_system.LearningSystem.get_agent","title":"<code>get_agent()</code>","text":"<p>Get the agent.</p> <p>this will perform any necessary setup, this may take time consider offloading this to another thread</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if the agent specified is not known</p> <p>Returns:</p> Name Type Description <code>BaseAgent</code> <code>BaseAgent</code> <p>the agent to instance. this agent is to be used with the</p> <code>BaseAgent</code> <p>dynamics provided to avoid inconsistencies.</p> Source code in <code>src/model/learning_system/learning_system.py</code> <pre><code>def get_agent(self) -&gt; BaseAgent:\n    \"\"\"Get the agent.\n\n    this will perform any necessary setup, this may take time consider\n    offloading this to another thread\n\n    Raises:\n        ValueError: if the agent specified is not known\n\n    Returns:\n        BaseAgent: the agent to instance. this agent is to be used with the\n        dynamics provided to avoid inconsistencies.\n    \"\"\"\n    if self._agent is not None:\n        return self._agent\n\n    match self._agent_option:\n        case AgentOptions.value_iteration:\n            self._agent = ValueIterationAgent(\n                self._agent_config, self.get_dynamics()\n            )\n        case AgentOptions.value_iteration_optimised:\n            self._agent = ValueIterationAgentOptimised(\n                self._agent_config, self.get_dynamics()\n            )\n        case AgentOptions.q_learning:\n            self._agent = QLearningAgent(self._agent_config)\n        case _:\n            raise ValueError(f\"unknown agent {self._agent_option.name}\")\n\n    return self._agent\n</code></pre>"},{"location":"reference/model/learning_system/learning_system/#src.model.learning_system.learning_system.LearningSystem.get_current_state","title":"<code>get_current_state()</code>","text":"<p>Get the current state of the learning instance.</p> <p>Returns:</p> Name Type Description <code>StateDescription</code> <code>StateDescription</code> <p>the current configuration for this state.</p> Source code in <code>src/model/learning_system/learning_system.py</code> <pre><code>def get_current_state(self) -&gt; StateDescription:\n    \"\"\"Get the current state of the learning instance.\n\n    Returns:\n        StateDescription: the current configuration for this state.\n    \"\"\"\n    instance = self.__get_learning_instance()\n    return self.__state_id_to_description(instance.get_current_state())\n</code></pre>"},{"location":"reference/model/learning_system/learning_system/#src.model.learning_system.learning_system.LearningSystem.get_dynamics","title":"<code>get_dynamics()</code>","text":"<p>Get the dynamics.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if the dynamics option specified is unknown.</p> <p>Returns:</p> Name Type Description <code>BaseDynamics</code> <code>BaseDynamics</code> <p>the dynamics instance, the returned class will be a</p> <code>BaseDynamics</code> <p>concrete instance that extends <code>BaseDynamics</code></p> Source code in <code>src/model/learning_system/learning_system.py</code> <pre><code>def get_dynamics(self) -&gt; BaseDynamics:\n    \"\"\"Get the dynamics.\n\n    Raises:\n        ValueError: if the dynamics option specified is unknown.\n\n    Returns:\n        BaseDynamics: the dynamics instance, the returned class will be a\n        concrete instance that extends `BaseDynamics`\n    \"\"\"\n    if self._dynamics is not None:\n        # reuse existing dynamics to avoid inconsistencies\n        return self._dynamics\n\n    dynamics_config = ConfigReader().grid_world()\n\n    match self._dynamics_option:\n        case DynamicsOptions.collection:\n            self._dynamics = CollectionDynamics(dynamics_config)\n        case _:\n            raise ValueError(\n                f\"unknown dynamics {self._dynamics_option.name}\"\n            )\n\n    return self._dynamics\n</code></pre>"},{"location":"reference/model/learning_system/learning_system/#src.model.learning_system.learning_system.LearningSystem.perform_action","title":"<code>perform_action()</code>","text":"<p>Perform one action chosen by the agent.</p> Source code in <code>src/model/learning_system/learning_system.py</code> <pre><code>def perform_action(\n    self,\n):\n    \"\"\"Perform one action chosen by the agent.\"\"\"\n    self.__get_learning_instance().perform_action()\n</code></pre>"},{"location":"reference/model/learning_system/learning_system/#src.model.learning_system.learning_system.LearningSystem.reset_state","title":"<code>reset_state()</code>","text":"<p>Reset the current state to the initial state.</p> Source code in <code>src/model/learning_system/learning_system.py</code> <pre><code>def reset_state(self):\n    \"\"\"Reset the current state to the initial state.\"\"\"\n    instance = self.__get_learning_instance()\n    instance.reset_state()\n</code></pre>"},{"location":"reference/model/learning_system/learning_system/#src.model.learning_system.learning_system.LearningSystem.set_display_mode","title":"<code>set_display_mode(display_mode)</code>","text":"<p>Set the learning instance's display mode.</p> <p>Parameters:</p> Name Type Description Default <code>display_mode</code> <code>DisplayMode</code> <p>how to display the learning instance</p> required Source code in <code>src/model/learning_system/learning_system.py</code> <pre><code>def set_display_mode(self, display_mode: DisplayMode):\n    \"\"\"Set the learning instance's display mode.\n\n    Args:\n        display_mode (DisplayMode): how to display the learning instance\n    \"\"\"\n    self._display_mode = display_mode\n</code></pre>"},{"location":"reference/model/learning_system/options/","title":"Options","text":""},{"location":"reference/model/learning_system/options/#src.model.learning_system.options.AgentOptions","title":"<code>AgentOptions</code>","text":"<p>             Bases: <code>Enum</code></p> <p>Enumerates the possible agents.</p> Source code in <code>src/model/learning_system/options.py</code> <pre><code>class AgentOptions(Enum):\n    \"\"\"Enumerates the possible agents.\"\"\"\n\n    value_iteration_optimised = 1\n    value_iteration = 2\n    q_learning = 3\n</code></pre>"},{"location":"reference/model/learning_system/options/#src.model.learning_system.options.DynamicsOptions","title":"<code>DynamicsOptions</code>","text":"<p>             Bases: <code>Enum</code></p> <p>Enumerates the possible agents.</p> Source code in <code>src/model/learning_system/options.py</code> <pre><code>class DynamicsOptions(Enum):\n    \"\"\"Enumerates the possible agents.\"\"\"\n\n    collection = 1\n</code></pre>"},{"location":"reference/model/learning_system/state_description/","title":"State Description","text":""},{"location":"reference/model/learning_system/state_description/#src.model.learning_system.state_description.StateDescription","title":"<code>StateDescription</code>","text":"<p>             Bases: <code>object</code></p> <p>Compile together the dynamic static state information.</p> Source code in <code>src/model/learning_system/state_description.py</code> <pre><code>class StateDescription(object):\n    \"\"\"Compile together the dynamic static state information.\"\"\"\n\n    def __init__(\n        self,\n        grid_world: GridWorld,\n        state: StateInstance,\n        cell_config: cell_config_listing,\n        display_mode: DisplayMode,\n    ) -&gt; None:\n        \"\"\"Initiate this state description.\n\n        Args:\n            grid_world (GridWorld): the grid world of this state.\n            state (StateInstance): the state to describe.\n            cell_config (cell_config_listing): the configuration for cells in\n                the view. allowing for visualisations of the current state\n                value table.\n            display_mode (DisplayMode): how to display this state.\n        \"\"\"\n        self.grid_world = grid_world\n        self.state = state\n        self.display_mode = display_mode\n        self.cell_config = cell_config\n</code></pre>"},{"location":"reference/model/learning_system/state_description/#src.model.learning_system.state_description.StateDescription.__init__","title":"<code>__init__(grid_world, state, cell_config, display_mode)</code>","text":"<p>Initiate this state description.</p> <p>Parameters:</p> Name Type Description Default <code>grid_world</code> <code>GridWorld</code> <p>the grid world of this state.</p> required <code>state</code> <code>StateInstance</code> <p>the state to describe.</p> required <code>cell_config</code> <code>cell_config_listing</code> <p>the configuration for cells in the view. allowing for visualisations of the current state value table.</p> required <code>display_mode</code> <code>DisplayMode</code> <p>how to display this state.</p> required Source code in <code>src/model/learning_system/state_description.py</code> <pre><code>def __init__(\n    self,\n    grid_world: GridWorld,\n    state: StateInstance,\n    cell_config: cell_config_listing,\n    display_mode: DisplayMode,\n) -&gt; None:\n    \"\"\"Initiate this state description.\n\n    Args:\n        grid_world (GridWorld): the grid world of this state.\n        state (StateInstance): the state to describe.\n        cell_config (cell_config_listing): the configuration for cells in\n            the view. allowing for visualisations of the current state\n            value table.\n        display_mode (DisplayMode): how to display this state.\n    \"\"\"\n    self.grid_world = grid_world\n    self.state = state\n    self.display_mode = display_mode\n    self.cell_config = cell_config\n</code></pre>"},{"location":"reference/model/learning_system/state_description_factory/","title":"State Description Factory","text":""},{"location":"reference/model/learning_system/state_description_factory/#src.model.learning_system.state_description_factory.StateDescriptionFactory","title":"<code>StateDescriptionFactory</code>","text":"<p>             Bases: <code>object</code></p> <p>Factory for creating state descriptions.</p> Source code in <code>src/model/learning_system/state_description_factory.py</code> <pre><code>class StateDescriptionFactory(object):\n    \"\"\"Factory for creating state descriptions.\"\"\"\n\n    def __init__(\n        self,\n        agent: BaseAgent,\n        dynamics: BaseDynamics,\n        display_mode: DisplayMode,\n    ) -&gt; None:\n        \"\"\"Initialise the state Description factory.\n\n        Args:\n            agent (BaseAgent): the agent, used to get get the cell values.\n            dynamics (BaseDynamics): the dynamics the state is in.\n            display_mode (DisplayMode): the display_mode of the cell.\n        \"\"\"\n        self.agent = agent\n        self.dynamics = dynamics\n        self.grid_world = dynamics.grid_world\n        self.value_normalisation_factory = NormaliserFactory(\n            self.agent,\n            self.dynamics,\n            isinstance(self.agent, ValueIterationAgent),\n        )\n        self.display_mode = display_mode\n\n    def create_state_description(self, state_id: int) -&gt; StateDescription:\n        \"\"\"Get a state description for this state ID.\n\n        Args:\n            state_id (int): the state to represent in the view\n\n        Returns:\n            StateDescription: the state description\n        \"\"\"\n        normaliser = self.value_normalisation_factory.create_normaliser(\n            state_id\n        )\n        state = self.dynamics.state_pool.get_state_from_id(state_id)\n        config = {\n            cell: self.__cell_configuration(state, normaliser, cell)\n            for cell in self.grid_world.list_cells()\n        }\n\n        return StateDescription(\n            self.grid_world, state, config, self.display_mode\n        )\n\n    def __cell_configuration(\n        self,\n        state: StateInstance,\n        normaliser: StateValueNormaliser,\n        cell: Tuple[int, int],\n    ) -&gt; CellConfiguration:\n        \"\"\"Get the configuration of a cell in a given state.\n\n        Args:\n            state (StateInstance): the state that this cell is in.\n            normaliser (StateValueNormaliser): normaliser to get value\n            cell (tuple[int, int]): the cell to check.\n\n        Returns:\n            CellConfiguration: the cell's configuration\n        \"\"\"\n        action_values_normalised: action_value_description = {}\n        action_values_raw: action_value_description = {}\n        for action in Action:\n            action_values_normalised[\n                action\n            ] = normaliser.get_state_action_value_normalised(cell, action)\n            action_values_raw[action] = normaliser.get_state_action_value_raw(\n                cell, action\n            )\n\n        return CellConfiguration(\n            normaliser.get_state_value_normalised(cell),\n            action_values_normalised,\n            normaliser.get_state_value_raw(cell),\n            action_values_raw,\n            cell,\n            self.__cell_entity(state, cell),\n            self.display_mode,\n        )\n\n    def __cell_entity(\n        self, state: StateInstance, cell: tuple[int, int]\n    ) -&gt; CellEntity:\n        \"\"\"Get the cell entity at a given location.\n\n        Args:\n            state (StateInstance): the state the cell is in.\n            cell (tuple[int, int]): the location of the cell to check.\n\n        Raises:\n            ValueError: if the cell is not a valid location\n\n        Returns:\n            CellEntity: the cell entity at this location\n        \"\"\"\n        if not self.grid_world.is_in_bounds(cell):\n            raise ValueError(f\"location {cell} is not in bounds\")\n\n        if cell == state.agent_location:\n            return CellEntity.agent\n\n        return state.entities.get(cell, CellEntity.empty)\n</code></pre>"},{"location":"reference/model/learning_system/state_description_factory/#src.model.learning_system.state_description_factory.StateDescriptionFactory.__cell_configuration","title":"<code>__cell_configuration(state, normaliser, cell)</code>","text":"<p>Get the configuration of a cell in a given state.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>StateInstance</code> <p>the state that this cell is in.</p> required <code>normaliser</code> <code>StateValueNormaliser</code> <p>normaliser to get value</p> required <code>cell</code> <code>tuple[int, int]</code> <p>the cell to check.</p> required <p>Returns:</p> Name Type Description <code>CellConfiguration</code> <code>CellConfiguration</code> <p>the cell's configuration</p> Source code in <code>src/model/learning_system/state_description_factory.py</code> <pre><code>def __cell_configuration(\n    self,\n    state: StateInstance,\n    normaliser: StateValueNormaliser,\n    cell: Tuple[int, int],\n) -&gt; CellConfiguration:\n    \"\"\"Get the configuration of a cell in a given state.\n\n    Args:\n        state (StateInstance): the state that this cell is in.\n        normaliser (StateValueNormaliser): normaliser to get value\n        cell (tuple[int, int]): the cell to check.\n\n    Returns:\n        CellConfiguration: the cell's configuration\n    \"\"\"\n    action_values_normalised: action_value_description = {}\n    action_values_raw: action_value_description = {}\n    for action in Action:\n        action_values_normalised[\n            action\n        ] = normaliser.get_state_action_value_normalised(cell, action)\n        action_values_raw[action] = normaliser.get_state_action_value_raw(\n            cell, action\n        )\n\n    return CellConfiguration(\n        normaliser.get_state_value_normalised(cell),\n        action_values_normalised,\n        normaliser.get_state_value_raw(cell),\n        action_values_raw,\n        cell,\n        self.__cell_entity(state, cell),\n        self.display_mode,\n    )\n</code></pre>"},{"location":"reference/model/learning_system/state_description_factory/#src.model.learning_system.state_description_factory.StateDescriptionFactory.__cell_entity","title":"<code>__cell_entity(state, cell)</code>","text":"<p>Get the cell entity at a given location.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>StateInstance</code> <p>the state the cell is in.</p> required <code>cell</code> <code>tuple[int, int]</code> <p>the location of the cell to check.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>if the cell is not a valid location</p> <p>Returns:</p> Name Type Description <code>CellEntity</code> <code>CellEntity</code> <p>the cell entity at this location</p> Source code in <code>src/model/learning_system/state_description_factory.py</code> <pre><code>def __cell_entity(\n    self, state: StateInstance, cell: tuple[int, int]\n) -&gt; CellEntity:\n    \"\"\"Get the cell entity at a given location.\n\n    Args:\n        state (StateInstance): the state the cell is in.\n        cell (tuple[int, int]): the location of the cell to check.\n\n    Raises:\n        ValueError: if the cell is not a valid location\n\n    Returns:\n        CellEntity: the cell entity at this location\n    \"\"\"\n    if not self.grid_world.is_in_bounds(cell):\n        raise ValueError(f\"location {cell} is not in bounds\")\n\n    if cell == state.agent_location:\n        return CellEntity.agent\n\n    return state.entities.get(cell, CellEntity.empty)\n</code></pre>"},{"location":"reference/model/learning_system/state_description_factory/#src.model.learning_system.state_description_factory.StateDescriptionFactory.__init__","title":"<code>__init__(agent, dynamics, display_mode)</code>","text":"<p>Initialise the state Description factory.</p> <p>Parameters:</p> Name Type Description Default <code>agent</code> <code>BaseAgent</code> <p>the agent, used to get get the cell values.</p> required <code>dynamics</code> <code>BaseDynamics</code> <p>the dynamics the state is in.</p> required <code>display_mode</code> <code>DisplayMode</code> <p>the display_mode of the cell.</p> required Source code in <code>src/model/learning_system/state_description_factory.py</code> <pre><code>def __init__(\n    self,\n    agent: BaseAgent,\n    dynamics: BaseDynamics,\n    display_mode: DisplayMode,\n) -&gt; None:\n    \"\"\"Initialise the state Description factory.\n\n    Args:\n        agent (BaseAgent): the agent, used to get get the cell values.\n        dynamics (BaseDynamics): the dynamics the state is in.\n        display_mode (DisplayMode): the display_mode of the cell.\n    \"\"\"\n    self.agent = agent\n    self.dynamics = dynamics\n    self.grid_world = dynamics.grid_world\n    self.value_normalisation_factory = NormaliserFactory(\n        self.agent,\n        self.dynamics,\n        isinstance(self.agent, ValueIterationAgent),\n    )\n    self.display_mode = display_mode\n</code></pre>"},{"location":"reference/model/learning_system/state_description_factory/#src.model.learning_system.state_description_factory.StateDescriptionFactory.create_state_description","title":"<code>create_state_description(state_id)</code>","text":"<p>Get a state description for this state ID.</p> <p>Parameters:</p> Name Type Description Default <code>state_id</code> <code>int</code> <p>the state to represent in the view</p> required <p>Returns:</p> Name Type Description <code>StateDescription</code> <code>StateDescription</code> <p>the state description</p> Source code in <code>src/model/learning_system/state_description_factory.py</code> <pre><code>def create_state_description(self, state_id: int) -&gt; StateDescription:\n    \"\"\"Get a state description for this state ID.\n\n    Args:\n        state_id (int): the state to represent in the view\n\n    Returns:\n        StateDescription: the state description\n    \"\"\"\n    normaliser = self.value_normalisation_factory.create_normaliser(\n        state_id\n    )\n    state = self.dynamics.state_pool.get_state_from_id(state_id)\n    config = {\n        cell: self.__cell_configuration(state, normaliser, cell)\n        for cell in self.grid_world.list_cells()\n    }\n\n    return StateDescription(\n        self.grid_world, state, config, self.display_mode\n    )\n</code></pre>"},{"location":"reference/model/learning_system/value_range_normaliser/","title":"Value Range Normaliser","text":"<p>Package for managing the value at different states for visualisation.</p>"},{"location":"reference/model/learning_system/value_range_normaliser/normaliser/","title":"Normaliser","text":""},{"location":"reference/model/learning_system/value_range_normaliser/normaliser/#src.model.learning_system.value_range_normaliser.normaliser.StateValueNormaliser","title":"<code>StateValueNormaliser</code>","text":"<p>             Bases: <code>object</code></p> <p>Compute the normalised value of an agent being in a state.</p> Source code in <code>src/model/learning_system/value_range_normaliser/normaliser.py</code> <pre><code>class StateValueNormaliser(object):\n    \"\"\"Compute the normalised value of an agent being in a state.\"\"\"\n\n    def __init__(\n        self,\n        agent: BaseAgent,\n        state_pool: StatePool,\n        entities: entities_type,\n        value_range: ValueRange,\n    ) -&gt; None:\n        \"\"\"Initialise the normaliser.\n\n        this class will normalise the values between 0 and 1.\n\n\n        Args:\n            agent (BaseAgent): the agent to decide the value\n            state_pool (StatePool): a state pool with all possible states.\n            entities (entities_type): the entity space to consider.\n            value_range (ValueRange): the range of possible values for this\n                agent and dynamics\n        \"\"\"\n        self.agent = agent\n        self.state_pool = state_pool\n        self.entities = entities\n        self.value_range = value_range\n        self.state_value_cache: Dict[Tuple[int, int], float] = {}\n        self.action_value_cache: Dict[action_value_tuple, float] = {}\n\n    def get_state_action_value_normalised(\n        self,\n        new_agent_location: Tuple[int, int],\n        action: Action,\n    ) -&gt; Union[float, None]:\n        \"\"\"Get the normalised value of a given agent location and action.\n\n        Args:\n            new_agent_location (Tuple[int, int]): the new agents location\n            action (Action): the action to perform\n\n        Returns:\n            Union[float, None]: the value if one can be found.\n        \"\"\"\n        cache_key = (new_agent_location, action)\n        cached_value = self.action_value_cache.get(cache_key, None)\n        if cached_value is not None:\n            return cached_value\n\n        state = self.__get_agent_state(new_agent_location)\n        if state is None:\n            return None\n        action_value = self.value_range.rescale_value(\n            ValueType.state_action_value,\n            self.agent.get_state_action_value(state, action),\n        )\n        self.action_value_cache[cache_key] = action_value\n        return action_value\n\n    def get_state_value_normalised(\n        self, new_agent_location: Tuple[int, int]\n    ) -&gt; Union[float, None]:\n        \"\"\"Get the normalised value of the agent being in this location.\n\n        Args:\n            new_agent_location (Tuple[int, int]): the new agents location\n\n        Returns:\n            Union[float, None]: the value if one can be found.\n        \"\"\"\n        cached_value = self.state_value_cache.get(new_agent_location, None)\n        if cached_value is not None:\n            return cached_value\n\n        state = self.__get_agent_state(new_agent_location)\n        if state is None:\n            return None\n\n        state_value = self.value_range.rescale_value(\n            ValueType.state_value,\n            self.agent.get_state_value(state),\n        )\n        self.state_value_cache[new_agent_location] = state_value\n\n        return state_value\n\n    def get_state_action_value_raw(\n        self, new_agent_location: Tuple[int, int], action: Action\n    ) -&gt; Optional[float]:\n        \"\"\"Get the un-normalised value of a given agent location and action.\n\n        Args:\n            new_agent_location (Tuple[int, int]): the location the agent is in\n            action (Action): the action to perform.\n\n        Returns:\n            Optional[float]: the raw value of this action state combination\n            according to the agent.\n        \"\"\"\n        state = self.__get_agent_state(new_agent_location)\n        if state is None:\n            return None\n        return self.agent.get_state_action_value(state, action)\n\n    def get_state_value_raw(\n        self, new_agent_location: Tuple[int, int]\n    ) -&gt; Optional[float]:\n        \"\"\"Get the un-normalised value of the agent being in this location.\n\n        Args:\n            new_agent_location (Tuple[int, int]): _description_\n\n        Returns:\n            Optional[float]: the the raw value of the agent being in this\n            location according to the agent.\n        \"\"\"\n        state = self.__get_agent_state(new_agent_location)\n        if state is None:\n            return None\n        return self.agent.get_state_value(state)\n\n    def __get_agent_state(\n        self, new_agent_location: Tuple[int, int]\n    ) -&gt; Union[int, None]:\n        state_to_id = self.state_pool.state_to_id\n        base_entities = self.entities\n\n        best_state: Union[int, None] = None\n        best_energy = 0\n\n        for state, state_id in state_to_id.items():\n            if state.agent_location != new_agent_location:\n                continue\n            if state.entities != base_entities:\n                continue\n            if state.agent_energy &gt; best_energy:\n                best_energy = state.agent_energy\n                best_state = state_id\n        return best_state\n</code></pre>"},{"location":"reference/model/learning_system/value_range_normaliser/normaliser/#src.model.learning_system.value_range_normaliser.normaliser.StateValueNormaliser.__init__","title":"<code>__init__(agent, state_pool, entities, value_range)</code>","text":"<p>Initialise the normaliser.</p> <p>this class will normalise the values between 0 and 1.</p> <p>Parameters:</p> Name Type Description Default <code>agent</code> <code>BaseAgent</code> <p>the agent to decide the value</p> required <code>state_pool</code> <code>StatePool</code> <p>a state pool with all possible states.</p> required <code>entities</code> <code>entities_type</code> <p>the entity space to consider.</p> required <code>value_range</code> <code>ValueRange</code> <p>the range of possible values for this agent and dynamics</p> required Source code in <code>src/model/learning_system/value_range_normaliser/normaliser.py</code> <pre><code>def __init__(\n    self,\n    agent: BaseAgent,\n    state_pool: StatePool,\n    entities: entities_type,\n    value_range: ValueRange,\n) -&gt; None:\n    \"\"\"Initialise the normaliser.\n\n    this class will normalise the values between 0 and 1.\n\n\n    Args:\n        agent (BaseAgent): the agent to decide the value\n        state_pool (StatePool): a state pool with all possible states.\n        entities (entities_type): the entity space to consider.\n        value_range (ValueRange): the range of possible values for this\n            agent and dynamics\n    \"\"\"\n    self.agent = agent\n    self.state_pool = state_pool\n    self.entities = entities\n    self.value_range = value_range\n    self.state_value_cache: Dict[Tuple[int, int], float] = {}\n    self.action_value_cache: Dict[action_value_tuple, float] = {}\n</code></pre>"},{"location":"reference/model/learning_system/value_range_normaliser/normaliser/#src.model.learning_system.value_range_normaliser.normaliser.StateValueNormaliser.get_state_action_value_normalised","title":"<code>get_state_action_value_normalised(new_agent_location, action)</code>","text":"<p>Get the normalised value of a given agent location and action.</p> <p>Parameters:</p> Name Type Description Default <code>new_agent_location</code> <code>Tuple[int, int]</code> <p>the new agents location</p> required <code>action</code> <code>Action</code> <p>the action to perform</p> required <p>Returns:</p> Type Description <code>Union[float, None]</code> <p>Union[float, None]: the value if one can be found.</p> Source code in <code>src/model/learning_system/value_range_normaliser/normaliser.py</code> <pre><code>def get_state_action_value_normalised(\n    self,\n    new_agent_location: Tuple[int, int],\n    action: Action,\n) -&gt; Union[float, None]:\n    \"\"\"Get the normalised value of a given agent location and action.\n\n    Args:\n        new_agent_location (Tuple[int, int]): the new agents location\n        action (Action): the action to perform\n\n    Returns:\n        Union[float, None]: the value if one can be found.\n    \"\"\"\n    cache_key = (new_agent_location, action)\n    cached_value = self.action_value_cache.get(cache_key, None)\n    if cached_value is not None:\n        return cached_value\n\n    state = self.__get_agent_state(new_agent_location)\n    if state is None:\n        return None\n    action_value = self.value_range.rescale_value(\n        ValueType.state_action_value,\n        self.agent.get_state_action_value(state, action),\n    )\n    self.action_value_cache[cache_key] = action_value\n    return action_value\n</code></pre>"},{"location":"reference/model/learning_system/value_range_normaliser/normaliser/#src.model.learning_system.value_range_normaliser.normaliser.StateValueNormaliser.get_state_action_value_raw","title":"<code>get_state_action_value_raw(new_agent_location, action)</code>","text":"<p>Get the un-normalised value of a given agent location and action.</p> <p>Parameters:</p> Name Type Description Default <code>new_agent_location</code> <code>Tuple[int, int]</code> <p>the location the agent is in</p> required <code>action</code> <code>Action</code> <p>the action to perform.</p> required <p>Returns:</p> Type Description <code>Optional[float]</code> <p>Optional[float]: the raw value of this action state combination</p> <code>Optional[float]</code> <p>according to the agent.</p> Source code in <code>src/model/learning_system/value_range_normaliser/normaliser.py</code> <pre><code>def get_state_action_value_raw(\n    self, new_agent_location: Tuple[int, int], action: Action\n) -&gt; Optional[float]:\n    \"\"\"Get the un-normalised value of a given agent location and action.\n\n    Args:\n        new_agent_location (Tuple[int, int]): the location the agent is in\n        action (Action): the action to perform.\n\n    Returns:\n        Optional[float]: the raw value of this action state combination\n        according to the agent.\n    \"\"\"\n    state = self.__get_agent_state(new_agent_location)\n    if state is None:\n        return None\n    return self.agent.get_state_action_value(state, action)\n</code></pre>"},{"location":"reference/model/learning_system/value_range_normaliser/normaliser/#src.model.learning_system.value_range_normaliser.normaliser.StateValueNormaliser.get_state_value_normalised","title":"<code>get_state_value_normalised(new_agent_location)</code>","text":"<p>Get the normalised value of the agent being in this location.</p> <p>Parameters:</p> Name Type Description Default <code>new_agent_location</code> <code>Tuple[int, int]</code> <p>the new agents location</p> required <p>Returns:</p> Type Description <code>Union[float, None]</code> <p>Union[float, None]: the value if one can be found.</p> Source code in <code>src/model/learning_system/value_range_normaliser/normaliser.py</code> <pre><code>def get_state_value_normalised(\n    self, new_agent_location: Tuple[int, int]\n) -&gt; Union[float, None]:\n    \"\"\"Get the normalised value of the agent being in this location.\n\n    Args:\n        new_agent_location (Tuple[int, int]): the new agents location\n\n    Returns:\n        Union[float, None]: the value if one can be found.\n    \"\"\"\n    cached_value = self.state_value_cache.get(new_agent_location, None)\n    if cached_value is not None:\n        return cached_value\n\n    state = self.__get_agent_state(new_agent_location)\n    if state is None:\n        return None\n\n    state_value = self.value_range.rescale_value(\n        ValueType.state_value,\n        self.agent.get_state_value(state),\n    )\n    self.state_value_cache[new_agent_location] = state_value\n\n    return state_value\n</code></pre>"},{"location":"reference/model/learning_system/value_range_normaliser/normaliser/#src.model.learning_system.value_range_normaliser.normaliser.StateValueNormaliser.get_state_value_raw","title":"<code>get_state_value_raw(new_agent_location)</code>","text":"<p>Get the un-normalised value of the agent being in this location.</p> <p>Parameters:</p> Name Type Description Default <code>new_agent_location</code> <code>Tuple[int, int]</code> <p>description</p> required <p>Returns:</p> Type Description <code>Optional[float]</code> <p>Optional[float]: the the raw value of the agent being in this</p> <code>Optional[float]</code> <p>location according to the agent.</p> Source code in <code>src/model/learning_system/value_range_normaliser/normaliser.py</code> <pre><code>def get_state_value_raw(\n    self, new_agent_location: Tuple[int, int]\n) -&gt; Optional[float]:\n    \"\"\"Get the un-normalised value of the agent being in this location.\n\n    Args:\n        new_agent_location (Tuple[int, int]): _description_\n\n    Returns:\n        Optional[float]: the the raw value of the agent being in this\n        location according to the agent.\n    \"\"\"\n    state = self.__get_agent_state(new_agent_location)\n    if state is None:\n        return None\n    return self.agent.get_state_value(state)\n</code></pre>"},{"location":"reference/model/learning_system/value_range_normaliser/normaliser_factory/","title":"Normaliser Factory","text":""},{"location":"reference/model/learning_system/value_range_normaliser/normaliser_factory/#src.model.learning_system.value_range_normaliser.normaliser_factory.NormaliserFactory","title":"<code>NormaliserFactory</code>","text":"<p>             Bases: <code>object</code></p> <p>Factory class for creating value normalisers.</p> Source code in <code>src/model/learning_system/value_range_normaliser/normaliser_factory.py</code> <pre><code>class NormaliserFactory(object):\n    \"\"\"Factory class for creating value normalisers.\"\"\"\n\n    def __init__(\n        self, agent: BaseAgent, dynamics: BaseDynamics, enable_cache: bool\n    ) -&gt; None:\n        \"\"\"Initialise the normaliser factory.\n\n        This factory creates normalisers and caches equivalent ones to avoid\n        re-computation\n\n        Args:\n            agent (BaseAgent): the agent to generate normalisers for\n            dynamics (BaseDynamics): the dynamics to generate normalisers for\n            enable_cache: weather the cache can be enabled (if the value table\n                changes like for q-learning then caching must be disabled)\n        \"\"\"\n        self.agent = agent\n        self.dynamics = dynamics\n        self.has_generated_all_states: bool = False\n        self.cache: Dict[entities_type, StateValueNormaliser] = {}\n        self.value_range: Optional[ValueRange] = None\n        self.enable_cache = enable_cache\n\n    def create_normaliser(self, base_state: int) -&gt; StateValueNormaliser:\n        \"\"\"Get the appropriate state normaliser for the given base state.\n\n        Args:\n            base_state (int): the state the defines the possible entities that\n                the normaliser should consider.\n\n        Returns:\n            StateValueNormaliser: _description_\n        \"\"\"\n        entities = self.dynamics.state_pool.get_state_from_id(\n            base_state\n        ).entities\n        cached_normaliser = self.cache.get(entities, None)\n        if cached_normaliser is not None and self.enable_cache:\n            return cached_normaliser\n\n        normaliser = StateValueNormaliser(\n            self.agent,\n            self.__get_state_pool(),\n            entities,\n            self.__get_value_range(),\n        )\n        self.cache[entities] = normaliser\n        return normaliser\n\n    def __get_state_pool(self) -&gt; StatePool:\n        \"\"\"Get a fully populated state pool.\n\n        Returns:\n            StatePool: the pool of all possible reachable states\n        \"\"\"\n        if self.has_generated_all_states:\n            return self.dynamics.state_pool\n        # use the dynamics distribution code to ensure all states are visited\n        dd = DynamicsDistribution(100, self.dynamics)\n        dd.compile()\n        self.has_generated_all_states = True\n        return self.dynamics.state_pool\n\n    def __get_value_range(self) -&gt; ValueRange:\n        \"\"\"Get the value range for this given dynamics and agent.\n\n        Returns:\n            ValueRange: the range of values to provide a consistent scale\n        \"\"\"\n        if self.value_range is not None and self.enable_cache:\n            return self.value_range\n\n        self.value_range = ValueRange(self.__get_state_pool(), self.agent)\n        return self.value_range\n</code></pre>"},{"location":"reference/model/learning_system/value_range_normaliser/normaliser_factory/#src.model.learning_system.value_range_normaliser.normaliser_factory.NormaliserFactory.__get_state_pool","title":"<code>__get_state_pool()</code>","text":"<p>Get a fully populated state pool.</p> <p>Returns:</p> Name Type Description <code>StatePool</code> <code>StatePool</code> <p>the pool of all possible reachable states</p> Source code in <code>src/model/learning_system/value_range_normaliser/normaliser_factory.py</code> <pre><code>def __get_state_pool(self) -&gt; StatePool:\n    \"\"\"Get a fully populated state pool.\n\n    Returns:\n        StatePool: the pool of all possible reachable states\n    \"\"\"\n    if self.has_generated_all_states:\n        return self.dynamics.state_pool\n    # use the dynamics distribution code to ensure all states are visited\n    dd = DynamicsDistribution(100, self.dynamics)\n    dd.compile()\n    self.has_generated_all_states = True\n    return self.dynamics.state_pool\n</code></pre>"},{"location":"reference/model/learning_system/value_range_normaliser/normaliser_factory/#src.model.learning_system.value_range_normaliser.normaliser_factory.NormaliserFactory.__get_value_range","title":"<code>__get_value_range()</code>","text":"<p>Get the value range for this given dynamics and agent.</p> <p>Returns:</p> Name Type Description <code>ValueRange</code> <code>ValueRange</code> <p>the range of values to provide a consistent scale</p> Source code in <code>src/model/learning_system/value_range_normaliser/normaliser_factory.py</code> <pre><code>def __get_value_range(self) -&gt; ValueRange:\n    \"\"\"Get the value range for this given dynamics and agent.\n\n    Returns:\n        ValueRange: the range of values to provide a consistent scale\n    \"\"\"\n    if self.value_range is not None and self.enable_cache:\n        return self.value_range\n\n    self.value_range = ValueRange(self.__get_state_pool(), self.agent)\n    return self.value_range\n</code></pre>"},{"location":"reference/model/learning_system/value_range_normaliser/normaliser_factory/#src.model.learning_system.value_range_normaliser.normaliser_factory.NormaliserFactory.__init__","title":"<code>__init__(agent, dynamics, enable_cache)</code>","text":"<p>Initialise the normaliser factory.</p> <p>This factory creates normalisers and caches equivalent ones to avoid re-computation</p> <p>Parameters:</p> Name Type Description Default <code>agent</code> <code>BaseAgent</code> <p>the agent to generate normalisers for</p> required <code>dynamics</code> <code>BaseDynamics</code> <p>the dynamics to generate normalisers for</p> required <code>enable_cache</code> <code>bool</code> <p>weather the cache can be enabled (if the value table changes like for q-learning then caching must be disabled)</p> required Source code in <code>src/model/learning_system/value_range_normaliser/normaliser_factory.py</code> <pre><code>def __init__(\n    self, agent: BaseAgent, dynamics: BaseDynamics, enable_cache: bool\n) -&gt; None:\n    \"\"\"Initialise the normaliser factory.\n\n    This factory creates normalisers and caches equivalent ones to avoid\n    re-computation\n\n    Args:\n        agent (BaseAgent): the agent to generate normalisers for\n        dynamics (BaseDynamics): the dynamics to generate normalisers for\n        enable_cache: weather the cache can be enabled (if the value table\n            changes like for q-learning then caching must be disabled)\n    \"\"\"\n    self.agent = agent\n    self.dynamics = dynamics\n    self.has_generated_all_states: bool = False\n    self.cache: Dict[entities_type, StateValueNormaliser] = {}\n    self.value_range: Optional[ValueRange] = None\n    self.enable_cache = enable_cache\n</code></pre>"},{"location":"reference/model/learning_system/value_range_normaliser/normaliser_factory/#src.model.learning_system.value_range_normaliser.normaliser_factory.NormaliserFactory.create_normaliser","title":"<code>create_normaliser(base_state)</code>","text":"<p>Get the appropriate state normaliser for the given base state.</p> <p>Parameters:</p> Name Type Description Default <code>base_state</code> <code>int</code> <p>the state the defines the possible entities that the normaliser should consider.</p> required <p>Returns:</p> Name Type Description <code>StateValueNormaliser</code> <code>StateValueNormaliser</code> <p>description</p> Source code in <code>src/model/learning_system/value_range_normaliser/normaliser_factory.py</code> <pre><code>def create_normaliser(self, base_state: int) -&gt; StateValueNormaliser:\n    \"\"\"Get the appropriate state normaliser for the given base state.\n\n    Args:\n        base_state (int): the state the defines the possible entities that\n            the normaliser should consider.\n\n    Returns:\n        StateValueNormaliser: _description_\n    \"\"\"\n    entities = self.dynamics.state_pool.get_state_from_id(\n        base_state\n    ).entities\n    cached_normaliser = self.cache.get(entities, None)\n    if cached_normaliser is not None and self.enable_cache:\n        return cached_normaliser\n\n    normaliser = StateValueNormaliser(\n        self.agent,\n        self.__get_state_pool(),\n        entities,\n        self.__get_value_range(),\n    )\n    self.cache[entities] = normaliser\n    return normaliser\n</code></pre>"},{"location":"reference/model/learning_system/value_range_normaliser/value_range/","title":"Value Range","text":""},{"location":"reference/model/learning_system/value_range_normaliser/value_range/#src.model.learning_system.value_range_normaliser.value_range.ValueRange","title":"<code>ValueRange</code>","text":"<p>             Bases: <code>object</code></p> <p>Maintains the range of all possible values for mapping from 0 to 1.</p> Source code in <code>src/model/learning_system/value_range_normaliser/value_range.py</code> <pre><code>class ValueRange(object):\n    \"\"\"Maintains the range of all possible values for mapping from 0 to 1.\"\"\"\n\n    def __init__(self, state_pool: StatePool, agent: BaseAgent) -&gt; None:\n        \"\"\"Initialise a value range.\n\n        Args:\n            state_pool (StatePool): the populated set of all possible states to\n                find the range of values.\n            agent (BaseAgent): the agent to decide on values\n\n        \"\"\"\n        self.state_pool = state_pool\n        self.agent = agent\n\n        self.action_range: Optional[Tuple[float, float]] = None\n\n        self.state_range: Optional[Tuple[float, float]] = None\n\n    def rescale_value(\n        self, value_type: ValueType, absolute_value: float\n    ) -&gt; float:\n        \"\"\"Rescale a value from a value type into the range 0-1.\n\n        the minimum value of this type would get a value of 0 and the maximum\n        value of this type would get a 1.\n\n        Args:\n            value_type (ValueType): the type of value received\n            absolute_value (float): the raw value before rescaling\n\n        Returns:\n            float: _description_\n        \"\"\"\n        min_value, max_value = self.__get_value_range(value_type)\n        return (absolute_value - min_value) / (max_value - min_value)\n\n    def __get_value_range(self, value_type: ValueType) -&gt; Tuple[float, float]:\n        match value_type:\n            case ValueType.state_value:\n                return self.__get_state_value_range()\n            case ValueType.state_action_value:\n                return self.__get_state_action_value_range()\n\n    def __get_state_value_range(self) -&gt; Tuple[float, float]:\n        if self.state_range is not None:\n            return self.state_range\n        maximum_state_value = float(\"-inf\")\n        minimum_state_value = float(\"inf\")\n        for state in self.state_pool.state_to_id.values():\n            state_value = self.agent.get_state_value(state)\n            maximum_state_value = max(maximum_state_value, state_value)\n            minimum_state_value = min(minimum_state_value, state_value)\n\n        self.state_range = (minimum_state_value, maximum_state_value)\n        return self.state_range\n\n    def __get_state_action_value_range(self) -&gt; Tuple[float, float]:\n        if self.action_range is not None:\n            return self.action_range\n\n        maximum_action_value = float(\"-inf\")\n        minimum_action_value = float(\"inf\")\n\n        for state in self.state_pool.state_to_id.values():\n            for action in Action:\n                action_value = self.agent.get_state_action_value(state, action)\n                maximum_action_value = max(maximum_action_value, action_value)\n                minimum_action_value = min(minimum_action_value, action_value)\n\n        self.action_range = (minimum_action_value, maximum_action_value)\n        return self.action_range\n</code></pre>"},{"location":"reference/model/learning_system/value_range_normaliser/value_range/#src.model.learning_system.value_range_normaliser.value_range.ValueRange.__init__","title":"<code>__init__(state_pool, agent)</code>","text":"<p>Initialise a value range.</p> <p>Parameters:</p> Name Type Description Default <code>state_pool</code> <code>StatePool</code> <p>the populated set of all possible states to find the range of values.</p> required <code>agent</code> <code>BaseAgent</code> <p>the agent to decide on values</p> required Source code in <code>src/model/learning_system/value_range_normaliser/value_range.py</code> <pre><code>def __init__(self, state_pool: StatePool, agent: BaseAgent) -&gt; None:\n    \"\"\"Initialise a value range.\n\n    Args:\n        state_pool (StatePool): the populated set of all possible states to\n            find the range of values.\n        agent (BaseAgent): the agent to decide on values\n\n    \"\"\"\n    self.state_pool = state_pool\n    self.agent = agent\n\n    self.action_range: Optional[Tuple[float, float]] = None\n\n    self.state_range: Optional[Tuple[float, float]] = None\n</code></pre>"},{"location":"reference/model/learning_system/value_range_normaliser/value_range/#src.model.learning_system.value_range_normaliser.value_range.ValueRange.rescale_value","title":"<code>rescale_value(value_type, absolute_value)</code>","text":"<p>Rescale a value from a value type into the range 0-1.</p> <p>the minimum value of this type would get a value of 0 and the maximum value of this type would get a 1.</p> <p>Parameters:</p> Name Type Description Default <code>value_type</code> <code>ValueType</code> <p>the type of value received</p> required <code>absolute_value</code> <code>float</code> <p>the raw value before rescaling</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>description</p> Source code in <code>src/model/learning_system/value_range_normaliser/value_range.py</code> <pre><code>def rescale_value(\n    self, value_type: ValueType, absolute_value: float\n) -&gt; float:\n    \"\"\"Rescale a value from a value type into the range 0-1.\n\n    the minimum value of this type would get a value of 0 and the maximum\n    value of this type would get a 1.\n\n    Args:\n        value_type (ValueType): the type of value received\n        absolute_value (float): the raw value before rescaling\n\n    Returns:\n        float: _description_\n    \"\"\"\n    min_value, max_value = self.__get_value_range(value_type)\n    return (absolute_value - min_value) / (max_value - min_value)\n</code></pre>"},{"location":"reference/model/learning_system/value_range_normaliser/value_range/#src.model.learning_system.value_range_normaliser.value_range.ValueType","title":"<code>ValueType</code>","text":"<p>             Bases: <code>Enum</code></p> <p>Enumerates the possible types of values.</p> Source code in <code>src/model/learning_system/value_range_normaliser/value_range.py</code> <pre><code>class ValueType(Enum):\n    \"\"\"Enumerates the possible types of values.\"\"\"\n\n    state_value = 0\n    state_action_value = 1\n</code></pre>"},{"location":"reference/model/state/","title":"State","text":"<p>This Package contains functionality for representing each state.</p>"},{"location":"reference/model/state/cell_entities/","title":"Cell Entities","text":""},{"location":"reference/model/state/cell_entities/#src.model.state.cell_entities.CellEntity","title":"<code>CellEntity</code>","text":"<p>             Bases: <code>Enum</code></p> <p>This class enumerates all the possible entities that may be in a cell.</p> Source code in <code>src/model/state/cell_entities.py</code> <pre><code>class CellEntity(Enum):\n    \"\"\"This class enumerates all the possible entities that may be in a cell.\"\"\"\n\n    agent = 1\n    goal = 2\n    empty = 3\n    blocked = 4\n</code></pre>"},{"location":"reference/model/state/state_builder/","title":"State Builder","text":""},{"location":"reference/model/state/state_builder/#src.model.state.state_builder.StateBuilder","title":"<code>StateBuilder</code>","text":"<p>             Bases: <code>object</code></p> <p>State builder simplifies creating states.</p> <p>Since states must be immutable the state builder lets you apply multiple changes without creating the intermediary states.</p> Source code in <code>src/model/state/state_builder.py</code> <pre><code>class StateBuilder(object):\n    \"\"\"State builder simplifies creating states.\n\n    Since states must be immutable the state builder lets you apply multiple\n    changes without creating the intermediary states.\n    \"\"\"\n\n    def __init__(\n        self,\n        previous_state: Optional[StateInstance] = None,\n    ) -&gt; None:\n        \"\"\"Initialise the state builder.\n\n        Args:\n            previous_state (Optional[StateInstance]): the state to build from,\n                if not specified an arbitrary state is chosen.\n        \"\"\"\n        if previous_state is None:\n            previous_state = StateInstance.get_blank_state()\n\n        self.entities = previous_state.entities\n        self.agent_location = previous_state.agent_location\n        self.agent_energy = previous_state.agent_energy\n\n    def set_agent_location(self, pos: tuple[int, int]) -&gt; Self:\n        \"\"\"Set the agent's location.\n\n        Args:\n            pos (tuple[int, int]): the agent's new location\n\n        Returns:\n            Self: the builder to continue chaining methods\n        \"\"\"\n        self.agent_location = pos\n        return self\n\n    def set_energy(self, energy: int) -&gt; Self:\n        \"\"\"Set the agent's energy.\n\n        Args:\n            energy (int): the agent's new energy\n\n        Returns:\n            Self: the builder to continue chaining methods\n        \"\"\"\n        self.agent_energy = energy\n        return self\n\n    def decrement_energy(self, amount=1) -&gt; Self:\n        \"\"\"Decrement the energy by an amount.\n\n        Args:\n            amount (int): the amount to reduce the energy by. Defaults to 1.\n\n        Returns:\n            Self: the builder to continue chaining methods\n        \"\"\"\n        self.agent_energy -= amount\n        if self.agent_energy &lt; 0:\n            self.agent_energy = 0\n        return self\n\n    def set_entity(self, cell: tuple[int, int], entity: CellEntity) -&gt; Self:\n        \"\"\"Set the entity that is in a cell.\n\n        Args:\n            cell (tuple[int, int]): the cell where to update the entity.\n            entity (CellEntity): the new entity at this location.\n\n        Returns:\n            Self: the builder to continue chaining methods\n        \"\"\"\n        self.entities = self.entities.set(cell, entity)\n        return self\n\n    def remove_entity(self, cell: tuple[int, int]) -&gt; Self:\n        \"\"\"Remove the entity that is in a cell.\n\n        Args:\n            cell (tuple[int, int]): the cell where to update an entity.\n\n        Returns:\n            Self: the builder to continue chaining methods\n        \"\"\"\n        self.entities = self.entities.delete(cell)\n        return self\n\n    def build(self) -&gt; StateInstance:\n        \"\"\"Compile the changes into the new state.\n\n        Returns:\n            StateInstance: the new state instance after the changes have been\n            applied.\n        \"\"\"\n        return StateInstance(\n            self.agent_location, self.entities, self.agent_energy\n        )\n</code></pre>"},{"location":"reference/model/state/state_builder/#src.model.state.state_builder.StateBuilder.__init__","title":"<code>__init__(previous_state=None)</code>","text":"<p>Initialise the state builder.</p> <p>Parameters:</p> Name Type Description Default <code>previous_state</code> <code>Optional[StateInstance]</code> <p>the state to build from, if not specified an arbitrary state is chosen.</p> <code>None</code> Source code in <code>src/model/state/state_builder.py</code> <pre><code>def __init__(\n    self,\n    previous_state: Optional[StateInstance] = None,\n) -&gt; None:\n    \"\"\"Initialise the state builder.\n\n    Args:\n        previous_state (Optional[StateInstance]): the state to build from,\n            if not specified an arbitrary state is chosen.\n    \"\"\"\n    if previous_state is None:\n        previous_state = StateInstance.get_blank_state()\n\n    self.entities = previous_state.entities\n    self.agent_location = previous_state.agent_location\n    self.agent_energy = previous_state.agent_energy\n</code></pre>"},{"location":"reference/model/state/state_builder/#src.model.state.state_builder.StateBuilder.build","title":"<code>build()</code>","text":"<p>Compile the changes into the new state.</p> <p>Returns:</p> Name Type Description <code>StateInstance</code> <code>StateInstance</code> <p>the new state instance after the changes have been</p> <code>StateInstance</code> <p>applied.</p> Source code in <code>src/model/state/state_builder.py</code> <pre><code>def build(self) -&gt; StateInstance:\n    \"\"\"Compile the changes into the new state.\n\n    Returns:\n        StateInstance: the new state instance after the changes have been\n        applied.\n    \"\"\"\n    return StateInstance(\n        self.agent_location, self.entities, self.agent_energy\n    )\n</code></pre>"},{"location":"reference/model/state/state_builder/#src.model.state.state_builder.StateBuilder.decrement_energy","title":"<code>decrement_energy(amount=1)</code>","text":"<p>Decrement the energy by an amount.</p> <p>Parameters:</p> Name Type Description Default <code>amount</code> <code>int</code> <p>the amount to reduce the energy by. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>the builder to continue chaining methods</p> Source code in <code>src/model/state/state_builder.py</code> <pre><code>def decrement_energy(self, amount=1) -&gt; Self:\n    \"\"\"Decrement the energy by an amount.\n\n    Args:\n        amount (int): the amount to reduce the energy by. Defaults to 1.\n\n    Returns:\n        Self: the builder to continue chaining methods\n    \"\"\"\n    self.agent_energy -= amount\n    if self.agent_energy &lt; 0:\n        self.agent_energy = 0\n    return self\n</code></pre>"},{"location":"reference/model/state/state_builder/#src.model.state.state_builder.StateBuilder.remove_entity","title":"<code>remove_entity(cell)</code>","text":"<p>Remove the entity that is in a cell.</p> <p>Parameters:</p> Name Type Description Default <code>cell</code> <code>tuple[int, int]</code> <p>the cell where to update an entity.</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>the builder to continue chaining methods</p> Source code in <code>src/model/state/state_builder.py</code> <pre><code>def remove_entity(self, cell: tuple[int, int]) -&gt; Self:\n    \"\"\"Remove the entity that is in a cell.\n\n    Args:\n        cell (tuple[int, int]): the cell where to update an entity.\n\n    Returns:\n        Self: the builder to continue chaining methods\n    \"\"\"\n    self.entities = self.entities.delete(cell)\n    return self\n</code></pre>"},{"location":"reference/model/state/state_builder/#src.model.state.state_builder.StateBuilder.set_agent_location","title":"<code>set_agent_location(pos)</code>","text":"<p>Set the agent's location.</p> <p>Parameters:</p> Name Type Description Default <code>pos</code> <code>tuple[int, int]</code> <p>the agent's new location</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>the builder to continue chaining methods</p> Source code in <code>src/model/state/state_builder.py</code> <pre><code>def set_agent_location(self, pos: tuple[int, int]) -&gt; Self:\n    \"\"\"Set the agent's location.\n\n    Args:\n        pos (tuple[int, int]): the agent's new location\n\n    Returns:\n        Self: the builder to continue chaining methods\n    \"\"\"\n    self.agent_location = pos\n    return self\n</code></pre>"},{"location":"reference/model/state/state_builder/#src.model.state.state_builder.StateBuilder.set_energy","title":"<code>set_energy(energy)</code>","text":"<p>Set the agent's energy.</p> <p>Parameters:</p> Name Type Description Default <code>energy</code> <code>int</code> <p>the agent's new energy</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>the builder to continue chaining methods</p> Source code in <code>src/model/state/state_builder.py</code> <pre><code>def set_energy(self, energy: int) -&gt; Self:\n    \"\"\"Set the agent's energy.\n\n    Args:\n        energy (int): the agent's new energy\n\n    Returns:\n        Self: the builder to continue chaining methods\n    \"\"\"\n    self.agent_energy = energy\n    return self\n</code></pre>"},{"location":"reference/model/state/state_builder/#src.model.state.state_builder.StateBuilder.set_entity","title":"<code>set_entity(cell, entity)</code>","text":"<p>Set the entity that is in a cell.</p> <p>Parameters:</p> Name Type Description Default <code>cell</code> <code>tuple[int, int]</code> <p>the cell where to update the entity.</p> required <code>entity</code> <code>CellEntity</code> <p>the new entity at this location.</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>the builder to continue chaining methods</p> Source code in <code>src/model/state/state_builder.py</code> <pre><code>def set_entity(self, cell: tuple[int, int], entity: CellEntity) -&gt; Self:\n    \"\"\"Set the entity that is in a cell.\n\n    Args:\n        cell (tuple[int, int]): the cell where to update the entity.\n        entity (CellEntity): the new entity at this location.\n\n    Returns:\n        Self: the builder to continue chaining methods\n    \"\"\"\n    self.entities = self.entities.set(cell, entity)\n    return self\n</code></pre>"},{"location":"reference/model/state/state_instance/","title":"State Instance","text":""},{"location":"reference/model/state/state_instance/#src.model.state.state_instance.StateInstance","title":"<code>StateInstance</code>","text":"<p>             Bases: <code>object</code></p> <p>This class represents a possible state in the grid world of this MDP.</p> Source code in <code>src/model/state/state_instance.py</code> <pre><code>class StateInstance(object):\n    \"\"\"This class represents a possible state in the grid world of this MDP.\"\"\"\n\n    def __init__(\n        self,\n        agent_location: Tuple[int, int],\n        entities: entities_type,\n        agent_energy: int,\n    ) -&gt; None:\n        \"\"\"Initialise a new state.\n\n        each state must be immutable. therefore to achieve a state with\n        different properties a new state must be created, this is done by the\n        dynamics.\n\n        Args:\n            agent_location (tuple[int, int]): _description_\n            entities (entities_type): _description_\n            agent_energy (int): _description_\n        \"\"\"\n        self.agent_location = agent_location\n        self.entities = entities\n        self.agent_energy = agent_energy\n\n    @classmethod\n    def get_blank_state(cls) -&gt; Self:\n        \"\"\"Create a blank state.\n\n        Returns:\n            Self: a state with no particular features.\n        \"\"\"\n        return cls((0, 0), Map(), 10)\n\n    def __hash__(self) -&gt; int:\n        \"\"\"Generate a hash value for this state.\n\n        Helpful in speeding up indexing operations.\n\n        Returns:\n            int: the hash of this state\n        \"\"\"\n        return hash((self.agent_location, self.entities, self.agent_energy))\n\n    def __eq__(self, other: object) -&gt; bool:\n        \"\"\"Test for equality between two states.\n\n        Args:\n            other (object): the other state to compare to\n\n        Returns:\n            bool: true if the two states can be considered equal.\n        \"\"\"\n        if not isinstance(other, StateInstance):\n            return False\n        return (\n            self.agent_location == other.agent_location\n            and self.entities == other.entities\n            and self.agent_energy == other.agent_energy\n        )\n</code></pre>"},{"location":"reference/model/state/state_instance/#src.model.state.state_instance.StateInstance.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Test for equality between two states.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>object</code> <p>the other state to compare to</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>true if the two states can be considered equal.</p> Source code in <code>src/model/state/state_instance.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n    \"\"\"Test for equality between two states.\n\n    Args:\n        other (object): the other state to compare to\n\n    Returns:\n        bool: true if the two states can be considered equal.\n    \"\"\"\n    if not isinstance(other, StateInstance):\n        return False\n    return (\n        self.agent_location == other.agent_location\n        and self.entities == other.entities\n        and self.agent_energy == other.agent_energy\n    )\n</code></pre>"},{"location":"reference/model/state/state_instance/#src.model.state.state_instance.StateInstance.__hash__","title":"<code>__hash__()</code>","text":"<p>Generate a hash value for this state.</p> <p>Helpful in speeding up indexing operations.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>the hash of this state</p> Source code in <code>src/model/state/state_instance.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Generate a hash value for this state.\n\n    Helpful in speeding up indexing operations.\n\n    Returns:\n        int: the hash of this state\n    \"\"\"\n    return hash((self.agent_location, self.entities, self.agent_energy))\n</code></pre>"},{"location":"reference/model/state/state_instance/#src.model.state.state_instance.StateInstance.__init__","title":"<code>__init__(agent_location, entities, agent_energy)</code>","text":"<p>Initialise a new state.</p> <p>each state must be immutable. therefore to achieve a state with different properties a new state must be created, this is done by the dynamics.</p> <p>Parameters:</p> Name Type Description Default <code>agent_location</code> <code>tuple[int, int]</code> <p>description</p> required <code>entities</code> <code>entities_type</code> <p>description</p> required <code>agent_energy</code> <code>int</code> <p>description</p> required Source code in <code>src/model/state/state_instance.py</code> <pre><code>def __init__(\n    self,\n    agent_location: Tuple[int, int],\n    entities: entities_type,\n    agent_energy: int,\n) -&gt; None:\n    \"\"\"Initialise a new state.\n\n    each state must be immutable. therefore to achieve a state with\n    different properties a new state must be created, this is done by the\n    dynamics.\n\n    Args:\n        agent_location (tuple[int, int]): _description_\n        entities (entities_type): _description_\n        agent_energy (int): _description_\n    \"\"\"\n    self.agent_location = agent_location\n    self.entities = entities\n    self.agent_energy = agent_energy\n</code></pre>"},{"location":"reference/model/state/state_instance/#src.model.state.state_instance.StateInstance.get_blank_state","title":"<code>get_blank_state()</code>  <code>classmethod</code>","text":"<p>Create a blank state.</p> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>a state with no particular features.</p> Source code in <code>src/model/state/state_instance.py</code> <pre><code>@classmethod\ndef get_blank_state(cls) -&gt; Self:\n    \"\"\"Create a blank state.\n\n    Returns:\n        Self: a state with no particular features.\n    \"\"\"\n    return cls((0, 0), Map(), 10)\n</code></pre>"},{"location":"reference/model/state/state_pool/","title":"State Pool","text":""},{"location":"reference/model/state/state_pool/#src.model.state.state_pool.StatePool","title":"<code>StatePool</code>","text":"<p>             Bases: <code>object</code></p> <p>Class that manages the creation of states.</p> <p>This class avoids redundant states and allows for consistent identification</p> Source code in <code>src/model/state/state_pool.py</code> <pre><code>class StatePool(object):\n    \"\"\"Class that manages the creation of states.\n\n    This class avoids redundant states and allows for consistent identification\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialise a state pool.\"\"\"\n        self.id_to_state: Dict[int, StateInstance] = {}\n        self.state_to_id: Dict[StateInstance, int] = {}\n\n    def is_existing_state(self, state: StateInstance) -&gt; bool:\n        \"\"\"Determine weather a state has already been registered.\n\n        Args:\n            state (StateInstance): the state to check\n\n        Returns:\n            bool: true if this state already exists in this pool\n        \"\"\"\n        return state in self.state_to_id\n\n    def get_state_id(self, state: StateInstance) -&gt; int:\n        \"\"\"Get the numeric id for a given state.\n\n        If the state has already been registered with this pool then it should\n        return the existing key. else it should add this state to the pool and\n        return the new state.\n\n        Note, this id is not necessarily globally unique however it is unique in\n        this state pool\n\n        Args:\n            state (StateInstance): the state to get a unique id for\n\n        Returns:\n            int: the id for this state\n        \"\"\"\n        if self.is_existing_state(state):\n            return self.state_to_id[state]\n        new_id = len(self.state_to_id)\n        self.state_to_id[state] = new_id\n        self.id_to_state[new_id] = state\n        return new_id\n\n    def get_state_from_id(self, identifier: int) -&gt; StateInstance:\n        \"\"\"Get the state object corresponding to the given key in this pool.\n\n        Args:\n            identifier (int): the key of the state to get\n\n        Returns:\n            StateInstance: the state that is registered under this id\n        \"\"\"\n        return self.id_to_state[identifier]\n</code></pre>"},{"location":"reference/model/state/state_pool/#src.model.state.state_pool.StatePool.__init__","title":"<code>__init__()</code>","text":"<p>Initialise a state pool.</p> Source code in <code>src/model/state/state_pool.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialise a state pool.\"\"\"\n    self.id_to_state: Dict[int, StateInstance] = {}\n    self.state_to_id: Dict[StateInstance, int] = {}\n</code></pre>"},{"location":"reference/model/state/state_pool/#src.model.state.state_pool.StatePool.get_state_from_id","title":"<code>get_state_from_id(identifier)</code>","text":"<p>Get the state object corresponding to the given key in this pool.</p> <p>Parameters:</p> Name Type Description Default <code>identifier</code> <code>int</code> <p>the key of the state to get</p> required <p>Returns:</p> Name Type Description <code>StateInstance</code> <code>StateInstance</code> <p>the state that is registered under this id</p> Source code in <code>src/model/state/state_pool.py</code> <pre><code>def get_state_from_id(self, identifier: int) -&gt; StateInstance:\n    \"\"\"Get the state object corresponding to the given key in this pool.\n\n    Args:\n        identifier (int): the key of the state to get\n\n    Returns:\n        StateInstance: the state that is registered under this id\n    \"\"\"\n    return self.id_to_state[identifier]\n</code></pre>"},{"location":"reference/model/state/state_pool/#src.model.state.state_pool.StatePool.get_state_id","title":"<code>get_state_id(state)</code>","text":"<p>Get the numeric id for a given state.</p> <p>If the state has already been registered with this pool then it should return the existing key. else it should add this state to the pool and return the new state.</p> <p>Note, this id is not necessarily globally unique however it is unique in this state pool</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>StateInstance</code> <p>the state to get a unique id for</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>the id for this state</p> Source code in <code>src/model/state/state_pool.py</code> <pre><code>def get_state_id(self, state: StateInstance) -&gt; int:\n    \"\"\"Get the numeric id for a given state.\n\n    If the state has already been registered with this pool then it should\n    return the existing key. else it should add this state to the pool and\n    return the new state.\n\n    Note, this id is not necessarily globally unique however it is unique in\n    this state pool\n\n    Args:\n        state (StateInstance): the state to get a unique id for\n\n    Returns:\n        int: the id for this state\n    \"\"\"\n    if self.is_existing_state(state):\n        return self.state_to_id[state]\n    new_id = len(self.state_to_id)\n    self.state_to_id[state] = new_id\n    self.id_to_state[new_id] = state\n    return new_id\n</code></pre>"},{"location":"reference/model/state/state_pool/#src.model.state.state_pool.StatePool.is_existing_state","title":"<code>is_existing_state(state)</code>","text":"<p>Determine weather a state has already been registered.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>StateInstance</code> <p>the state to check</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>true if this state already exists in this pool</p> Source code in <code>src/model/state/state_pool.py</code> <pre><code>def is_existing_state(self, state: StateInstance) -&gt; bool:\n    \"\"\"Determine weather a state has already been registered.\n\n    Args:\n        state (StateInstance): the state to check\n\n    Returns:\n        bool: true if this state already exists in this pool\n    \"\"\"\n    return state in self.state_to_id\n</code></pre>"},{"location":"reference/view/","title":"View","text":"<p>The view package this package contains the code that defines the view.</p> <p>the view is the user interface with this program.</p>"},{"location":"reference/view/App/","title":"App","text":""},{"location":"reference/view/App/#src.view.App.ReinforcementLearningApp","title":"<code>ReinforcementLearningApp</code>","text":"<p>             Bases: <code>CTk</code></p> <p>Root of the application's view.</p> Source code in <code>src/view/App.py</code> <pre><code>class ReinforcementLearningApp(CTk):\n    \"\"\"Root of the application's view.\"\"\"\n\n    tab_definitions = {\n        \"Value Iteration\": AgentOptions.value_iteration_optimised,\n        \"Q Learning\": AgentOptions.q_learning,\n    }\n\n    def __init__(self, controller: LearningSystemControllerFactory):\n        \"\"\"Initialise the custom tkinter app.\n\n        Args:\n            controller (LearningSystemControllerFactory): The factory to make\n                system controllers.\n        \"\"\"\n        super().__init__()\n        self.controller = controller\n\n        self.title(\"RHUL MSci FYP - Reinforcement Learning App\")\n        self.setup_config()\n\n        self.grid_columnconfigure((0, 1), weight=1)\n        self.grid_rowconfigure(1, weight=1, minsize=0)\n\n        CTkLabel(self, text=\"Reinforcement Learning App\").grid(row=0, column=0)\n\n        self.tabs = CTkTabview(self)\n        self.tabs.grid(row=1, column=0, columnspan=2, sticky=\"nsew\")\n\n        self.__populate_tabs()\n\n    def setup_config(self):\n        \"\"\"Set app properties from config.\"\"\"\n        config = ConfigReader().gui()\n        set_appearance_mode(config.appearance_mode())\n        set_default_color_theme(config.color_theme())\n        self.geometry(config.initial_size())\n        deactivate_automatic_dpi_awareness()\n\n    def __populate_tabs(self):\n        \"\"\"Create the tabs for each agent.\"\"\"\n        for tab_name, agent in self.tab_definitions.items():\n            tab_frame = self.tabs.add(tab_name)\n            tab_frame.grid_columnconfigure(0, weight=1)\n            tab_frame.grid_rowconfigure(0, weight=1)\n            GridWorld(\n                tab_frame,\n                self.controller.create_controller(\n                    agent, DynamicsOptions.collection\n                ),\n            ).grid(row=0, column=0, sticky=\"nsew\")\n</code></pre>"},{"location":"reference/view/App/#src.view.App.ReinforcementLearningApp.__init__","title":"<code>__init__(controller)</code>","text":"<p>Initialise the custom tkinter app.</p> <p>Parameters:</p> Name Type Description Default <code>controller</code> <code>LearningSystemControllerFactory</code> <p>The factory to make system controllers.</p> required Source code in <code>src/view/App.py</code> <pre><code>def __init__(self, controller: LearningSystemControllerFactory):\n    \"\"\"Initialise the custom tkinter app.\n\n    Args:\n        controller (LearningSystemControllerFactory): The factory to make\n            system controllers.\n    \"\"\"\n    super().__init__()\n    self.controller = controller\n\n    self.title(\"RHUL MSci FYP - Reinforcement Learning App\")\n    self.setup_config()\n\n    self.grid_columnconfigure((0, 1), weight=1)\n    self.grid_rowconfigure(1, weight=1, minsize=0)\n\n    CTkLabel(self, text=\"Reinforcement Learning App\").grid(row=0, column=0)\n\n    self.tabs = CTkTabview(self)\n    self.tabs.grid(row=1, column=0, columnspan=2, sticky=\"nsew\")\n\n    self.__populate_tabs()\n</code></pre>"},{"location":"reference/view/App/#src.view.App.ReinforcementLearningApp.__populate_tabs","title":"<code>__populate_tabs()</code>","text":"<p>Create the tabs for each agent.</p> Source code in <code>src/view/App.py</code> <pre><code>def __populate_tabs(self):\n    \"\"\"Create the tabs for each agent.\"\"\"\n    for tab_name, agent in self.tab_definitions.items():\n        tab_frame = self.tabs.add(tab_name)\n        tab_frame.grid_columnconfigure(0, weight=1)\n        tab_frame.grid_rowconfigure(0, weight=1)\n        GridWorld(\n            tab_frame,\n            self.controller.create_controller(\n                agent, DynamicsOptions.collection\n            ),\n        ).grid(row=0, column=0, sticky=\"nsew\")\n</code></pre>"},{"location":"reference/view/App/#src.view.App.ReinforcementLearningApp.setup_config","title":"<code>setup_config()</code>","text":"<p>Set app properties from config.</p> Source code in <code>src/view/App.py</code> <pre><code>def setup_config(self):\n    \"\"\"Set app properties from config.\"\"\"\n    config = ConfigReader().gui()\n    set_appearance_mode(config.appearance_mode())\n    set_default_color_theme(config.color_theme())\n    self.geometry(config.initial_size())\n    deactivate_automatic_dpi_awareness()\n</code></pre>"},{"location":"reference/view/grid_world_view/","title":"Grid World View","text":"<p>This package allows you to display and interact with a grid world.</p>"},{"location":"reference/view/grid_world_view/grid_world/","title":"Grid World","text":""},{"location":"reference/view/grid_world_view/grid_world/#src.view.grid_world_view.grid_world.AutoSpeed","title":"<code>AutoSpeed</code>","text":"<p>             Bases: <code>Enum</code></p> <p>Enumerates all possible auto speeds.</p> Source code in <code>src/view/grid_world_view/grid_world.py</code> <pre><code>class AutoSpeed(Enum):\n    \"\"\"Enumerates all possible auto speeds.\"\"\"\n\n    manual = 0  # one step at a time\n    auto_local = 1  # step as fast as the states can be rendered\n    auto_full = 2  # full speed just show what states we can\n</code></pre>"},{"location":"reference/view/grid_world_view/grid_world/#src.view.grid_world_view.grid_world.GridWorld","title":"<code>GridWorld</code>","text":"<p>             Bases: <code>CTkFrame</code></p> <p>Show the grid world and allow the user to step through it.</p> Source code in <code>src/view/grid_world_view/grid_world.py</code> <pre><code>class GridWorld(CTkFrame):\n    \"\"\"Show the grid world and allow the user to step through it.\"\"\"\n\n    def __init__(self, master: Any, system: LearningSystemController):\n        \"\"\"Initialise the grid world view.\n\n        given a system this widget will show the grid world and allow the\n        user to step through it.\n\n        Args:\n            master (Any): the widget to draw this view into\n            system (LearningSystemController): the controller to send actions\n                to.\n        \"\"\"\n        super().__init__(master)\n\n        self.action_bridge = system.user_action_bridge\n        self.update_bridge = system.state_update_bridge\n        self.auto_mode = AutoSpeed.manual\n\n        columns = (0, 1, 2, 3)\n        self.grid_columnconfigure(columns, weight=1)\n        self.grid_rowconfigure(1, weight=1)\n\n        self._display = DisplayState(self)\n        self._display.grid(\n            row=1, column=0, columnspan=len(columns), sticky=\"nsew\"\n        )\n\n        self.__setup_controls()\n\n        # setup initial state\n        self.__start_update_loop()\n        self.action_bridge.submit_action(UserAction.fetch_current_state)\n\n    def next_button_pressed(self):\n        \"\"\"When the next button is presses step the state forward.\"\"\"\n        self.action_bridge.submit_action(UserAction.one_step)\n\n    def reset_button_pressed(self):\n        \"\"\"When the reset button is pressed. reset the state.\"\"\"\n        self.action_bridge.submit_action(UserAction.reset)\n\n    display_mode_options = {\n        \"default\": DisplayMode.default,\n        \"best action\": DisplayMode.best_action,\n        \"state value\": DisplayMode.state_value,\n        \"action value\": DisplayMode.action_value_global,\n        \"action value local\": DisplayMode.action_value_local,\n    }\n\n    def display_mode_changed(self, option: str):\n        \"\"\"When the display mode option menu is selected.\n\n        Args:\n            option (str): the mode selected\n        \"\"\"\n        display_mode = self.display_mode_options[option]\n        self.action_bridge.submit_action(\n            UserAction.set_display_mode, display_mode\n        )\n\n    auto_mode_options = {\n        \"manual\": AutoSpeed.manual,\n        \"auto\": AutoSpeed.auto_local,\n        \"fast\": AutoSpeed.auto_full,\n    }\n\n    def toggle_auto(self, key: str):\n        \"\"\"When the auto button has been pressed.\n\n        automatically press the next button\n\n        Args:\n            key (str): the mode selected.\n        \"\"\"\n        last_mode = self.auto_mode\n        self.auto_mode = self.auto_mode_options[key]\n        if last_mode is self.auto_mode:\n            return\n        self._next_button.configure(\n            state=\"normal\" if self.auto_mode is AutoSpeed.manual else \"disabled\"\n        )\n\n        if self.auto_mode is AutoSpeed.auto_full:\n            self.action_bridge.submit_action(UserAction.start_auto)\n        elif last_mode is AutoSpeed.auto_full:\n            self.action_bridge.submit_action(UserAction.stop_auto)\n\n    def __setup_controls(self):\n        self._display_mode = CTkOptionMenu(\n            self,\n            values=list(self.display_mode_options.keys()),\n            command=self.display_mode_changed,\n        )\n        default_display_mode = self.__invert_dict_search(\n            self.display_mode_options, DisplayMode.default\n        )\n        self._display_mode.set(default_display_mode)\n        self.__place_control(self._display_mode, 0)\n\n        self._reset_button = CTkButton(\n            self, text=\"reset\", command=self.reset_button_pressed\n        )\n        self.__place_control(self._reset_button, 1)\n\n        self._auto_progress = CTkSegmentedButton(\n            self,\n            values=list(self.auto_mode_options.keys()),\n            command=self.toggle_auto,\n        )\n        default_auto_mode = self.__invert_dict_search(\n            self.auto_mode_options, self.auto_mode\n        )\n        self._auto_progress.set(default_auto_mode)\n        self.__place_control(self._auto_progress, 2)\n\n        self._next_button = CTkButton(\n            self, text=\"next\", command=self.next_button_pressed\n        )\n        self.__place_control(self._next_button, 3)\n\n    def __place_control(self, control: Widget, column: int):\n        control.grid(row=2, column=column, pady=10)\n\n    def __invert_dict_search(self, dictionary: Dict, default: Any) -&gt; Any:\n        return {enum_value: key for key, enum_value in dictionary.items()}[\n            default\n        ]\n\n    def __start_update_loop(self):\n        self.after_idle(self.__update_loop)\n\n    def __update_loop(self):\n        self.update()  # force tkinter to complete all work before starting on\n        # new work\n        state = self.update_bridge.get_latest_state()\n        if state is not None:\n            self._display.set_state(state)\n\n        should_auto_next = self.auto_mode is AutoSpeed.auto_local\n        queue_is_available = not self.action_bridge.has_new_action()\n        ui_is_idle = state is None\n        if should_auto_next and queue_is_available and ui_is_idle:\n            self.next_button_pressed()\n\n        self.after(100, self.__update_loop)\n</code></pre>"},{"location":"reference/view/grid_world_view/grid_world/#src.view.grid_world_view.grid_world.GridWorld.__init__","title":"<code>__init__(master, system)</code>","text":"<p>Initialise the grid world view.</p> <p>given a system this widget will show the grid world and allow the user to step through it.</p> <p>Parameters:</p> Name Type Description Default <code>master</code> <code>Any</code> <p>the widget to draw this view into</p> required <code>system</code> <code>LearningSystemController</code> <p>the controller to send actions to.</p> required Source code in <code>src/view/grid_world_view/grid_world.py</code> <pre><code>def __init__(self, master: Any, system: LearningSystemController):\n    \"\"\"Initialise the grid world view.\n\n    given a system this widget will show the grid world and allow the\n    user to step through it.\n\n    Args:\n        master (Any): the widget to draw this view into\n        system (LearningSystemController): the controller to send actions\n            to.\n    \"\"\"\n    super().__init__(master)\n\n    self.action_bridge = system.user_action_bridge\n    self.update_bridge = system.state_update_bridge\n    self.auto_mode = AutoSpeed.manual\n\n    columns = (0, 1, 2, 3)\n    self.grid_columnconfigure(columns, weight=1)\n    self.grid_rowconfigure(1, weight=1)\n\n    self._display = DisplayState(self)\n    self._display.grid(\n        row=1, column=0, columnspan=len(columns), sticky=\"nsew\"\n    )\n\n    self.__setup_controls()\n\n    # setup initial state\n    self.__start_update_loop()\n    self.action_bridge.submit_action(UserAction.fetch_current_state)\n</code></pre>"},{"location":"reference/view/grid_world_view/grid_world/#src.view.grid_world_view.grid_world.GridWorld.display_mode_changed","title":"<code>display_mode_changed(option)</code>","text":"<p>When the display mode option menu is selected.</p> <p>Parameters:</p> Name Type Description Default <code>option</code> <code>str</code> <p>the mode selected</p> required Source code in <code>src/view/grid_world_view/grid_world.py</code> <pre><code>def display_mode_changed(self, option: str):\n    \"\"\"When the display mode option menu is selected.\n\n    Args:\n        option (str): the mode selected\n    \"\"\"\n    display_mode = self.display_mode_options[option]\n    self.action_bridge.submit_action(\n        UserAction.set_display_mode, display_mode\n    )\n</code></pre>"},{"location":"reference/view/grid_world_view/grid_world/#src.view.grid_world_view.grid_world.GridWorld.next_button_pressed","title":"<code>next_button_pressed()</code>","text":"<p>When the next button is presses step the state forward.</p> Source code in <code>src/view/grid_world_view/grid_world.py</code> <pre><code>def next_button_pressed(self):\n    \"\"\"When the next button is presses step the state forward.\"\"\"\n    self.action_bridge.submit_action(UserAction.one_step)\n</code></pre>"},{"location":"reference/view/grid_world_view/grid_world/#src.view.grid_world_view.grid_world.GridWorld.reset_button_pressed","title":"<code>reset_button_pressed()</code>","text":"<p>When the reset button is pressed. reset the state.</p> Source code in <code>src/view/grid_world_view/grid_world.py</code> <pre><code>def reset_button_pressed(self):\n    \"\"\"When the reset button is pressed. reset the state.\"\"\"\n    self.action_bridge.submit_action(UserAction.reset)\n</code></pre>"},{"location":"reference/view/grid_world_view/grid_world/#src.view.grid_world_view.grid_world.GridWorld.toggle_auto","title":"<code>toggle_auto(key)</code>","text":"<p>When the auto button has been pressed.</p> <p>automatically press the next button</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>the mode selected.</p> required Source code in <code>src/view/grid_world_view/grid_world.py</code> <pre><code>def toggle_auto(self, key: str):\n    \"\"\"When the auto button has been pressed.\n\n    automatically press the next button\n\n    Args:\n        key (str): the mode selected.\n    \"\"\"\n    last_mode = self.auto_mode\n    self.auto_mode = self.auto_mode_options[key]\n    if last_mode is self.auto_mode:\n        return\n    self._next_button.configure(\n        state=\"normal\" if self.auto_mode is AutoSpeed.manual else \"disabled\"\n    )\n\n    if self.auto_mode is AutoSpeed.auto_full:\n        self.action_bridge.submit_action(UserAction.start_auto)\n    elif last_mode is AutoSpeed.auto_full:\n        self.action_bridge.submit_action(UserAction.stop_auto)\n</code></pre>"},{"location":"reference/view/grid_world_view/display_state/","title":"Display State","text":"<p>This provides the widgets needed to display the grid world.</p>"},{"location":"reference/view/grid_world_view/display_state/display/","title":"Display","text":""},{"location":"reference/view/grid_world_view/display_state/display/#src.view.grid_world_view.display_state.display.DisplayState","title":"<code>DisplayState</code>","text":"<p>             Bases: <code>CTkFrame</code></p> <p>This widget contains the grid sizes it correctly.</p> <p>this widget sizes the view to fit as much of the container while maintaining the correct aspect ratio and centring the content</p> Source code in <code>src/view/grid_world_view/display_state/display.py</code> <pre><code>class DisplayState(CTkFrame):\n    \"\"\"This widget contains the grid sizes it correctly.\n\n    this widget sizes the view to fit as much of the container while maintaining\n    the correct aspect ratio and centring the content\n    \"\"\"\n\n    default_size = 0\n\n    cell_margins = 0.1\n\n    def __init__(self, master):\n        \"\"\"Initialise the padding widget.\n\n        Args:\n            master (Any): the widget to render this grid into\n        \"\"\"\n        super().__init__(\n            master, width=self.default_size, height=self.default_size\n        )\n        self.state: Optional[StateDescription] = None\n        self.cells: Dict[Tuple[int, int], Cell] = {}\n        self.grid_columnconfigure(0, weight=1)\n        self.grid_rowconfigure(1, weight=1)\n        self.image_label = CTkLabel(self, text=\"\")\n        self.image_label.grid(row=1, column=0, sticky=\"nsew\")\n        self.bind(\n            \"&lt;Configure&gt;\",\n            command=self.resize,\n        )\n\n    def set_state(self, state: StateDescription):\n        \"\"\"Set the state to be displayed.\n\n        Args:\n            state (StateDescription): the state to be displayed\n        \"\"\"\n        self.state = state\n        width, height = self.winfo_width(), self.winfo_height()\n        self.__configure_grid(width, height)\n\n    def resize(self, event):\n        \"\"\"Handle resize event.\n\n        resize the inner grid based upon the updated dimensions.\n\n        Args:\n            event (Any): the resize event\n        \"\"\"\n        self.__configure_grid(event.width, event.height)\n\n    def __populate_cells(\n        self, state: StateDescription, width: int, height: int\n    ):\n        self.cells = {}\n\n        cell_positions = state.grid_world.list_cell_positions(\n            width, height, self.cell_margins\n        )\n\n        for cell_position in cell_positions:\n            (\n                cell_coordinate,\n                bounding_box,\n            ) = cell_position\n            self.cells[cell_coordinate] = Cell(\n                state.cell_config[cell_coordinate], bounding_box\n            )\n\n    def __configure_grid(self, width: int, height: int):\n        if self.state is None:\n            return\n        (\n            expected_cell_size,\n            _marin_size,\n        ) = self.state.grid_world.get_cell_sizing(\n            width, height, self.cell_margins\n        )\n        if expected_cell_size &lt; 10:\n            # cells are too small\n            return\n        self.__populate_cells(self.state, width, height)\n        transparent = (255, 255, 255, 0)\n        image_mode = \"RGBA\"\n        image = Image.new(image_mode, (width, height), transparent)\n        image_draw = ImageDraw.Draw(image, image_mode)\n\n        for cell in self.cells.values():\n            cell.draw(image, image_draw)\n\n        image_tkinter = CTkImage(light_image=image, size=(width, height))\n        self.image_label.configure(image=image_tkinter)\n</code></pre>"},{"location":"reference/view/grid_world_view/display_state/display/#src.view.grid_world_view.display_state.display.DisplayState.__init__","title":"<code>__init__(master)</code>","text":"<p>Initialise the padding widget.</p> <p>Parameters:</p> Name Type Description Default <code>master</code> <code>Any</code> <p>the widget to render this grid into</p> required Source code in <code>src/view/grid_world_view/display_state/display.py</code> <pre><code>def __init__(self, master):\n    \"\"\"Initialise the padding widget.\n\n    Args:\n        master (Any): the widget to render this grid into\n    \"\"\"\n    super().__init__(\n        master, width=self.default_size, height=self.default_size\n    )\n    self.state: Optional[StateDescription] = None\n    self.cells: Dict[Tuple[int, int], Cell] = {}\n    self.grid_columnconfigure(0, weight=1)\n    self.grid_rowconfigure(1, weight=1)\n    self.image_label = CTkLabel(self, text=\"\")\n    self.image_label.grid(row=1, column=0, sticky=\"nsew\")\n    self.bind(\n        \"&lt;Configure&gt;\",\n        command=self.resize,\n    )\n</code></pre>"},{"location":"reference/view/grid_world_view/display_state/display/#src.view.grid_world_view.display_state.display.DisplayState.resize","title":"<code>resize(event)</code>","text":"<p>Handle resize event.</p> <p>resize the inner grid based upon the updated dimensions.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>Any</code> <p>the resize event</p> required Source code in <code>src/view/grid_world_view/display_state/display.py</code> <pre><code>def resize(self, event):\n    \"\"\"Handle resize event.\n\n    resize the inner grid based upon the updated dimensions.\n\n    Args:\n        event (Any): the resize event\n    \"\"\"\n    self.__configure_grid(event.width, event.height)\n</code></pre>"},{"location":"reference/view/grid_world_view/display_state/display/#src.view.grid_world_view.display_state.display.DisplayState.set_state","title":"<code>set_state(state)</code>","text":"<p>Set the state to be displayed.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>StateDescription</code> <p>the state to be displayed</p> required Source code in <code>src/view/grid_world_view/display_state/display.py</code> <pre><code>def set_state(self, state: StateDescription):\n    \"\"\"Set the state to be displayed.\n\n    Args:\n        state (StateDescription): the state to be displayed\n    \"\"\"\n    self.state = state\n    width, height = self.winfo_width(), self.winfo_height()\n    self.__configure_grid(width, height)\n</code></pre>"},{"location":"reference/view/grid_world_view/display_state/cell/","title":"Cell","text":"<p>This package is for the drawing of a cell in the grid world view.</p>"},{"location":"reference/view/grid_world_view/display_state/cell/arrow_layer/","title":"Arrow Layer","text":""},{"location":"reference/view/grid_world_view/display_state/cell/arrow_layer/#src.view.grid_world_view.display_state.cell.arrow_layer.ArrowLayer","title":"<code>ArrowLayer</code>","text":"<p>             Bases: <code>BaseLayer</code></p> <p>The layer responsible for drawing the background of the cell.</p> Source code in <code>src/view/grid_world_view/display_state/cell/arrow_layer.py</code> <pre><code>class ArrowLayer(BaseLayer):\n    \"\"\"The layer responsible for drawing the background of the cell.\"\"\"\n\n    def draw(self):\n        \"\"\"Draw the arrow layer.\"\"\"\n        match self.config.display_mode:\n            case DisplayMode.action_value_global:\n                self.__draw_specific_arrows(\n                    self.config.action_values_normalised\n                )\n            case DisplayMode.action_value_local:\n                self.__draw_specific_arrows(\n                    self.__rescale_values_locally(\n                        self.config.action_values_raw\n                    ),\n                )\n            case _:\n                return\n\n    def __draw_specific_arrows(self, action_values: action_value_description):\n        for action, action_value in action_values.items():\n            if action_value is not None:\n                self.__draw_arrow(action, action_value)\n\n    def __draw_arrow(self, action: Action, action_value: float):\n        size = self.cell_layout.get_bounding_box_size(self.bounding_box) // 3\n        color = self.value_to_color(action_value)\n        icon = self.icon_loader.get_action_icon(action, size, color)\n\n        dir_x, dir_y = GridWorld.action_direction[action]\n\n        relative_position = ((dir_x + 1) / 2, (dir_y + 1) / 2)\n        self.draw_icon(icon, size, relative_position)\n\n    def __rescale_values_locally(\n        self, action_values: action_value_description\n    ) -&gt; action_value_description:\n        \"\"\"Rescale the action values in this cell 0-1.\n\n        this should only be based on the values in this cell rather than the\n        global range of values.\n\n        Args:\n            action_values (action_value_description): the action values of this\n                cell.\n\n        Returns:\n            action_value_description: the scaled action values in the range 0-1\n        \"\"\"\n        min_value = float(\"inf\")\n        max_value = float(\"-inf\")\n\n        for action_value in action_values.values():\n            if action_value is None:\n                continue\n            min_value = min(action_value, min_value)\n            max_value = max(action_value, max_value)\n\n        rescaled_values: action_value_description = {}\n        value_range = max_value - min_value\n        for action, action_value in action_values.items():\n            if action_value is None:\n                rescaled_values[action] = None\n                continue\n            rescaled_values[action] = (action_value - min_value) / value_range\n        return rescaled_values\n</code></pre>"},{"location":"reference/view/grid_world_view/display_state/cell/arrow_layer/#src.view.grid_world_view.display_state.cell.arrow_layer.ArrowLayer.__rescale_values_locally","title":"<code>__rescale_values_locally(action_values)</code>","text":"<p>Rescale the action values in this cell 0-1.</p> <p>this should only be based on the values in this cell rather than the global range of values.</p> <p>Parameters:</p> Name Type Description Default <code>action_values</code> <code>action_value_description</code> <p>the action values of this cell.</p> required <p>Returns:</p> Name Type Description <code>action_value_description</code> <code>action_value_description</code> <p>the scaled action values in the range 0-1</p> Source code in <code>src/view/grid_world_view/display_state/cell/arrow_layer.py</code> <pre><code>def __rescale_values_locally(\n    self, action_values: action_value_description\n) -&gt; action_value_description:\n    \"\"\"Rescale the action values in this cell 0-1.\n\n    this should only be based on the values in this cell rather than the\n    global range of values.\n\n    Args:\n        action_values (action_value_description): the action values of this\n            cell.\n\n    Returns:\n        action_value_description: the scaled action values in the range 0-1\n    \"\"\"\n    min_value = float(\"inf\")\n    max_value = float(\"-inf\")\n\n    for action_value in action_values.values():\n        if action_value is None:\n            continue\n        min_value = min(action_value, min_value)\n        max_value = max(action_value, max_value)\n\n    rescaled_values: action_value_description = {}\n    value_range = max_value - min_value\n    for action, action_value in action_values.items():\n        if action_value is None:\n            rescaled_values[action] = None\n            continue\n        rescaled_values[action] = (action_value - min_value) / value_range\n    return rescaled_values\n</code></pre>"},{"location":"reference/view/grid_world_view/display_state/cell/arrow_layer/#src.view.grid_world_view.display_state.cell.arrow_layer.ArrowLayer.draw","title":"<code>draw()</code>","text":"<p>Draw the arrow layer.</p> Source code in <code>src/view/grid_world_view/display_state/cell/arrow_layer.py</code> <pre><code>def draw(self):\n    \"\"\"Draw the arrow layer.\"\"\"\n    match self.config.display_mode:\n        case DisplayMode.action_value_global:\n            self.__draw_specific_arrows(\n                self.config.action_values_normalised\n            )\n        case DisplayMode.action_value_local:\n            self.__draw_specific_arrows(\n                self.__rescale_values_locally(\n                    self.config.action_values_raw\n                ),\n            )\n        case _:\n            return\n</code></pre>"},{"location":"reference/view/grid_world_view/display_state/cell/background_layer/","title":"Background Layer","text":""},{"location":"reference/view/grid_world_view/display_state/cell/background_layer/#src.view.grid_world_view.display_state.cell.background_layer.BackgroundLayer","title":"<code>BackgroundLayer</code>","text":"<p>             Bases: <code>BaseLayer</code></p> <p>The layer responsible for drawing the background of the cell.</p> Source code in <code>src/view/grid_world_view/display_state/cell/background_layer.py</code> <pre><code>class BackgroundLayer(BaseLayer):\n    \"\"\"The layer responsible for drawing the background of the cell.\"\"\"\n\n    default_background_color = \"#515151\"\n\n    def draw(self):\n        \"\"\"Draw the background layer.\"\"\"\n        fill, outline = self.__cell_mode_color()\n\n        self.drawing_context.rounded_rectangle(\n            self.bounding_box,\n            self.cell_layout.border_width,\n            fill=fill,\n            outline=outline,\n            width=self.cell_layout.border_width,\n        )\n\n    def __cell_mode_color(self) -&gt; Tuple[str, str]:\n        \"\"\"Get the color for the inner and outer background based on the mode.\n\n        Returns:\n            Tuple[str, str]: inner and outer color\n        \"\"\"\n        default_color = self.default_background_color\n        if self.config.display_mode is not DisplayMode.state_value:\n            return default_color, default_color\n        cell_value_color = self.__cell_color()\n\n        if self.config.cell_entity is CellEntity.empty:\n            return cell_value_color, cell_value_color\n\n        return default_color, cell_value_color\n\n    def __cell_color(self) -&gt; str:\n        \"\"\"Get the color the cell should be based upon the value.\n\n        red represents a low value and green represents a good value\n\n        Returns:\n            str: the hex color of the cell based on this value.\n        \"\"\"\n        cell_value = self.config.cell_value_normalised\n        if cell_value is None:\n            return self.default_background_color\n        return self.value_to_color(cell_value)\n</code></pre>"},{"location":"reference/view/grid_world_view/display_state/cell/background_layer/#src.view.grid_world_view.display_state.cell.background_layer.BackgroundLayer.__cell_color","title":"<code>__cell_color()</code>","text":"<p>Get the color the cell should be based upon the value.</p> <p>red represents a low value and green represents a good value</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>the hex color of the cell based on this value.</p> Source code in <code>src/view/grid_world_view/display_state/cell/background_layer.py</code> <pre><code>def __cell_color(self) -&gt; str:\n    \"\"\"Get the color the cell should be based upon the value.\n\n    red represents a low value and green represents a good value\n\n    Returns:\n        str: the hex color of the cell based on this value.\n    \"\"\"\n    cell_value = self.config.cell_value_normalised\n    if cell_value is None:\n        return self.default_background_color\n    return self.value_to_color(cell_value)\n</code></pre>"},{"location":"reference/view/grid_world_view/display_state/cell/background_layer/#src.view.grid_world_view.display_state.cell.background_layer.BackgroundLayer.__cell_mode_color","title":"<code>__cell_mode_color()</code>","text":"<p>Get the color for the inner and outer background based on the mode.</p> <p>Returns:</p> Type Description <code>Tuple[str, str]</code> <p>Tuple[str, str]: inner and outer color</p> Source code in <code>src/view/grid_world_view/display_state/cell/background_layer.py</code> <pre><code>def __cell_mode_color(self) -&gt; Tuple[str, str]:\n    \"\"\"Get the color for the inner and outer background based on the mode.\n\n    Returns:\n        Tuple[str, str]: inner and outer color\n    \"\"\"\n    default_color = self.default_background_color\n    if self.config.display_mode is not DisplayMode.state_value:\n        return default_color, default_color\n    cell_value_color = self.__cell_color()\n\n    if self.config.cell_entity is CellEntity.empty:\n        return cell_value_color, cell_value_color\n\n    return default_color, cell_value_color\n</code></pre>"},{"location":"reference/view/grid_world_view/display_state/cell/background_layer/#src.view.grid_world_view.display_state.cell.background_layer.BackgroundLayer.draw","title":"<code>draw()</code>","text":"<p>Draw the background layer.</p> Source code in <code>src/view/grid_world_view/display_state/cell/background_layer.py</code> <pre><code>def draw(self):\n    \"\"\"Draw the background layer.\"\"\"\n    fill, outline = self.__cell_mode_color()\n\n    self.drawing_context.rounded_rectangle(\n        self.bounding_box,\n        self.cell_layout.border_width,\n        fill=fill,\n        outline=outline,\n        width=self.cell_layout.border_width,\n    )\n</code></pre>"},{"location":"reference/view/grid_world_view/display_state/cell/base_layer/","title":"Base Layer","text":""},{"location":"reference/view/grid_world_view/display_state/cell/base_layer/#src.view.grid_world_view.display_state.cell.base_layer.BaseLayer","title":"<code>BaseLayer</code>","text":"<p>             Bases: <code>object</code></p> <p>Represents one layer of the cell's drawing.</p> Source code in <code>src/view/grid_world_view/display_state/cell/base_layer.py</code> <pre><code>class BaseLayer(object):\n    \"\"\"Represents one layer of the cell's drawing.\"\"\"\n\n    def __init__(  # Noqa : WPS211\n        self,\n        config: CellConfiguration,\n        canvas: Image,\n        drawing_context: ImageDraw,\n        bounding_box: Tuple[int, int, int, int],\n        cell_layout: CellLayout,\n    ) -&gt; None:\n        \"\"\"Initialise the layer.\n\n        Args:\n            config (CellConfiguration): the configuration to represent\n            canvas (Image): the canvas to draw on\n            drawing_context (ImageDraw): the drawing context of this canvas\n            bounding_box (Tuple[int, int, int, int]): the area of the canvas\n                this layer should be drawn in.\n            cell_layout (CellLayout): the layout of the entire cell.\n\n        \"\"\"\n        self.config = config\n        self.canvas = canvas\n        self.drawing_context = drawing_context\n        self.bounding_box = bounding_box\n        self.cell_layout = cell_layout\n        self.icon_loader = IconLoader()\n\n    def draw(self):\n        \"\"\"Draw this layer to the canvas.\n\n        Raises:\n            RuntimeError: if this method is not overridden.\n        \"\"\"\n        raise RuntimeError(\"Draw should be overridden by concrete class\")\n\n    def draw_icon(\n        self,\n        icon: Image,\n        size: int,\n        rel_pos: Tuple[float, float] = (0.5, 0.5),\n    ):\n        \"\"\"Draw an icon in the cell.\n\n        rel_pos is relative to the bounding box of this layer.\n\n        Args:\n            icon (Image): the icon to display\n            size (int): the size of the icon to display\n            rel_pos (Tuple[float, float], optional): the position in the cell.\n                Defaults to the centre.\n        \"\"\"\n        min_x, min_y, max_x, _max_y = self.bounding_box\n        rel_x, rel_y = rel_pos\n\n        space = max_x - min_x - size\n        location = (\n            min_x + int(rel_x * space),\n            min_y + int(rel_y * space),\n        )\n\n        icon_alpha = icon.split()[3]\n        self.canvas.paste(icon, location, icon_alpha)\n\n    def value_to_color(self, worth: float) -&gt; str:\n        \"\"\"Convert a floating point value to a color.\n\n        Args:\n            worth (float): the value to represent in the range 0 to 1.\n\n        Returns:\n            str: the color in a hexadecimal string representation\n        \"\"\"\n        # I know red is zero but this allows for more configuration\n        start = Color(\"red\").get_hue()\n        end = Color(\"green\").get_hue()\n\n        hue = worth * (end - start) + start\n\n        return Color(hsl=(hue, 1, 0.5)).hex_l\n</code></pre>"},{"location":"reference/view/grid_world_view/display_state/cell/base_layer/#src.view.grid_world_view.display_state.cell.base_layer.BaseLayer.__init__","title":"<code>__init__(config, canvas, drawing_context, bounding_box, cell_layout)</code>","text":"<p>Initialise the layer.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>CellConfiguration</code> <p>the configuration to represent</p> required <code>canvas</code> <code>Image</code> <p>the canvas to draw on</p> required <code>drawing_context</code> <code>ImageDraw</code> <p>the drawing context of this canvas</p> required <code>bounding_box</code> <code>Tuple[int, int, int, int]</code> <p>the area of the canvas this layer should be drawn in.</p> required <code>cell_layout</code> <code>CellLayout</code> <p>the layout of the entire cell.</p> required Source code in <code>src/view/grid_world_view/display_state/cell/base_layer.py</code> <pre><code>def __init__(  # Noqa : WPS211\n    self,\n    config: CellConfiguration,\n    canvas: Image,\n    drawing_context: ImageDraw,\n    bounding_box: Tuple[int, int, int, int],\n    cell_layout: CellLayout,\n) -&gt; None:\n    \"\"\"Initialise the layer.\n\n    Args:\n        config (CellConfiguration): the configuration to represent\n        canvas (Image): the canvas to draw on\n        drawing_context (ImageDraw): the drawing context of this canvas\n        bounding_box (Tuple[int, int, int, int]): the area of the canvas\n            this layer should be drawn in.\n        cell_layout (CellLayout): the layout of the entire cell.\n\n    \"\"\"\n    self.config = config\n    self.canvas = canvas\n    self.drawing_context = drawing_context\n    self.bounding_box = bounding_box\n    self.cell_layout = cell_layout\n    self.icon_loader = IconLoader()\n</code></pre>"},{"location":"reference/view/grid_world_view/display_state/cell/base_layer/#src.view.grid_world_view.display_state.cell.base_layer.BaseLayer.draw","title":"<code>draw()</code>","text":"<p>Draw this layer to the canvas.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if this method is not overridden.</p> Source code in <code>src/view/grid_world_view/display_state/cell/base_layer.py</code> <pre><code>def draw(self):\n    \"\"\"Draw this layer to the canvas.\n\n    Raises:\n        RuntimeError: if this method is not overridden.\n    \"\"\"\n    raise RuntimeError(\"Draw should be overridden by concrete class\")\n</code></pre>"},{"location":"reference/view/grid_world_view/display_state/cell/base_layer/#src.view.grid_world_view.display_state.cell.base_layer.BaseLayer.draw_icon","title":"<code>draw_icon(icon, size, rel_pos=(0.5, 0.5))</code>","text":"<p>Draw an icon in the cell.</p> <p>rel_pos is relative to the bounding box of this layer.</p> <p>Parameters:</p> Name Type Description Default <code>icon</code> <code>Image</code> <p>the icon to display</p> required <code>size</code> <code>int</code> <p>the size of the icon to display</p> required <code>rel_pos</code> <code>Tuple[float, float]</code> <p>the position in the cell. Defaults to the centre.</p> <code>(0.5, 0.5)</code> Source code in <code>src/view/grid_world_view/display_state/cell/base_layer.py</code> <pre><code>def draw_icon(\n    self,\n    icon: Image,\n    size: int,\n    rel_pos: Tuple[float, float] = (0.5, 0.5),\n):\n    \"\"\"Draw an icon in the cell.\n\n    rel_pos is relative to the bounding box of this layer.\n\n    Args:\n        icon (Image): the icon to display\n        size (int): the size of the icon to display\n        rel_pos (Tuple[float, float], optional): the position in the cell.\n            Defaults to the centre.\n    \"\"\"\n    min_x, min_y, max_x, _max_y = self.bounding_box\n    rel_x, rel_y = rel_pos\n\n    space = max_x - min_x - size\n    location = (\n        min_x + int(rel_x * space),\n        min_y + int(rel_y * space),\n    )\n\n    icon_alpha = icon.split()[3]\n    self.canvas.paste(icon, location, icon_alpha)\n</code></pre>"},{"location":"reference/view/grid_world_view/display_state/cell/base_layer/#src.view.grid_world_view.display_state.cell.base_layer.BaseLayer.value_to_color","title":"<code>value_to_color(worth)</code>","text":"<p>Convert a floating point value to a color.</p> <p>Parameters:</p> Name Type Description Default <code>worth</code> <code>float</code> <p>the value to represent in the range 0 to 1.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>the color in a hexadecimal string representation</p> Source code in <code>src/view/grid_world_view/display_state/cell/base_layer.py</code> <pre><code>def value_to_color(self, worth: float) -&gt; str:\n    \"\"\"Convert a floating point value to a color.\n\n    Args:\n        worth (float): the value to represent in the range 0 to 1.\n\n    Returns:\n        str: the color in a hexadecimal string representation\n    \"\"\"\n    # I know red is zero but this allows for more configuration\n    start = Color(\"red\").get_hue()\n    end = Color(\"green\").get_hue()\n\n    hue = worth * (end - start) + start\n\n    return Color(hsl=(hue, 1, 0.5)).hex_l\n</code></pre>"},{"location":"reference/view/grid_world_view/display_state/cell/cell/","title":"Cell","text":""},{"location":"reference/view/grid_world_view/display_state/cell/cell/#src.view.grid_world_view.display_state.cell.cell.Cell","title":"<code>Cell</code>","text":"<p>             Bases: <code>object</code></p> <p>Widget to display an individual cell.</p> Source code in <code>src/view/grid_world_view/display_state/cell/cell.py</code> <pre><code>class Cell(object):\n    \"\"\"Widget to display an individual cell.\"\"\"\n\n    def __init__(\n        self,\n        config: CellConfiguration,\n        bounding_box: Tuple[int, int, int, int],\n    ) -&gt; None:\n        \"\"\"Initialise the cell.\n\n        displays the cell as a rounded rectangle with icons.\n\n        Args:\n            config (CellConfiguration): the configuration of how this cell\n                should present.\n            bounding_box (Tuple[int, int, int, int]): the position and size of\n                this cell on the canvas.\n        \"\"\"\n        self.config = config\n        self.cell_layout = CellLayout(bounding_box)\n\n    def draw(\n        self,\n        canvas: Image,\n        drawing_context: ImageDraw,\n    ):\n        \"\"\"Draw the cell to the canvas.\n\n        Args:\n            canvas (Image): the image to draw to\n            drawing_context (ImageDraw): the drawing context\n        \"\"\"\n        BackgroundLayer(\n            self.config,\n            canvas,\n            drawing_context,\n            self.cell_layout.bounding_box,\n            self.cell_layout,\n        ).draw()\n        MainIconLayer(\n            self.config,\n            canvas,\n            drawing_context,\n            self.cell_layout.inset_bounding_box(\n                self.cell_layout.padding + self.cell_layout.border_width\n            ),\n            self.cell_layout,\n        ).draw()\n        ArrowLayer(\n            self.config,\n            canvas,\n            drawing_context,\n            self.cell_layout.inset_bounding_box(self.cell_layout.padding),\n            self.cell_layout,\n        ).draw()\n</code></pre>"},{"location":"reference/view/grid_world_view/display_state/cell/cell/#src.view.grid_world_view.display_state.cell.cell.Cell.__init__","title":"<code>__init__(config, bounding_box)</code>","text":"<p>Initialise the cell.</p> <p>displays the cell as a rounded rectangle with icons.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>CellConfiguration</code> <p>the configuration of how this cell should present.</p> required <code>bounding_box</code> <code>Tuple[int, int, int, int]</code> <p>the position and size of this cell on the canvas.</p> required Source code in <code>src/view/grid_world_view/display_state/cell/cell.py</code> <pre><code>def __init__(\n    self,\n    config: CellConfiguration,\n    bounding_box: Tuple[int, int, int, int],\n) -&gt; None:\n    \"\"\"Initialise the cell.\n\n    displays the cell as a rounded rectangle with icons.\n\n    Args:\n        config (CellConfiguration): the configuration of how this cell\n            should present.\n        bounding_box (Tuple[int, int, int, int]): the position and size of\n            this cell on the canvas.\n    \"\"\"\n    self.config = config\n    self.cell_layout = CellLayout(bounding_box)\n</code></pre>"},{"location":"reference/view/grid_world_view/display_state/cell/cell/#src.view.grid_world_view.display_state.cell.cell.Cell.draw","title":"<code>draw(canvas, drawing_context)</code>","text":"<p>Draw the cell to the canvas.</p> <p>Parameters:</p> Name Type Description Default <code>canvas</code> <code>Image</code> <p>the image to draw to</p> required <code>drawing_context</code> <code>ImageDraw</code> <p>the drawing context</p> required Source code in <code>src/view/grid_world_view/display_state/cell/cell.py</code> <pre><code>def draw(\n    self,\n    canvas: Image,\n    drawing_context: ImageDraw,\n):\n    \"\"\"Draw the cell to the canvas.\n\n    Args:\n        canvas (Image): the image to draw to\n        drawing_context (ImageDraw): the drawing context\n    \"\"\"\n    BackgroundLayer(\n        self.config,\n        canvas,\n        drawing_context,\n        self.cell_layout.bounding_box,\n        self.cell_layout,\n    ).draw()\n    MainIconLayer(\n        self.config,\n        canvas,\n        drawing_context,\n        self.cell_layout.inset_bounding_box(\n            self.cell_layout.padding + self.cell_layout.border_width\n        ),\n        self.cell_layout,\n    ).draw()\n    ArrowLayer(\n        self.config,\n        canvas,\n        drawing_context,\n        self.cell_layout.inset_bounding_box(self.cell_layout.padding),\n        self.cell_layout,\n    ).draw()\n</code></pre>"},{"location":"reference/view/grid_world_view/display_state/cell/cell_layout/","title":"Cell Layout","text":""},{"location":"reference/view/grid_world_view/display_state/cell/cell_layout/#src.view.grid_world_view.display_state.cell.cell_layout.CellLayout","title":"<code>CellLayout</code>","text":"<p>             Bases: <code>object</code></p> <p>Class for managing the layout and configuration of each cell.</p> Source code in <code>src/view/grid_world_view/display_state/cell/cell_layout.py</code> <pre><code>class CellLayout(object):\n    \"\"\"Class for managing the layout and configuration of each cell.\"\"\"\n\n    min_border_width: int = 6\n    min_padding: int = 2\n    padding_ratio: float = 0.1\n    border_ratio: float = 0.05\n\n    def __init__(self, bounding_box: Tuple[int, int, int, int]):\n        \"\"\"Initialise the cell layout.\n\n        Args:\n            bounding_box (Tuple[int, int, int, int]): the size of the cell.\n        \"\"\"\n        self.bounding_box = bounding_box\n        self.cell_size = self.get_bounding_box_size(bounding_box)\n        self.border_width = int(\n            max(self.border_ratio * self.cell_size, self.min_border_width)\n        )\n        self.padding = int(\n            max(self.padding_ratio * self.cell_size, self.min_padding)\n        )\n\n    def get_bounding_box_size(\n        self, bounding_box: Tuple[int, int, int, int]\n    ) -&gt; int:\n        \"\"\"Get the size of a bounding box.\n\n        Args:\n            bounding_box (Tuple[int, int, int, int]): the box to measure\n\n        Returns:\n            int: the minimum length along one edge.\n        \"\"\"\n        min_x, min_y, max_x, max_y = bounding_box\n\n        return min(max_x - min_x, max_y - min_y)\n\n    def inset_bounding_box(\n        self, inset_amount: int\n    ) -&gt; Tuple[int, int, int, int]:\n        \"\"\"Get the bounding box that has been inset.\n\n        Args:\n            inset_amount (int): the amount to make the box smaller\n\n        Returns:\n            Tuple[int, int, int, int]: the new bounding box that has been inset\n        \"\"\"\n        min_x, min_y, max_x, max_y = self.bounding_box\n        return (\n            min_x + inset_amount,\n            min_y + inset_amount,\n            max_x - inset_amount,\n            max_y - inset_amount,\n        )\n</code></pre>"},{"location":"reference/view/grid_world_view/display_state/cell/cell_layout/#src.view.grid_world_view.display_state.cell.cell_layout.CellLayout.__init__","title":"<code>__init__(bounding_box)</code>","text":"<p>Initialise the cell layout.</p> <p>Parameters:</p> Name Type Description Default <code>bounding_box</code> <code>Tuple[int, int, int, int]</code> <p>the size of the cell.</p> required Source code in <code>src/view/grid_world_view/display_state/cell/cell_layout.py</code> <pre><code>def __init__(self, bounding_box: Tuple[int, int, int, int]):\n    \"\"\"Initialise the cell layout.\n\n    Args:\n        bounding_box (Tuple[int, int, int, int]): the size of the cell.\n    \"\"\"\n    self.bounding_box = bounding_box\n    self.cell_size = self.get_bounding_box_size(bounding_box)\n    self.border_width = int(\n        max(self.border_ratio * self.cell_size, self.min_border_width)\n    )\n    self.padding = int(\n        max(self.padding_ratio * self.cell_size, self.min_padding)\n    )\n</code></pre>"},{"location":"reference/view/grid_world_view/display_state/cell/cell_layout/#src.view.grid_world_view.display_state.cell.cell_layout.CellLayout.get_bounding_box_size","title":"<code>get_bounding_box_size(bounding_box)</code>","text":"<p>Get the size of a bounding box.</p> <p>Parameters:</p> Name Type Description Default <code>bounding_box</code> <code>Tuple[int, int, int, int]</code> <p>the box to measure</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>the minimum length along one edge.</p> Source code in <code>src/view/grid_world_view/display_state/cell/cell_layout.py</code> <pre><code>def get_bounding_box_size(\n    self, bounding_box: Tuple[int, int, int, int]\n) -&gt; int:\n    \"\"\"Get the size of a bounding box.\n\n    Args:\n        bounding_box (Tuple[int, int, int, int]): the box to measure\n\n    Returns:\n        int: the minimum length along one edge.\n    \"\"\"\n    min_x, min_y, max_x, max_y = bounding_box\n\n    return min(max_x - min_x, max_y - min_y)\n</code></pre>"},{"location":"reference/view/grid_world_view/display_state/cell/cell_layout/#src.view.grid_world_view.display_state.cell.cell_layout.CellLayout.inset_bounding_box","title":"<code>inset_bounding_box(inset_amount)</code>","text":"<p>Get the bounding box that has been inset.</p> <p>Parameters:</p> Name Type Description Default <code>inset_amount</code> <code>int</code> <p>the amount to make the box smaller</p> required <p>Returns:</p> Type Description <code>Tuple[int, int, int, int]</code> <p>Tuple[int, int, int, int]: the new bounding box that has been inset</p> Source code in <code>src/view/grid_world_view/display_state/cell/cell_layout.py</code> <pre><code>def inset_bounding_box(\n    self, inset_amount: int\n) -&gt; Tuple[int, int, int, int]:\n    \"\"\"Get the bounding box that has been inset.\n\n    Args:\n        inset_amount (int): the amount to make the box smaller\n\n    Returns:\n        Tuple[int, int, int, int]: the new bounding box that has been inset\n    \"\"\"\n    min_x, min_y, max_x, max_y = self.bounding_box\n    return (\n        min_x + inset_amount,\n        min_y + inset_amount,\n        max_x - inset_amount,\n        max_y - inset_amount,\n    )\n</code></pre>"},{"location":"reference/view/grid_world_view/display_state/cell/main_icon_layer/","title":"Main Icon Layer","text":""},{"location":"reference/view/grid_world_view/display_state/cell/main_icon_layer/#src.view.grid_world_view.display_state.cell.main_icon_layer.MainIconLayer","title":"<code>MainIconLayer</code>","text":"<p>             Bases: <code>BaseLayer</code></p> <p>The layer responsible for drawing the background of the cell.</p> Source code in <code>src/view/grid_world_view/display_state/cell/main_icon_layer.py</code> <pre><code>class MainIconLayer(BaseLayer):\n    \"\"\"The layer responsible for drawing the background of the cell.\"\"\"\n\n    def draw(self):\n        \"\"\"Draw the main icon.\"\"\"\n        size = self.cell_layout.get_bounding_box_size(self.bounding_box)\n        icon = self.__get_main_icon(size)\n        if icon is None:\n            return\n        self.draw_icon(icon, size)\n\n    def __get_main_icon(self, size: int) -&gt; Optional[Image]:\n        \"\"\"Get what the main icon should be based upon the cell config.\n\n        Args:\n            size (int): the size the icon should be.\n\n        Returns:\n            Image: the image that corresponds to what the main icon should be\n        \"\"\"\n        config = self.config\n        loader = self.icon_loader\n        match config.display_mode:\n            case DisplayMode.default | DisplayMode.state_value:\n                return loader.get_cell_entity_icon(config.cell_entity, size)\n            case (\n                DisplayMode.action_value_global | DisplayMode.action_value_local\n            ):\n                if config.cell_entity is CellEntity.goal:\n                    return loader.get_cell_entity_icon(config.cell_entity, size)\n                return None\n            case DisplayMode.best_action:\n                best_action = self.__get_best_action()\n                if best_action is None:\n                    return loader.get_cell_entity_icon(config.cell_entity, size)\n\n                return loader.get_action_icon(best_action, size)\n\n    def __get_best_action(self) -&gt; Optional[Action]:\n        \"\"\"Get the action that has the best value.\n\n        Returns:\n            Optional[Action]: the best action if there is one.\n        \"\"\"\n        action_values = self.config.action_values_raw\n        best_action_value = float(\"-inf\")\n        best_action = None\n        for action in Action:\n            action_value = action_values[action]\n            if action_value is None:\n                continue\n            if best_action_value is None:\n                best_action_value = action_value\n                best_action = action\n            elif action_value &gt; best_action_value:\n                best_action_value = action_value\n                best_action = action\n        return best_action\n</code></pre>"},{"location":"reference/view/grid_world_view/display_state/cell/main_icon_layer/#src.view.grid_world_view.display_state.cell.main_icon_layer.MainIconLayer.__get_best_action","title":"<code>__get_best_action()</code>","text":"<p>Get the action that has the best value.</p> <p>Returns:</p> Type Description <code>Optional[Action]</code> <p>Optional[Action]: the best action if there is one.</p> Source code in <code>src/view/grid_world_view/display_state/cell/main_icon_layer.py</code> <pre><code>def __get_best_action(self) -&gt; Optional[Action]:\n    \"\"\"Get the action that has the best value.\n\n    Returns:\n        Optional[Action]: the best action if there is one.\n    \"\"\"\n    action_values = self.config.action_values_raw\n    best_action_value = float(\"-inf\")\n    best_action = None\n    for action in Action:\n        action_value = action_values[action]\n        if action_value is None:\n            continue\n        if best_action_value is None:\n            best_action_value = action_value\n            best_action = action\n        elif action_value &gt; best_action_value:\n            best_action_value = action_value\n            best_action = action\n    return best_action\n</code></pre>"},{"location":"reference/view/grid_world_view/display_state/cell/main_icon_layer/#src.view.grid_world_view.display_state.cell.main_icon_layer.MainIconLayer.__get_main_icon","title":"<code>__get_main_icon(size)</code>","text":"<p>Get what the main icon should be based upon the cell config.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int</code> <p>the size the icon should be.</p> required <p>Returns:</p> Name Type Description <code>Image</code> <code>Optional[Image]</code> <p>the image that corresponds to what the main icon should be</p> Source code in <code>src/view/grid_world_view/display_state/cell/main_icon_layer.py</code> <pre><code>def __get_main_icon(self, size: int) -&gt; Optional[Image]:\n    \"\"\"Get what the main icon should be based upon the cell config.\n\n    Args:\n        size (int): the size the icon should be.\n\n    Returns:\n        Image: the image that corresponds to what the main icon should be\n    \"\"\"\n    config = self.config\n    loader = self.icon_loader\n    match config.display_mode:\n        case DisplayMode.default | DisplayMode.state_value:\n            return loader.get_cell_entity_icon(config.cell_entity, size)\n        case (\n            DisplayMode.action_value_global | DisplayMode.action_value_local\n        ):\n            if config.cell_entity is CellEntity.goal:\n                return loader.get_cell_entity_icon(config.cell_entity, size)\n            return None\n        case DisplayMode.best_action:\n            best_action = self.__get_best_action()\n            if best_action is None:\n                return loader.get_cell_entity_icon(config.cell_entity, size)\n\n            return loader.get_action_icon(best_action, size)\n</code></pre>"},{"location":"reference/view/grid_world_view/display_state/cell/main_icon_layer/#src.view.grid_world_view.display_state.cell.main_icon_layer.MainIconLayer.draw","title":"<code>draw()</code>","text":"<p>Draw the main icon.</p> Source code in <code>src/view/grid_world_view/display_state/cell/main_icon_layer.py</code> <pre><code>def draw(self):\n    \"\"\"Draw the main icon.\"\"\"\n    size = self.cell_layout.get_bounding_box_size(self.bounding_box)\n    icon = self.__get_main_icon(size)\n    if icon is None:\n        return\n    self.draw_icon(icon, size)\n</code></pre>"},{"location":"reference/view/icons/","title":"Icons","text":"<p>Package for loading icons into custom tkinter.</p>"},{"location":"reference/view/icons/load_icon/","title":"Load Icon","text":""},{"location":"reference/view/icons/load_icon/#src.view.icons.load_icon.Icon","title":"<code>Icon</code>","text":"<p>             Bases: <code>Enum</code></p> <p>Enumerates all possible icons available.</p> Source code in <code>src/view/icons/load_icon.py</code> <pre><code>class Icon(Enum):\n    \"\"\"Enumerates all possible icons available.\"\"\"\n\n    robot = \"robot\"\n    flag = \"flag\"\n    no_entry = \"do-not-enter\"\n    up_arrow = \"up-arrow\"\n    down_arrow = \"down-arrow\"\n    right_arrow = \"right-arrow\"\n    left_arrow = \"left-arrow\"\n    empty = \"empty\"\n</code></pre>"},{"location":"reference/view/icons/load_icon/#src.view.icons.load_icon.IconLoader","title":"<code>IconLoader</code>","text":"<p>             Bases: <code>object</code></p> <p>Load Icon images into the application.</p> Source code in <code>src/view/icons/load_icon.py</code> <pre><code>class IconLoader(object):\n    \"\"\"Load Icon images into the application.\"\"\"\n\n    _instance = None\n\n    # icon -&gt; normal icon, light icon\n    # avoid loading the same icon file multiple times\n    bitmap_cache: Dict[Icon, Image] = {}\n\n    # cache icon size and color because they will likely be used a lot\n    color_size_cache: Dict[Tuple[Icon, int, str], Image] = {}\n\n    def __new__(cls) -&gt; Self:\n        \"\"\"Create a config object.\n\n        Overridden to provide the singleton patten, there must only be one\n        IconLoader object. there should only be one cache so there is not need\n        for more than one loader\n\n        Returns:\n            Self: The config object with the loaded data\n        \"\"\"\n        # https://python-patterns.guide/gang-of-four/singleton/\n        if cls._instance is None:\n            cls._instance = super().__new__(cls)\n        return cls._instance\n\n    def get_path(self, icon: Icon) -&gt; str:\n        \"\"\"Get an icon's file path.\n\n        Args:\n            icon (Icon): the icon to find the path for.\n\n        Returns:\n            str: the absolute path to the icon file.\n        \"\"\"\n        return path.abspath(\n            path.join(path.dirname(__file__), f\"{icon.value}.png\")\n        )\n\n    rgb_component_max = 255\n\n    def get_coloured_icon(self, image: Image, color: str) -&gt; Image:\n        \"\"\"Convert a black icon to a specific color.\n\n        sets all non-transparent pixels to the color.\n\n        Args:\n            image (Image): the image to convert,\n            color (str): must represent a valid color\n\n        Returns:\n            Image: the image with a white foreground\n        \"\"\"\n        rgb_float = np.array(Color(color).get_rgb())\n\n        np_color = np.floor(rgb_float * self.rgb_component_max).astype(int)\n\n        img_array = np.array(image.convert(\"RGBA\"))\n\n        rgb = img_array[:, :, :3]\n        alpha = img_array[:, :, 3]\n        non_transparent_pixels = alpha != 0\n        # set icon color to wight\n        rgb[non_transparent_pixels] = np_color\n\n        return Pillow.fromarray(img_array)\n\n    action_mapping: Dict[Action, Icon] = {\n        Action.up: Icon.up_arrow,\n        Action.down: Icon.down_arrow,\n        Action.left: Icon.left_arrow,\n        Action.right: Icon.right_arrow,\n    }\n\n    def get_action_icon(\n        self, action: Action, size: int, color: str = \"#fff\"\n    ) -&gt; Image:\n        \"\"\"Get the appropriate arrow icon for a given action.\n\n        Args:\n            action (Action): the action to represent\n            size (int): the size the icon should be displayed by tkinter\n            color (str): the color of the icon\n\n        Returns:\n            Image: the image pointing in that actions direction.\n        \"\"\"\n        return self.get_icon(self.action_mapping[action], size, color)\n\n    cell_entity_mapping = {\n        CellEntity.agent: Icon.robot,\n        CellEntity.goal: Icon.flag,\n        CellEntity.blocked: Icon.no_entry,\n        CellEntity.empty: Icon.empty,\n    }\n\n    def get_cell_entity_icon(\n        self, entity: CellEntity, size: int, color: str = \"#fff\"\n    ) -&gt; Image:\n        \"\"\"Get the appropriate icon for a given cell entity.\n\n        Args:\n            entity (CellEntity): the entity to represent\n            size (int): the size the icon should be displayed by tkinter\n            color (str): the color of the icon\n\n        Returns:\n            Image: the image of this cell entity\n        \"\"\"\n        return self.get_icon(self.cell_entity_mapping[entity], size, color)\n\n    def get_icon(self, icon: Icon, size: int, color: str = \"#fff\") -&gt; Image:\n        \"\"\"Get the custom tkinter image object for a given icon.\n\n        Args:\n            icon (Icon): the icon to display\n            size (int): the size the icon should be displayed by tkinter\n            color (str): the color of the icon\n\n        Returns:\n            Image: the image representing this icon\n        \"\"\"\n        size = max(size, 1)\n        cache_key = (icon, size, color)\n        existing_image = self.color_size_cache.get(cache_key, None)\n        if existing_image is not None:\n            return existing_image\n\n        image_raw = self.__get_icon_raw_files(icon)\n\n        coloured_icon = self.get_coloured_icon(image_raw, color)\n        # resize image\n        coloured_icon.thumbnail((size, size))\n\n        self.color_size_cache[cache_key] = coloured_icon\n\n        return coloured_icon\n\n    def __get_icon_raw_files(self, icon: Icon) -&gt; Image:\n        cached_file = self.bitmap_cache.get(icon, None)\n        if cached_file is not None:\n            return cached_file\n\n        icon_raw = Pillow.open(self.get_path(icon))\n\n        self.bitmap_cache[icon] = icon_raw\n        return icon_raw\n</code></pre>"},{"location":"reference/view/icons/load_icon/#src.view.icons.load_icon.IconLoader.__new__","title":"<code>__new__()</code>","text":"<p>Create a config object.</p> <p>Overridden to provide the singleton patten, there must only be one IconLoader object. there should only be one cache so there is not need for more than one loader</p> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The config object with the loaded data</p> Source code in <code>src/view/icons/load_icon.py</code> <pre><code>def __new__(cls) -&gt; Self:\n    \"\"\"Create a config object.\n\n    Overridden to provide the singleton patten, there must only be one\n    IconLoader object. there should only be one cache so there is not need\n    for more than one loader\n\n    Returns:\n        Self: The config object with the loaded data\n    \"\"\"\n    # https://python-patterns.guide/gang-of-four/singleton/\n    if cls._instance is None:\n        cls._instance = super().__new__(cls)\n    return cls._instance\n</code></pre>"},{"location":"reference/view/icons/load_icon/#src.view.icons.load_icon.IconLoader.get_action_icon","title":"<code>get_action_icon(action, size, color='#fff')</code>","text":"<p>Get the appropriate arrow icon for a given action.</p> <p>Parameters:</p> Name Type Description Default <code>action</code> <code>Action</code> <p>the action to represent</p> required <code>size</code> <code>int</code> <p>the size the icon should be displayed by tkinter</p> required <code>color</code> <code>str</code> <p>the color of the icon</p> <code>'#fff'</code> <p>Returns:</p> Name Type Description <code>Image</code> <code>Image</code> <p>the image pointing in that actions direction.</p> Source code in <code>src/view/icons/load_icon.py</code> <pre><code>def get_action_icon(\n    self, action: Action, size: int, color: str = \"#fff\"\n) -&gt; Image:\n    \"\"\"Get the appropriate arrow icon for a given action.\n\n    Args:\n        action (Action): the action to represent\n        size (int): the size the icon should be displayed by tkinter\n        color (str): the color of the icon\n\n    Returns:\n        Image: the image pointing in that actions direction.\n    \"\"\"\n    return self.get_icon(self.action_mapping[action], size, color)\n</code></pre>"},{"location":"reference/view/icons/load_icon/#src.view.icons.load_icon.IconLoader.get_cell_entity_icon","title":"<code>get_cell_entity_icon(entity, size, color='#fff')</code>","text":"<p>Get the appropriate icon for a given cell entity.</p> <p>Parameters:</p> Name Type Description Default <code>entity</code> <code>CellEntity</code> <p>the entity to represent</p> required <code>size</code> <code>int</code> <p>the size the icon should be displayed by tkinter</p> required <code>color</code> <code>str</code> <p>the color of the icon</p> <code>'#fff'</code> <p>Returns:</p> Name Type Description <code>Image</code> <code>Image</code> <p>the image of this cell entity</p> Source code in <code>src/view/icons/load_icon.py</code> <pre><code>def get_cell_entity_icon(\n    self, entity: CellEntity, size: int, color: str = \"#fff\"\n) -&gt; Image:\n    \"\"\"Get the appropriate icon for a given cell entity.\n\n    Args:\n        entity (CellEntity): the entity to represent\n        size (int): the size the icon should be displayed by tkinter\n        color (str): the color of the icon\n\n    Returns:\n        Image: the image of this cell entity\n    \"\"\"\n    return self.get_icon(self.cell_entity_mapping[entity], size, color)\n</code></pre>"},{"location":"reference/view/icons/load_icon/#src.view.icons.load_icon.IconLoader.get_coloured_icon","title":"<code>get_coloured_icon(image, color)</code>","text":"<p>Convert a black icon to a specific color.</p> <p>sets all non-transparent pixels to the color.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>Image</code> <p>the image to convert,</p> required <code>color</code> <code>str</code> <p>must represent a valid color</p> required <p>Returns:</p> Name Type Description <code>Image</code> <code>Image</code> <p>the image with a white foreground</p> Source code in <code>src/view/icons/load_icon.py</code> <pre><code>def get_coloured_icon(self, image: Image, color: str) -&gt; Image:\n    \"\"\"Convert a black icon to a specific color.\n\n    sets all non-transparent pixels to the color.\n\n    Args:\n        image (Image): the image to convert,\n        color (str): must represent a valid color\n\n    Returns:\n        Image: the image with a white foreground\n    \"\"\"\n    rgb_float = np.array(Color(color).get_rgb())\n\n    np_color = np.floor(rgb_float * self.rgb_component_max).astype(int)\n\n    img_array = np.array(image.convert(\"RGBA\"))\n\n    rgb = img_array[:, :, :3]\n    alpha = img_array[:, :, 3]\n    non_transparent_pixels = alpha != 0\n    # set icon color to wight\n    rgb[non_transparent_pixels] = np_color\n\n    return Pillow.fromarray(img_array)\n</code></pre>"},{"location":"reference/view/icons/load_icon/#src.view.icons.load_icon.IconLoader.get_icon","title":"<code>get_icon(icon, size, color='#fff')</code>","text":"<p>Get the custom tkinter image object for a given icon.</p> <p>Parameters:</p> Name Type Description Default <code>icon</code> <code>Icon</code> <p>the icon to display</p> required <code>size</code> <code>int</code> <p>the size the icon should be displayed by tkinter</p> required <code>color</code> <code>str</code> <p>the color of the icon</p> <code>'#fff'</code> <p>Returns:</p> Name Type Description <code>Image</code> <code>Image</code> <p>the image representing this icon</p> Source code in <code>src/view/icons/load_icon.py</code> <pre><code>def get_icon(self, icon: Icon, size: int, color: str = \"#fff\") -&gt; Image:\n    \"\"\"Get the custom tkinter image object for a given icon.\n\n    Args:\n        icon (Icon): the icon to display\n        size (int): the size the icon should be displayed by tkinter\n        color (str): the color of the icon\n\n    Returns:\n        Image: the image representing this icon\n    \"\"\"\n    size = max(size, 1)\n    cache_key = (icon, size, color)\n    existing_image = self.color_size_cache.get(cache_key, None)\n    if existing_image is not None:\n        return existing_image\n\n    image_raw = self.__get_icon_raw_files(icon)\n\n    coloured_icon = self.get_coloured_icon(image_raw, color)\n    # resize image\n    coloured_icon.thumbnail((size, size))\n\n    self.color_size_cache[cache_key] = coloured_icon\n\n    return coloured_icon\n</code></pre>"},{"location":"reference/view/icons/load_icon/#src.view.icons.load_icon.IconLoader.get_path","title":"<code>get_path(icon)</code>","text":"<p>Get an icon's file path.</p> <p>Parameters:</p> Name Type Description Default <code>icon</code> <code>Icon</code> <p>the icon to find the path for.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>the absolute path to the icon file.</p> Source code in <code>src/view/icons/load_icon.py</code> <pre><code>def get_path(self, icon: Icon) -&gt; str:\n    \"\"\"Get an icon's file path.\n\n    Args:\n        icon (Icon): the icon to find the path for.\n\n    Returns:\n        str: the absolute path to the icon file.\n    \"\"\"\n    return path.abspath(\n        path.join(path.dirname(__file__), f\"{icon.value}.png\")\n    )\n</code></pre>"}]}