{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Final Year Project Documentation","text":"<p>This site contains the documentation for this project, please navigate the reference section in the left panel or use the search tool in the top right.</p> <p>The project consists of three main sections:</p> <ul> <li>Model<ul> <li>This package contains the code for the reinforcement learning models such as the agents and dynamics.</li> </ul> </li> <li>View<ul> <li>This package contains the code for the user interface it displays the state of model and allows the user to interact with it.</li> </ul> </li> <li>Controller<ul> <li>This package contains the code that links the Model and View. </li> </ul> </li> </ul> <p>and two entry points:</p> <ul> <li>Main<ul> <li>This is the main usual entrypoint of the application</li> </ul> </li> <li>Profile<ul> <li>This is a secondary entrypoint that sets up a profiler before starting the application</li> </ul> </li> </ul> <p>This documentation site was generated with mkdocs.</p>"},{"location":"#documentation-commands","title":"Documentation Commands","text":"<p>To start a server that will allow you to see the documentation locally.</p> <pre><code>poetry run mkdocs serve -a localhost:3000\n</code></pre> <p>To make a new build of the documentation locally.</p> <pre><code>poetry run mkdocs build\n</code></pre>"},{"location":"SUMMARY/","title":"SUMMARY","text":"<ul> <li>Reference<ul> <li>Controller<ul> <li>Base Bridge</li> <li>Hyper Parameter Controller<ul> <li>Controller</li> <li>Request Bridge</li> <li>Update Bridge</li> </ul> </li> <li>Learning System Controller<ul> <li>Controller</li> <li>State Update Bridge</li> <li>User Action Bridge</li> <li>User Action Handlers<ul> <li>Auto Progress Handler</li> <li>Base Handler</li> <li>Progress Handler</li> <li>Responsibility Chain</li> <li>Set Options Handler</li> <li>Standard Handler</li> </ul> </li> </ul> </li> </ul> </li> <li>Main</li> <li>Model<ul> <li>Agents<ul> <li>Base Agent</li> <li>Q Learning<ul> <li>Agent</li> <li>Exploration Strategies<ul> <li>Base Strategy</li> <li>Epsilon Greedy Strategy</li> <li>Mf Bpi</li> <li>Options</li> <li>Upper Confidence Bound</li> </ul> </li> </ul> </li> <li>Value Iteration<ul> <li>Agent</li> <li>Agent Optimised</li> <li>Dynamics Distribution</li> <li>Types</li> </ul> </li> </ul> </li> <li>Config<ul> <li>Agent Section<ul> <li>Agent Section</li> <li>Epsilon Greedy</li> <li>Mf Bpi</li> <li>Q Learning</li> <li>Upper Confidence Bound</li> <li>Value Iteration</li> </ul> </li> <li>Base Section</li> <li>Grid World Section</li> <li>Gui Section</li> <li>Reader</li> </ul> </li> <li>Dynamics<ul> <li>Actions</li> <li>Base Dynamics</li> <li>Cliff Dynamics</li> <li>Collection Dynamics</li> <li>Grid World</li> </ul> </li> <li>Hyperparameters<ul> <li>Base Parameter Strategy</li> <li>Config Parameter Strategy</li> <li>Hyper Parameter System</li> <li>Parameter Evaluator</li> <li>Random Search<ul> <li>Random Parameter Strategy</li> <li>Random Search</li> <li>Random Search Data</li> </ul> </li> <li>Report Generation<ul> <li>Compute Confidence Interval</li> <li>Report Data</li> <li>Report Generator</li> <li>Tuning Parameter Strategy</li> </ul> </li> <li>Tuning Information</li> </ul> </li> <li>Learning System<ul> <li>Base Entity Decorator</li> <li>Cell Configuration<ul> <li>Cell Configuration</li> <li>Cell Configuration Factory</li> <li>Cell State Lookup</li> </ul> </li> <li>Global Options</li> <li>Learning Instance<ul> <li>Learning Instance</li> <li>Statistics Record</li> <li>Statistics Recorder</li> </ul> </li> <li>Learning System</li> <li>State Description<ul> <li>State Description</li> <li>State Description Factory</li> </ul> </li> <li>Top Level Entities<ul> <li>Cache</li> <li>Container</li> <li>Factory</li> <li>Options</li> </ul> </li> <li>Value Standardisation<ul> <li>Normaliser</li> <li>Normaliser Factory</li> <li>Value Range</li> </ul> </li> </ul> </li> <li>State<ul> <li>Cell Entities</li> <li>State Builder</li> <li>State Instance</li> <li>State Pool</li> </ul> </li> <li>Transition Information</li> </ul> </li> <li>Profile</li> <li>View<ul> <li>Controls<ul> <li>Control Factory</li> <li>Custom Button Widget</li> <li>Custom Combo Widget</li> </ul> </li> <li>Display State V2<ul> <li>Cell<ul> <li>Arrow Layer</li> <li>Background Layer</li> <li>Base Layer</li> <li>Cell</li> <li>Cell Layout</li> <li>Main Icon Layer</li> </ul> </li> <li>Display</li> </ul> </li> <li>Icons<ul> <li>Load Icon</li> </ul> </li> <li>Interaction Controls</li> <li>Main Tab Area</li> <li>Option Controls</li> <li>Option Display Text</li> <li>Report State Publisher</li> <li>State Publisher</li> <li>Statistics<ul> <li>Matplotlib Setup</li> <li>Plotting</li> <li>Report Display<ul> <li>Progress Indicator</li> <li>Report Container</li> <li>Report Information Display</li> <li>Report Selector</li> </ul> </li> <li>Reward History</li> <li>Search Results<ul> <li>Container</li> <li>Display</li> <li>Start Button</li> </ul> </li> </ul> </li> <li>View Root V2</li> <li>Visibility Observer</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/","title":"Reference","text":"<p>This package contains the source code to the project.</p>"},{"location":"reference/main/","title":"Main","text":""},{"location":"reference/main/#src.main.main","title":"<code>main()</code>","text":"<p>Start the application.</p> <p>The main entry point into the application.</p> Source code in <code>src/main.py</code> <pre><code>def main():\n    \"\"\"Start the application.\n\n    The main entry point into the application.\n    \"\"\"\n    with LearningSystemController() as main_controller:\n        with HyperParameterController() as report_controller:\n            qt = QApplication(sys.argv)\n            app = ReinforcementLearningApp(main_controller, report_controller)\n            app.show()\n            qt.exec()\n</code></pre>"},{"location":"reference/profile/","title":"Profile","text":""},{"location":"reference/profile/#src.profile.end_to_end_profiling","title":"<code>end_to_end_profiling()</code>","text":"<p>Run the profiled code.</p> <p>The code in this method will be profiled by the application.</p> Source code in <code>src/profile.py</code> <pre><code>def end_to_end_profiling():\n    \"\"\"Run the profiled code.\n\n    The code in this method will be profiled by the application.\n    \"\"\"\n    with LearningSystemController() as main_controller:\n        with HyperParameterController() as report_controller:\n            main_controller.user_action_bridge.submit_action(\n                UserAction.select_auto, AutomaticOptions.automatic_playing\n            )\n            qt = QApplication()\n            app = ReinforcementLearningApp(main_controller, report_controller)\n            app.show()\n            qt.exec()\n</code></pre>"},{"location":"reference/profile/#src.profile.one_process_profiling","title":"<code>one_process_profiling()</code>","text":"<p>Run the profiled code.</p> <p>The code in this method will be profiled by the application.</p> Source code in <code>src/profile.py</code> <pre><code>def one_process_profiling():\n    \"\"\"Run the profiled code.\n\n    The code in this method will be profiled by the application.\n    \"\"\"\n    ls = LearningSystem()\n    top_level_options = TopEntitiesOptions(\n        AgentOptions.value_iteration_optimised,\n        DynamicsOptions.collection,\n        ExplorationStrategyOptions.not_applicable,\n    )\n    ls.update_options(\n        GlobalOptions(\n            top_level_options,\n            DisplayMode.state_value,\n            AutomaticOptions.automatic_playing,\n        )\n    )\n\n    qt = QApplication()\n    display_state = DisplayState(None)\n    display_state.show()\n    display_state.resize(application_size, application_size)\n\n    def loop():\n        cs = ls.get_current_state()\n        display_state.visible_state_updated(cs)\n        ls.learning_instance.perform_action()\n\n    timer = QTimer(display_state)\n    timer.timeout.connect(loop)\n    timer.start(1)\n    qt.exec()\n</code></pre>"},{"location":"reference/profile/#src.profile.profile","title":"<code>profile()</code>","text":"<p>Entry point for profiling the application.</p> Source code in <code>src/profile.py</code> <pre><code>def profile():\n    \"\"\"Entry point for profiling the application.\"\"\"\n    profiler = cProfile.Profile()\n    profiler.enable()\n    try:\n        profiled_code()\n    finally:\n        profiler.disable()\n        ps = pstats.Stats(profiler)\n        ps.dump_stats(\"profile_result.prof\")\n</code></pre>"},{"location":"reference/profile/#src.profile.profiled_code","title":"<code>profiled_code()</code>","text":"<p>Run the profiled code.</p> <p>The code in this method will be profiled by the application.</p> Source code in <code>src/profile.py</code> <pre><code>def profiled_code():\n    \"\"\"Run the profiled code.\n\n    The code in this method will be profiled by the application.\n    \"\"\"\n    rs = RandomSearch()\n    rs.running.set(True)\n    seed(10)\n    for i in range(5):\n        print(i)\n        for options in rs.search_options:\n            if not rs.running.get():\n                return\n            hyper_parameters = RandomParameterStrategy()\n\n            total_reward = ParameterEvaluator.evaluate_reward(\n                options, hyper_parameters, rs.running\n            )\n\n            if not rs.running.get():\n                return\n\n            with rs.state_lock:\n                state = rs.state.get()\n                rs.state.set(\n                    state.record_result(options, hyper_parameters, total_reward)\n                )\n</code></pre>"},{"location":"reference/controller/","title":"Controller","text":"<p>This package contains the controllers.</p> <p>These act as the bridge between the view and the model</p>"},{"location":"reference/controller/base_bridge/","title":"Base Bridge","text":""},{"location":"reference/controller/base_bridge/#src.controller.base_bridge.BaseBridge","title":"<code>BaseBridge</code>","text":"<p>             Bases: <code>object</code></p> <p>Bases class that represents a bridge between two processes.</p> Source code in <code>src/controller/base_bridge.py</code> <pre><code>class BaseBridge(object):\n    \"\"\"Bases class that represents a bridge between two processes.\"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialise a bridge.\"\"\"\n        manager = Manager()\n        self.state_lock = manager.Lock()\n        self.port = manager.Value(int, 0)\n        self.state = manager.Value(BridgeState, BridgeState.none)\n        self.socket = None\n\n    def add_item(self, queue_item: Any):\n        \"\"\"Add item to the queue, not blocking.\n\n        Args:\n            queue_item (Any): The item to be added.\n        \"\"\"\n        self.__get_socket().send_pyobj(queue_item)\n\n    def get_item_blocking(self) -&gt; Any:\n        \"\"\"Get the next item in the queue while blocking.\n\n        Returns:\n            Any: the next item.\n        \"\"\"\n        return self.__get_socket().recv_pyobj()\n\n    def get_item_non_blocking(self) -&gt; Any:\n        \"\"\"Get the latest item on the queue.\n\n        Returns:\n            Any: the latest item. None if the queue is empty\n        \"\"\"\n        try:\n            return self.__get_socket().recv_pyobj(NOBLOCK)\n        except Again:\n            return None\n\n    def __get_socket(self):\n        if self.socket is not None:\n            return self.socket\n\n        with self.state_lock:\n            match self.state.get():\n                case BridgeState.none:\n                    self.socket = Context().socket(PAIR)\n                    port = self.socket.bind_to_random_port(\"tcp://*\")\n                    self.port.set(port)\n                    self.state.set(BridgeState.port_bound)\n                case BridgeState.port_bound:\n                    self.socket = Context().socket(PAIR)\n                    self.socket.connect(f\"tcp://localhost:{self.port.get()}\")\n                    self.state.set(BridgeState.connected)\n                case BridgeState.connected:\n                    raise RuntimeError(\"connected while missing bridge end\")\n\n        return self.socket\n</code></pre>"},{"location":"reference/controller/base_bridge/#src.controller.base_bridge.BaseBridge.__init__","title":"<code>__init__()</code>","text":"<p>Initialise a bridge.</p> Source code in <code>src/controller/base_bridge.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialise a bridge.\"\"\"\n    manager = Manager()\n    self.state_lock = manager.Lock()\n    self.port = manager.Value(int, 0)\n    self.state = manager.Value(BridgeState, BridgeState.none)\n    self.socket = None\n</code></pre>"},{"location":"reference/controller/base_bridge/#src.controller.base_bridge.BaseBridge.add_item","title":"<code>add_item(queue_item)</code>","text":"<p>Add item to the queue, not blocking.</p> <p>Parameters:</p> Name Type Description Default <code>queue_item</code> <code>Any</code> <p>The item to be added.</p> required Source code in <code>src/controller/base_bridge.py</code> <pre><code>def add_item(self, queue_item: Any):\n    \"\"\"Add item to the queue, not blocking.\n\n    Args:\n        queue_item (Any): The item to be added.\n    \"\"\"\n    self.__get_socket().send_pyobj(queue_item)\n</code></pre>"},{"location":"reference/controller/base_bridge/#src.controller.base_bridge.BaseBridge.get_item_blocking","title":"<code>get_item_blocking()</code>","text":"<p>Get the next item in the queue while blocking.</p> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>the next item.</p> Source code in <code>src/controller/base_bridge.py</code> <pre><code>def get_item_blocking(self) -&gt; Any:\n    \"\"\"Get the next item in the queue while blocking.\n\n    Returns:\n        Any: the next item.\n    \"\"\"\n    return self.__get_socket().recv_pyobj()\n</code></pre>"},{"location":"reference/controller/base_bridge/#src.controller.base_bridge.BaseBridge.get_item_non_blocking","title":"<code>get_item_non_blocking()</code>","text":"<p>Get the latest item on the queue.</p> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>the latest item. None if the queue is empty</p> Source code in <code>src/controller/base_bridge.py</code> <pre><code>def get_item_non_blocking(self) -&gt; Any:\n    \"\"\"Get the latest item on the queue.\n\n    Returns:\n        Any: the latest item. None if the queue is empty\n    \"\"\"\n    try:\n        return self.__get_socket().recv_pyobj(NOBLOCK)\n    except Again:\n        return None\n</code></pre>"},{"location":"reference/controller/base_bridge/#src.controller.base_bridge.BridgeState","title":"<code>BridgeState</code>","text":"<p>             Bases: <code>Enum</code></p> <p>Enumerates the possible connection states of the bridge.</p> Source code in <code>src/controller/base_bridge.py</code> <pre><code>class BridgeState(Enum):\n    \"\"\"Enumerates the possible connection states of the bridge.\"\"\"\n\n    none = 0\n    port_bound = 1\n    connected = 2\n</code></pre>"},{"location":"reference/controller/hyper_parameter_controller/","title":"Hyper Parameter Controller","text":"<p>This package contains the controller for the report generation.</p> <p>This controller is separate due to its long running nature so it can avoid blocking the traditional functionality.</p>"},{"location":"reference/controller/hyper_parameter_controller/controller/","title":"Controller","text":""},{"location":"reference/controller/hyper_parameter_controller/controller/#src.controller.hyper_parameter_controller.controller.HyperParameterController","title":"<code>HyperParameterController</code>","text":"<p>             Bases: <code>object</code></p> <p>Controller for managing the hyper parameter functionality.</p> Source code in <code>src/controller/hyper_parameter_controller/controller.py</code> <pre><code>class HyperParameterController(object):\n    \"\"\"Controller for managing the hyper parameter functionality.\"\"\"\n\n    minimum_update_delta_seconds = 0.3\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialise the learning system controller.\"\"\"\n        self.system = HyperParameterSystem()\n\n        self.request_bridge = HyperParameterRequestBridge()\n        self.update_bridge = HyperParameterUpdateBridge()\n\n        self.report_process: Optional[Process] = None\n\n        self.last_update_timestamp = time()\n\n    def __enter__(self) -&gt; Self:\n        \"\"\"Enter the context manager.\n\n        the context manager is used for cleaning up processes gracefully.\n\n        Returns:\n            Self: the factory.\n        \"\"\"\n        self.report_process = Process(\n            target=self.report_mainloop, name=\"report_mainloop\"\n        )\n        self.report_process.start()\n        return self\n\n    def __exit__(self, exc_type, exc_value, exc_tb) -&gt; None:\n        \"\"\"Exit the context, clean up the resources.\n\n        Args:\n            exc_type (Any): Not used.\n            exc_value (Any): Not used.\n            exc_tb (Any): Not used.\n        \"\"\"\n        self.request_bridge.request_shutdown()\n        if self.report_process is not None:\n            self.report_process.join()\n\n    def report_mainloop(\n        self,\n    ):\n        \"\"\"Run the main loop of the report generation process.\n\n        Raises:\n            RuntimeError: if an unsupported request is made.\n        \"\"\"\n        request_bridge = self.request_bridge\n        report_generator = self.system.report_generator\n        random_search = self.system.random_search\n\n        # used to keep track if there is new completed work to display\n        work_was_in_progress = False\n        while True:\n            work_in_progress = self.send_progress_update()\n\n            completed_work = not work_in_progress and work_was_in_progress\n            work_was_in_progress = work_in_progress\n            if completed_work:\n                self.send_current_state()\n\n            message = None\n            if work_in_progress:\n                message = request_bridge.get_request()\n            else:\n                message = request_bridge.get_request_blocking()\n\n            match message:\n                case None:\n                    continue\n                case ReportRequestMessage(request=HyperParameterRequest.end):\n                    self.system.shutdown()\n                    break\n                case ReportRequestMessage(\n                    request=HyperParameterRequest.generate_report,\n                    payload=parameter,\n                ):\n                    report_generator.generate_report(parameter)\n                    self.send_current_state()\n                case ReportRequestMessage(\n                    request=HyperParameterRequest.fetch_current_state\n                ):\n                    self.send_current_state()\n                case ReportRequestMessage(\n                    request=HyperParameterRequest.set_searching_state,\n                    payload=True,\n                ):\n                    random_search.start_search()\n                case ReportRequestMessage(\n                    request=HyperParameterRequest.set_searching_state,\n                    payload=False,\n                ):\n                    random_search.stop_search()\n                case _:\n                    raise RuntimeError(\"Unsupported report request.\")\n\n    def send_progress_update(self) -&gt; bool:\n        \"\"\"Send progress updates to the user if they are warranted.\n\n        A progress update is required when it has been long enough from the last\n        one and there is some work in progress.\n\n        Returns:\n            bool: weather there is work in progress\n        \"\"\"\n        state = self.system.get_state()\n\n        report_in_progress = bool(state.report.pending_requests)\n        search_in_progress = state.search.searching\n\n        work_in_progress = report_in_progress or search_in_progress\n\n        next_update = (\n            self.last_update_timestamp + self.minimum_update_delta_seconds\n        )\n\n        if time() &lt; next_update:\n            return work_in_progress\n\n        if work_in_progress:\n            # send progress update\n            self.send_current_state()\n\n        return work_in_progress\n\n    def send_current_state(self):\n        \"\"\"Send the current state to the view.\"\"\"\n        self.last_update_timestamp = time()\n        current_state = self.system.get_state()\n        self.update_bridge.update_state(current_state)\n</code></pre>"},{"location":"reference/controller/hyper_parameter_controller/controller/#src.controller.hyper_parameter_controller.controller.HyperParameterController.__enter__","title":"<code>__enter__()</code>","text":"<p>Enter the context manager.</p> <p>the context manager is used for cleaning up processes gracefully.</p> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>the factory.</p> Source code in <code>src/controller/hyper_parameter_controller/controller.py</code> <pre><code>def __enter__(self) -&gt; Self:\n    \"\"\"Enter the context manager.\n\n    the context manager is used for cleaning up processes gracefully.\n\n    Returns:\n        Self: the factory.\n    \"\"\"\n    self.report_process = Process(\n        target=self.report_mainloop, name=\"report_mainloop\"\n    )\n    self.report_process.start()\n    return self\n</code></pre>"},{"location":"reference/controller/hyper_parameter_controller/controller/#src.controller.hyper_parameter_controller.controller.HyperParameterController.__exit__","title":"<code>__exit__(exc_type, exc_value, exc_tb)</code>","text":"<p>Exit the context, clean up the resources.</p> <p>Parameters:</p> Name Type Description Default <code>exc_type</code> <code>Any</code> <p>Not used.</p> required <code>exc_value</code> <code>Any</code> <p>Not used.</p> required <code>exc_tb</code> <code>Any</code> <p>Not used.</p> required Source code in <code>src/controller/hyper_parameter_controller/controller.py</code> <pre><code>def __exit__(self, exc_type, exc_value, exc_tb) -&gt; None:\n    \"\"\"Exit the context, clean up the resources.\n\n    Args:\n        exc_type (Any): Not used.\n        exc_value (Any): Not used.\n        exc_tb (Any): Not used.\n    \"\"\"\n    self.request_bridge.request_shutdown()\n    if self.report_process is not None:\n        self.report_process.join()\n</code></pre>"},{"location":"reference/controller/hyper_parameter_controller/controller/#src.controller.hyper_parameter_controller.controller.HyperParameterController.__init__","title":"<code>__init__()</code>","text":"<p>Initialise the learning system controller.</p> Source code in <code>src/controller/hyper_parameter_controller/controller.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialise the learning system controller.\"\"\"\n    self.system = HyperParameterSystem()\n\n    self.request_bridge = HyperParameterRequestBridge()\n    self.update_bridge = HyperParameterUpdateBridge()\n\n    self.report_process: Optional[Process] = None\n\n    self.last_update_timestamp = time()\n</code></pre>"},{"location":"reference/controller/hyper_parameter_controller/controller/#src.controller.hyper_parameter_controller.controller.HyperParameterController.report_mainloop","title":"<code>report_mainloop()</code>","text":"<p>Run the main loop of the report generation process.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if an unsupported request is made.</p> Source code in <code>src/controller/hyper_parameter_controller/controller.py</code> <pre><code>def report_mainloop(\n    self,\n):\n    \"\"\"Run the main loop of the report generation process.\n\n    Raises:\n        RuntimeError: if an unsupported request is made.\n    \"\"\"\n    request_bridge = self.request_bridge\n    report_generator = self.system.report_generator\n    random_search = self.system.random_search\n\n    # used to keep track if there is new completed work to display\n    work_was_in_progress = False\n    while True:\n        work_in_progress = self.send_progress_update()\n\n        completed_work = not work_in_progress and work_was_in_progress\n        work_was_in_progress = work_in_progress\n        if completed_work:\n            self.send_current_state()\n\n        message = None\n        if work_in_progress:\n            message = request_bridge.get_request()\n        else:\n            message = request_bridge.get_request_blocking()\n\n        match message:\n            case None:\n                continue\n            case ReportRequestMessage(request=HyperParameterRequest.end):\n                self.system.shutdown()\n                break\n            case ReportRequestMessage(\n                request=HyperParameterRequest.generate_report,\n                payload=parameter,\n            ):\n                report_generator.generate_report(parameter)\n                self.send_current_state()\n            case ReportRequestMessage(\n                request=HyperParameterRequest.fetch_current_state\n            ):\n                self.send_current_state()\n            case ReportRequestMessage(\n                request=HyperParameterRequest.set_searching_state,\n                payload=True,\n            ):\n                random_search.start_search()\n            case ReportRequestMessage(\n                request=HyperParameterRequest.set_searching_state,\n                payload=False,\n            ):\n                random_search.stop_search()\n            case _:\n                raise RuntimeError(\"Unsupported report request.\")\n</code></pre>"},{"location":"reference/controller/hyper_parameter_controller/controller/#src.controller.hyper_parameter_controller.controller.HyperParameterController.send_current_state","title":"<code>send_current_state()</code>","text":"<p>Send the current state to the view.</p> Source code in <code>src/controller/hyper_parameter_controller/controller.py</code> <pre><code>def send_current_state(self):\n    \"\"\"Send the current state to the view.\"\"\"\n    self.last_update_timestamp = time()\n    current_state = self.system.get_state()\n    self.update_bridge.update_state(current_state)\n</code></pre>"},{"location":"reference/controller/hyper_parameter_controller/controller/#src.controller.hyper_parameter_controller.controller.HyperParameterController.send_progress_update","title":"<code>send_progress_update()</code>","text":"<p>Send progress updates to the user if they are warranted.</p> <p>A progress update is required when it has been long enough from the last one and there is some work in progress.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>weather there is work in progress</p> Source code in <code>src/controller/hyper_parameter_controller/controller.py</code> <pre><code>def send_progress_update(self) -&gt; bool:\n    \"\"\"Send progress updates to the user if they are warranted.\n\n    A progress update is required when it has been long enough from the last\n    one and there is some work in progress.\n\n    Returns:\n        bool: weather there is work in progress\n    \"\"\"\n    state = self.system.get_state()\n\n    report_in_progress = bool(state.report.pending_requests)\n    search_in_progress = state.search.searching\n\n    work_in_progress = report_in_progress or search_in_progress\n\n    next_update = (\n        self.last_update_timestamp + self.minimum_update_delta_seconds\n    )\n\n    if time() &lt; next_update:\n        return work_in_progress\n\n    if work_in_progress:\n        # send progress update\n        self.send_current_state()\n\n    return work_in_progress\n</code></pre>"},{"location":"reference/controller/hyper_parameter_controller/request_bridge/","title":"Request Bridge","text":""},{"location":"reference/controller/hyper_parameter_controller/request_bridge/#src.controller.hyper_parameter_controller.request_bridge.HyperParameterRequest","title":"<code>HyperParameterRequest</code>","text":"<p>             Bases: <code>Enum</code></p> <p>Enumerate all possible user actions.</p> Source code in <code>src/controller/hyper_parameter_controller/request_bridge.py</code> <pre><code>class HyperParameterRequest(Enum):\n    \"\"\"Enumerate all possible user actions.\"\"\"\n\n    end = 0\n    generate_report = 1\n    fetch_current_state = 2\n    set_searching_state = 3\n</code></pre>"},{"location":"reference/controller/hyper_parameter_controller/request_bridge/#src.controller.hyper_parameter_controller.request_bridge.HyperParameterRequestBridge","title":"<code>HyperParameterRequestBridge</code>","text":"<p>             Bases: <code>BaseBridge</code></p> <p>Bridge for passing the report requests from the view to the model.</p> Source code in <code>src/controller/hyper_parameter_controller/request_bridge.py</code> <pre><code>class HyperParameterRequestBridge(BaseBridge):\n    \"\"\"Bridge for passing the report requests from the view to the model.\"\"\"\n\n    def request_current_state(self) -&gt; None:\n        \"\"\"Request to receive the current state.\"\"\"\n        self.add_item(\n            ReportRequestMessage(HyperParameterRequest.fetch_current_state)\n        )\n\n    def request_shutdown(self) -&gt; None:\n        \"\"\"Request to shutdown the report generator.\"\"\"\n        self.add_item(ReportRequestMessage(HyperParameterRequest.end))\n\n    def request_report(self, parameter: HyperParameter) -&gt; None:\n        \"\"\"Request report from the generator.\n\n        Args:\n            parameter (HyperParameter): the hyper-parameter to generate a\n                report for.\n        \"\"\"\n        self.add_item(\n            ReportRequestMessage(\n                HyperParameterRequest.generate_report, parameter\n            )\n        )\n\n    def set_search_state(self, running: bool) -&gt; None:\n        \"\"\"Request to set the searching state.\n\n        Args:\n            running (bool): the new search state.\n        \"\"\"\n        self.add_item(\n            ReportRequestMessage(\n                HyperParameterRequest.set_searching_state, running\n            )\n        )\n\n    def get_request(self) -&gt; Optional[ReportRequestMessage]:\n        \"\"\"Get the latest requested report if there is one.\n\n        Returns:\n            Optional[ReportRequestMessage]: the latest request, None if no\n                request has been made.\n        \"\"\"\n        return self.get_item_non_blocking()\n\n    def get_request_blocking(self) -&gt; ReportRequestMessage:\n        \"\"\"Get the latest request, block until a request is made.\n\n        can be used while there is no pending requests to avoid computation.\n\n        Returns:\n            ReportRequestMessage: the latest request.\n        \"\"\"\n        return self.get_item_blocking()\n</code></pre>"},{"location":"reference/controller/hyper_parameter_controller/request_bridge/#src.controller.hyper_parameter_controller.request_bridge.HyperParameterRequestBridge.get_request","title":"<code>get_request()</code>","text":"<p>Get the latest requested report if there is one.</p> <p>Returns:</p> Type Description <code>Optional[ReportRequestMessage]</code> <p>Optional[ReportRequestMessage]: the latest request, None if no request has been made.</p> Source code in <code>src/controller/hyper_parameter_controller/request_bridge.py</code> <pre><code>def get_request(self) -&gt; Optional[ReportRequestMessage]:\n    \"\"\"Get the latest requested report if there is one.\n\n    Returns:\n        Optional[ReportRequestMessage]: the latest request, None if no\n            request has been made.\n    \"\"\"\n    return self.get_item_non_blocking()\n</code></pre>"},{"location":"reference/controller/hyper_parameter_controller/request_bridge/#src.controller.hyper_parameter_controller.request_bridge.HyperParameterRequestBridge.get_request_blocking","title":"<code>get_request_blocking()</code>","text":"<p>Get the latest request, block until a request is made.</p> <p>can be used while there is no pending requests to avoid computation.</p> <p>Returns:</p> Name Type Description <code>ReportRequestMessage</code> <code>ReportRequestMessage</code> <p>the latest request.</p> Source code in <code>src/controller/hyper_parameter_controller/request_bridge.py</code> <pre><code>def get_request_blocking(self) -&gt; ReportRequestMessage:\n    \"\"\"Get the latest request, block until a request is made.\n\n    can be used while there is no pending requests to avoid computation.\n\n    Returns:\n        ReportRequestMessage: the latest request.\n    \"\"\"\n    return self.get_item_blocking()\n</code></pre>"},{"location":"reference/controller/hyper_parameter_controller/request_bridge/#src.controller.hyper_parameter_controller.request_bridge.HyperParameterRequestBridge.request_current_state","title":"<code>request_current_state()</code>","text":"<p>Request to receive the current state.</p> Source code in <code>src/controller/hyper_parameter_controller/request_bridge.py</code> <pre><code>def request_current_state(self) -&gt; None:\n    \"\"\"Request to receive the current state.\"\"\"\n    self.add_item(\n        ReportRequestMessage(HyperParameterRequest.fetch_current_state)\n    )\n</code></pre>"},{"location":"reference/controller/hyper_parameter_controller/request_bridge/#src.controller.hyper_parameter_controller.request_bridge.HyperParameterRequestBridge.request_report","title":"<code>request_report(parameter)</code>","text":"<p>Request report from the generator.</p> <p>Parameters:</p> Name Type Description Default <code>parameter</code> <code>HyperParameter</code> <p>the hyper-parameter to generate a report for.</p> required Source code in <code>src/controller/hyper_parameter_controller/request_bridge.py</code> <pre><code>def request_report(self, parameter: HyperParameter) -&gt; None:\n    \"\"\"Request report from the generator.\n\n    Args:\n        parameter (HyperParameter): the hyper-parameter to generate a\n            report for.\n    \"\"\"\n    self.add_item(\n        ReportRequestMessage(\n            HyperParameterRequest.generate_report, parameter\n        )\n    )\n</code></pre>"},{"location":"reference/controller/hyper_parameter_controller/request_bridge/#src.controller.hyper_parameter_controller.request_bridge.HyperParameterRequestBridge.request_shutdown","title":"<code>request_shutdown()</code>","text":"<p>Request to shutdown the report generator.</p> Source code in <code>src/controller/hyper_parameter_controller/request_bridge.py</code> <pre><code>def request_shutdown(self) -&gt; None:\n    \"\"\"Request to shutdown the report generator.\"\"\"\n    self.add_item(ReportRequestMessage(HyperParameterRequest.end))\n</code></pre>"},{"location":"reference/controller/hyper_parameter_controller/request_bridge/#src.controller.hyper_parameter_controller.request_bridge.HyperParameterRequestBridge.set_search_state","title":"<code>set_search_state(running)</code>","text":"<p>Request to set the searching state.</p> <p>Parameters:</p> Name Type Description Default <code>running</code> <code>bool</code> <p>the new search state.</p> required Source code in <code>src/controller/hyper_parameter_controller/request_bridge.py</code> <pre><code>def set_search_state(self, running: bool) -&gt; None:\n    \"\"\"Request to set the searching state.\n\n    Args:\n        running (bool): the new search state.\n    \"\"\"\n    self.add_item(\n        ReportRequestMessage(\n            HyperParameterRequest.set_searching_state, running\n        )\n    )\n</code></pre>"},{"location":"reference/controller/hyper_parameter_controller/request_bridge/#src.controller.hyper_parameter_controller.request_bridge.ReportRequestMessage","title":"<code>ReportRequestMessage</code>  <code>dataclass</code>","text":"<p>             Bases: <code>object</code></p> <p>Encapsulates a user action and its data.</p> Source code in <code>src/controller/hyper_parameter_controller/request_bridge.py</code> <pre><code>@dataclass(frozen=True, slots=True)\nclass ReportRequestMessage(object):\n    \"\"\"Encapsulates a user action and its data.\"\"\"\n\n    request: HyperParameterRequest\n    payload: Any = None\n</code></pre>"},{"location":"reference/controller/hyper_parameter_controller/update_bridge/","title":"Update Bridge","text":""},{"location":"reference/controller/hyper_parameter_controller/update_bridge/#src.controller.hyper_parameter_controller.update_bridge.HyperParameterUpdateBridge","title":"<code>HyperParameterUpdateBridge</code>","text":"<p>             Bases: <code>BaseBridge</code></p> <p>Bridge for passing report updates to the view.</p> Source code in <code>src/controller/hyper_parameter_controller/update_bridge.py</code> <pre><code>class HyperParameterUpdateBridge(BaseBridge):\n    \"\"\"Bridge for passing report updates to the view.\"\"\"\n\n    def update_state(self, state: HyperParameterState):\n        \"\"\"Set the new state to be displayed.\n\n        Args:\n            state (HyperParameterState): The new hyper parameter state.\n        \"\"\"\n        self.add_item(state)\n\n    def get_latest_state(self) -&gt; Optional[HyperParameterState]:\n        \"\"\"Get the last (most recent) new report state.\n\n        Returns:\n            Optional[HyperParameterState]: the new state, none if there has not\n                been any changes.\n        \"\"\"\n        latest_state = None\n        state = self.get_item_non_blocking()\n        while state is not None:\n            latest_state = state\n            state = self.get_item_non_blocking()\n        return latest_state\n</code></pre>"},{"location":"reference/controller/hyper_parameter_controller/update_bridge/#src.controller.hyper_parameter_controller.update_bridge.HyperParameterUpdateBridge.get_latest_state","title":"<code>get_latest_state()</code>","text":"<p>Get the last (most recent) new report state.</p> <p>Returns:</p> Type Description <code>Optional[HyperParameterState]</code> <p>Optional[HyperParameterState]: the new state, none if there has not been any changes.</p> Source code in <code>src/controller/hyper_parameter_controller/update_bridge.py</code> <pre><code>def get_latest_state(self) -&gt; Optional[HyperParameterState]:\n    \"\"\"Get the last (most recent) new report state.\n\n    Returns:\n        Optional[HyperParameterState]: the new state, none if there has not\n            been any changes.\n    \"\"\"\n    latest_state = None\n    state = self.get_item_non_blocking()\n    while state is not None:\n        latest_state = state\n        state = self.get_item_non_blocking()\n    return latest_state\n</code></pre>"},{"location":"reference/controller/hyper_parameter_controller/update_bridge/#src.controller.hyper_parameter_controller.update_bridge.HyperParameterUpdateBridge.update_state","title":"<code>update_state(state)</code>","text":"<p>Set the new state to be displayed.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>HyperParameterState</code> <p>The new hyper parameter state.</p> required Source code in <code>src/controller/hyper_parameter_controller/update_bridge.py</code> <pre><code>def update_state(self, state: HyperParameterState):\n    \"\"\"Set the new state to be displayed.\n\n    Args:\n        state (HyperParameterState): The new hyper parameter state.\n    \"\"\"\n    self.add_item(state)\n</code></pre>"},{"location":"reference/controller/learning_system_controller/","title":"Learning System Controller","text":"<p>This package contains the main controller.</p>"},{"location":"reference/controller/learning_system_controller/controller/","title":"Controller","text":""},{"location":"reference/controller/learning_system_controller/controller/#src.controller.learning_system_controller.controller.LearningSystemController","title":"<code>LearningSystemController</code>","text":"<p>             Bases: <code>object</code></p> <p>Controller for managing learning systems.</p> Source code in <code>src/controller/learning_system_controller/controller.py</code> <pre><code>class LearningSystemController(object):\n    \"\"\"Controller for managing learning systems.\"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialise the learning system controller.\"\"\"\n        self.system = LearningSystem()\n\n        self.user_action_bridge = UserActionBridge()\n        self.state_update_bridge = StateUpdateBridge()\n\n        self.model_process: Optional[Process] = None\n\n    def __enter__(self) -&gt; Self:\n        \"\"\"Enter the context manager.\n\n        the context manager is used for cleaning up processes gracefully.\n\n        Returns:\n            Self: the factory.\n        \"\"\"\n        self.model_process = Process(\n            target=self.model_mainloop, name=\"model_mainloop\", daemon=True\n        )\n        self.model_process.start()\n        return self\n\n    def __exit__(self, exc_type, exc_value, exc_tb) -&gt; None:\n        \"\"\"Exit the context, clean up the resources.\n\n        Args:\n            exc_type (Any): Not used.\n            exc_value (Any): Not used.\n            exc_tb (Any): Not used.\n        \"\"\"\n        self.user_action_bridge.submit_action(UserAction.end)\n        if self.model_process is not None:\n            self.model_process.join()\n\n    def model_mainloop(\n        self,\n    ):\n        \"\"\"Run the main loop of the model process.\n\n        Raises:\n            RuntimeError: if an unsupported action is made.\n        \"\"\"\n        user_action_bridge = self.user_action_bridge\n        chain = UserActionResponsibilityChain(self.system)\n        while True:\n            message = user_action_bridge.get_action_non_blocking()\n\n            if message is None:\n                if chain.handle_inaction():\n                    self.send_current_state()\n            else:\n                if message.action is UserAction.end:\n                    break\n                chain.handle_user_action(message)\n                self.send_current_state()\n\n    def send_current_state(self):\n        \"\"\"Send the current state to the view.\"\"\"\n        current_state = self.system.get_current_state()\n        self.state_update_bridge.update_state(current_state)\n</code></pre>"},{"location":"reference/controller/learning_system_controller/controller/#src.controller.learning_system_controller.controller.LearningSystemController.__enter__","title":"<code>__enter__()</code>","text":"<p>Enter the context manager.</p> <p>the context manager is used for cleaning up processes gracefully.</p> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>the factory.</p> Source code in <code>src/controller/learning_system_controller/controller.py</code> <pre><code>def __enter__(self) -&gt; Self:\n    \"\"\"Enter the context manager.\n\n    the context manager is used for cleaning up processes gracefully.\n\n    Returns:\n        Self: the factory.\n    \"\"\"\n    self.model_process = Process(\n        target=self.model_mainloop, name=\"model_mainloop\", daemon=True\n    )\n    self.model_process.start()\n    return self\n</code></pre>"},{"location":"reference/controller/learning_system_controller/controller/#src.controller.learning_system_controller.controller.LearningSystemController.__exit__","title":"<code>__exit__(exc_type, exc_value, exc_tb)</code>","text":"<p>Exit the context, clean up the resources.</p> <p>Parameters:</p> Name Type Description Default <code>exc_type</code> <code>Any</code> <p>Not used.</p> required <code>exc_value</code> <code>Any</code> <p>Not used.</p> required <code>exc_tb</code> <code>Any</code> <p>Not used.</p> required Source code in <code>src/controller/learning_system_controller/controller.py</code> <pre><code>def __exit__(self, exc_type, exc_value, exc_tb) -&gt; None:\n    \"\"\"Exit the context, clean up the resources.\n\n    Args:\n        exc_type (Any): Not used.\n        exc_value (Any): Not used.\n        exc_tb (Any): Not used.\n    \"\"\"\n    self.user_action_bridge.submit_action(UserAction.end)\n    if self.model_process is not None:\n        self.model_process.join()\n</code></pre>"},{"location":"reference/controller/learning_system_controller/controller/#src.controller.learning_system_controller.controller.LearningSystemController.__init__","title":"<code>__init__()</code>","text":"<p>Initialise the learning system controller.</p> Source code in <code>src/controller/learning_system_controller/controller.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialise the learning system controller.\"\"\"\n    self.system = LearningSystem()\n\n    self.user_action_bridge = UserActionBridge()\n    self.state_update_bridge = StateUpdateBridge()\n\n    self.model_process: Optional[Process] = None\n</code></pre>"},{"location":"reference/controller/learning_system_controller/controller/#src.controller.learning_system_controller.controller.LearningSystemController.model_mainloop","title":"<code>model_mainloop()</code>","text":"<p>Run the main loop of the model process.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if an unsupported action is made.</p> Source code in <code>src/controller/learning_system_controller/controller.py</code> <pre><code>def model_mainloop(\n    self,\n):\n    \"\"\"Run the main loop of the model process.\n\n    Raises:\n        RuntimeError: if an unsupported action is made.\n    \"\"\"\n    user_action_bridge = self.user_action_bridge\n    chain = UserActionResponsibilityChain(self.system)\n    while True:\n        message = user_action_bridge.get_action_non_blocking()\n\n        if message is None:\n            if chain.handle_inaction():\n                self.send_current_state()\n        else:\n            if message.action is UserAction.end:\n                break\n            chain.handle_user_action(message)\n            self.send_current_state()\n</code></pre>"},{"location":"reference/controller/learning_system_controller/controller/#src.controller.learning_system_controller.controller.LearningSystemController.send_current_state","title":"<code>send_current_state()</code>","text":"<p>Send the current state to the view.</p> Source code in <code>src/controller/learning_system_controller/controller.py</code> <pre><code>def send_current_state(self):\n    \"\"\"Send the current state to the view.\"\"\"\n    current_state = self.system.get_current_state()\n    self.state_update_bridge.update_state(current_state)\n</code></pre>"},{"location":"reference/controller/learning_system_controller/state_update_bridge/","title":"State Update Bridge","text":""},{"location":"reference/controller/learning_system_controller/state_update_bridge/#src.controller.learning_system_controller.state_update_bridge.StateUpdateBridge","title":"<code>StateUpdateBridge</code>","text":"<p>             Bases: <code>BaseBridge</code></p> <p>Bridge for passing state updates to the view.</p> Source code in <code>src/controller/learning_system_controller/state_update_bridge.py</code> <pre><code>class StateUpdateBridge(BaseBridge):\n    \"\"\"Bridge for passing state updates to the view.\"\"\"\n\n    def update_state(self, state: StateDescription):\n        \"\"\"Set the new state to be displayed.\n\n        Args:\n            state (StateDescription): The new state.\n        \"\"\"\n        self.add_item(state)\n\n    def get_latest_state(self) -&gt; Optional[StateDescription]:\n        \"\"\"Get the last (most recent) new state.\n\n        Returns:\n            Optional[StateDescription]: the new state, none if none has been set\n        \"\"\"\n        latest_state = None\n        state = self.get_item_non_blocking()\n        while state is not None:\n            latest_state = state\n            state = self.get_item_non_blocking()\n        return latest_state\n</code></pre>"},{"location":"reference/controller/learning_system_controller/state_update_bridge/#src.controller.learning_system_controller.state_update_bridge.StateUpdateBridge.get_latest_state","title":"<code>get_latest_state()</code>","text":"<p>Get the last (most recent) new state.</p> <p>Returns:</p> Type Description <code>Optional[StateDescription]</code> <p>Optional[StateDescription]: the new state, none if none has been set</p> Source code in <code>src/controller/learning_system_controller/state_update_bridge.py</code> <pre><code>def get_latest_state(self) -&gt; Optional[StateDescription]:\n    \"\"\"Get the last (most recent) new state.\n\n    Returns:\n        Optional[StateDescription]: the new state, none if none has been set\n    \"\"\"\n    latest_state = None\n    state = self.get_item_non_blocking()\n    while state is not None:\n        latest_state = state\n        state = self.get_item_non_blocking()\n    return latest_state\n</code></pre>"},{"location":"reference/controller/learning_system_controller/state_update_bridge/#src.controller.learning_system_controller.state_update_bridge.StateUpdateBridge.update_state","title":"<code>update_state(state)</code>","text":"<p>Set the new state to be displayed.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>StateDescription</code> <p>The new state.</p> required Source code in <code>src/controller/learning_system_controller/state_update_bridge.py</code> <pre><code>def update_state(self, state: StateDescription):\n    \"\"\"Set the new state to be displayed.\n\n    Args:\n        state (StateDescription): The new state.\n    \"\"\"\n    self.add_item(state)\n</code></pre>"},{"location":"reference/controller/learning_system_controller/user_action_bridge/","title":"User Action Bridge","text":""},{"location":"reference/controller/learning_system_controller/user_action_bridge/#src.controller.learning_system_controller.user_action_bridge.UserAction","title":"<code>UserAction</code>","text":"<p>             Bases: <code>Enum</code></p> <p>Enumerate all possible user actions.</p> Source code in <code>src/controller/learning_system_controller/user_action_bridge.py</code> <pre><code>class UserAction(Enum):\n    \"\"\"Enumerate all possible user actions.\"\"\"\n\n    progress = 0\n    select_auto = 1\n    reset_state = 2\n    fetch_current_state = 3\n    set_display_mode = 4\n    set_agent = 5\n    set_dynamics = 6\n    set_agent_strategy = 7\n    reset_system = 8\n    end = 9\n</code></pre>"},{"location":"reference/controller/learning_system_controller/user_action_bridge/#src.controller.learning_system_controller.user_action_bridge.UserActionBridge","title":"<code>UserActionBridge</code>","text":"<p>             Bases: <code>BaseBridge</code></p> <p>Bridge for passing the user actions from the view to the model.</p> Source code in <code>src/controller/learning_system_controller/user_action_bridge.py</code> <pre><code>class UserActionBridge(BaseBridge):\n    \"\"\"Bridge for passing the user actions from the view to the model.\"\"\"\n\n    def submit_action(self, action: UserAction, payload: Any = None):\n        \"\"\"Submit an action to be processed.\n\n        Args:\n            action (UserAction): the action the user has performed.\n            payload (Any): the data to send, defaults to None.\n        \"\"\"\n        self.add_item(UserActionMessage(action, payload))\n\n    def get_action(self) -&gt; UserActionMessage:\n        \"\"\"Get the latest action the user has performed.\n\n        This is blocking.\n\n        Returns:\n            UserActionMessage: the action that has been performed\n        \"\"\"\n        return self.get_item_blocking()\n\n    def get_action_non_blocking(self) -&gt; Optional[UserActionMessage]:\n        \"\"\"Get the latest action the user has performed.\n\n        This is blocking.\n\n        Returns:\n            UserActionMessage: the action that has been performed\n        \"\"\"\n        return self.get_item_non_blocking()\n</code></pre>"},{"location":"reference/controller/learning_system_controller/user_action_bridge/#src.controller.learning_system_controller.user_action_bridge.UserActionBridge.get_action","title":"<code>get_action()</code>","text":"<p>Get the latest action the user has performed.</p> <p>This is blocking.</p> <p>Returns:</p> Name Type Description <code>UserActionMessage</code> <code>UserActionMessage</code> <p>the action that has been performed</p> Source code in <code>src/controller/learning_system_controller/user_action_bridge.py</code> <pre><code>def get_action(self) -&gt; UserActionMessage:\n    \"\"\"Get the latest action the user has performed.\n\n    This is blocking.\n\n    Returns:\n        UserActionMessage: the action that has been performed\n    \"\"\"\n    return self.get_item_blocking()\n</code></pre>"},{"location":"reference/controller/learning_system_controller/user_action_bridge/#src.controller.learning_system_controller.user_action_bridge.UserActionBridge.get_action_non_blocking","title":"<code>get_action_non_blocking()</code>","text":"<p>Get the latest action the user has performed.</p> <p>This is blocking.</p> <p>Returns:</p> Name Type Description <code>UserActionMessage</code> <code>Optional[UserActionMessage]</code> <p>the action that has been performed</p> Source code in <code>src/controller/learning_system_controller/user_action_bridge.py</code> <pre><code>def get_action_non_blocking(self) -&gt; Optional[UserActionMessage]:\n    \"\"\"Get the latest action the user has performed.\n\n    This is blocking.\n\n    Returns:\n        UserActionMessage: the action that has been performed\n    \"\"\"\n    return self.get_item_non_blocking()\n</code></pre>"},{"location":"reference/controller/learning_system_controller/user_action_bridge/#src.controller.learning_system_controller.user_action_bridge.UserActionBridge.submit_action","title":"<code>submit_action(action, payload=None)</code>","text":"<p>Submit an action to be processed.</p> <p>Parameters:</p> Name Type Description Default <code>action</code> <code>UserAction</code> <p>the action the user has performed.</p> required <code>payload</code> <code>Any</code> <p>the data to send, defaults to None.</p> <code>None</code> Source code in <code>src/controller/learning_system_controller/user_action_bridge.py</code> <pre><code>def submit_action(self, action: UserAction, payload: Any = None):\n    \"\"\"Submit an action to be processed.\n\n    Args:\n        action (UserAction): the action the user has performed.\n        payload (Any): the data to send, defaults to None.\n    \"\"\"\n    self.add_item(UserActionMessage(action, payload))\n</code></pre>"},{"location":"reference/controller/learning_system_controller/user_action_bridge/#src.controller.learning_system_controller.user_action_bridge.UserActionMessage","title":"<code>UserActionMessage</code>  <code>dataclass</code>","text":"<p>             Bases: <code>object</code></p> <p>Encapsulates a user action and its data.</p> Source code in <code>src/controller/learning_system_controller/user_action_bridge.py</code> <pre><code>@dataclass(frozen=True, slots=True)\nclass UserActionMessage(object):\n    \"\"\"Encapsulates a user action and its data.\"\"\"\n\n    action: UserAction\n    payload: Any = None\n</code></pre>"},{"location":"reference/controller/learning_system_controller/user_action_handlers/","title":"User Action Handlers","text":"<p>This package contains the chain of responsibility for handling actions.</p>"},{"location":"reference/controller/learning_system_controller/user_action_handlers/auto_progress_handler/","title":"Auto Progress Handler","text":""},{"location":"reference/controller/learning_system_controller/user_action_handlers/auto_progress_handler/#src.controller.learning_system_controller.user_action_handlers.auto_progress_handler.AutoHandler","title":"<code>AutoHandler</code>","text":"<p>             Bases: <code>BaseUserActionHandler</code></p> <p>Handles automatic progress actions.</p> Source code in <code>src/controller/learning_system_controller/user_action_handlers/auto_progress_handler.py</code> <pre><code>class AutoHandler(BaseUserActionHandler):\n    \"\"\"Handles automatic progress actions.\"\"\"\n\n    def handle_action(self, user_action: UserActionMessage) -&gt; HandleResult:\n        \"\"\"Handle the select auto actions.\n\n        Args:\n            user_action (UserActionMessage): the user action provided\n\n        Returns:\n            HandleResult: weather this handler has been able to deal with the\n                request.\n        \"\"\"\n        if user_action.action is not UserAction.select_auto:\n            return HandleResult.fail\n\n        self.set_options(automatic=user_action.payload)\n\n        return HandleResult.success\n\n    def handle_inaction(self) -&gt; HandleResult:\n        \"\"\"Handle when there has not been an action.\n\n        In this case the simulation is free to automatically progress the\n        simulation.\n\n        Returns:\n            HandleResult: weather the hander has automatically progressed the\n            simulation.\n        \"\"\"\n        automatic_mode = self.learning_system.options.automatic\n        not_playing_auto = (\n            automatic_mode is not AutomaticOptions.automatic_playing\n        )\n        if not_playing_auto:\n            return HandleResult.fail\n\n        self.learning_instance.perform_action()\n\n        return HandleResult.success\n</code></pre>"},{"location":"reference/controller/learning_system_controller/user_action_handlers/auto_progress_handler/#src.controller.learning_system_controller.user_action_handlers.auto_progress_handler.AutoHandler.handle_action","title":"<code>handle_action(user_action)</code>","text":"<p>Handle the select auto actions.</p> <p>Parameters:</p> Name Type Description Default <code>user_action</code> <code>UserActionMessage</code> <p>the user action provided</p> required <p>Returns:</p> Name Type Description <code>HandleResult</code> <code>HandleResult</code> <p>weather this handler has been able to deal with the request.</p> Source code in <code>src/controller/learning_system_controller/user_action_handlers/auto_progress_handler.py</code> <pre><code>def handle_action(self, user_action: UserActionMessage) -&gt; HandleResult:\n    \"\"\"Handle the select auto actions.\n\n    Args:\n        user_action (UserActionMessage): the user action provided\n\n    Returns:\n        HandleResult: weather this handler has been able to deal with the\n            request.\n    \"\"\"\n    if user_action.action is not UserAction.select_auto:\n        return HandleResult.fail\n\n    self.set_options(automatic=user_action.payload)\n\n    return HandleResult.success\n</code></pre>"},{"location":"reference/controller/learning_system_controller/user_action_handlers/auto_progress_handler/#src.controller.learning_system_controller.user_action_handlers.auto_progress_handler.AutoHandler.handle_inaction","title":"<code>handle_inaction()</code>","text":"<p>Handle when there has not been an action.</p> <p>In this case the simulation is free to automatically progress the simulation.</p> <p>Returns:</p> Name Type Description <code>HandleResult</code> <code>HandleResult</code> <p>weather the hander has automatically progressed the</p> <code>HandleResult</code> <p>simulation.</p> Source code in <code>src/controller/learning_system_controller/user_action_handlers/auto_progress_handler.py</code> <pre><code>def handle_inaction(self) -&gt; HandleResult:\n    \"\"\"Handle when there has not been an action.\n\n    In this case the simulation is free to automatically progress the\n    simulation.\n\n    Returns:\n        HandleResult: weather the hander has automatically progressed the\n        simulation.\n    \"\"\"\n    automatic_mode = self.learning_system.options.automatic\n    not_playing_auto = (\n        automatic_mode is not AutomaticOptions.automatic_playing\n    )\n    if not_playing_auto:\n        return HandleResult.fail\n\n    self.learning_instance.perform_action()\n\n    return HandleResult.success\n</code></pre>"},{"location":"reference/controller/learning_system_controller/user_action_handlers/base_handler/","title":"Base Handler","text":""},{"location":"reference/controller/learning_system_controller/user_action_handlers/base_handler/#src.controller.learning_system_controller.user_action_handlers.base_handler.BaseUserActionHandler","title":"<code>BaseUserActionHandler</code>","text":"<p>             Bases: <code>object</code></p> <p>Base class for user action handlers.</p> Source code in <code>src/controller/learning_system_controller/user_action_handlers/base_handler.py</code> <pre><code>class BaseUserActionHandler(object):\n    \"\"\"Base class for user action handlers.\"\"\"\n\n    def __init__(\n        self,\n        learning_system: LearningSystem,\n    ) -&gt; None:\n        \"\"\"Initialise the handler.\n\n        Args:\n            learning_system (LearningSystem): The system to interact with.\n        \"\"\"\n        self.learning_system = learning_system\n\n    def handle_action(self, user_action: UserActionMessage) -&gt; HandleResult:\n        \"\"\"Handle the users action. Concrete handlers should override this.\n\n        If the hander is not successful it will be passed onto the next in the\n        chain.\n\n        Args:\n            user_action (UserActionMessage): the action the handler\n                should consider.\n\n        Returns:\n            HandleResult: weather this handler has been successful.\n        \"\"\"\n        return HandleResult.fail\n\n    def handle_inaction(self) -&gt; HandleResult:\n        \"\"\"Handle if there has not been an action provided.\n\n        Returns:\n            HandleResult: weather this handler has been successful.\n        \"\"\"\n        return HandleResult.fail\n\n    @property\n    def learning_instance(self) -&gt; LearningInstance:\n        \"\"\"Get the learning instance.\n\n        Returns:\n            LearningInstance: the learning instance to interact with.\n        \"\"\"\n        return self.learning_system.learning_instance\n\n    def set_options(self, **options):\n        \"\"\"Shorthand for updating global options.\n\n        Args:\n            options (Dict[str, Any]): the options to change.\n        \"\"\"\n        self.learning_system.update_options(\n            replace(self.learning_system.options, **options)\n        )\n\n    def set_top_level_options(self, **options):\n        \"\"\"Shorthand for updating entity options.\n\n        Args:\n            options (Dict[str, Any]): the options to change.\n        \"\"\"\n        existing_options = self.learning_system.options\n        top_level_options = replace(\n            existing_options.top_level_options,\n            **options,\n        )\n\n        self.learning_system.update_options(\n            replace(\n                existing_options,\n                top_level_options=top_level_options,\n            )\n        )\n</code></pre>"},{"location":"reference/controller/learning_system_controller/user_action_handlers/base_handler/#src.controller.learning_system_controller.user_action_handlers.base_handler.BaseUserActionHandler.learning_instance","title":"<code>learning_instance: LearningInstance</code>  <code>property</code>","text":"<p>Get the learning instance.</p> <p>Returns:</p> Name Type Description <code>LearningInstance</code> <code>LearningInstance</code> <p>the learning instance to interact with.</p>"},{"location":"reference/controller/learning_system_controller/user_action_handlers/base_handler/#src.controller.learning_system_controller.user_action_handlers.base_handler.BaseUserActionHandler.__init__","title":"<code>__init__(learning_system)</code>","text":"<p>Initialise the handler.</p> <p>Parameters:</p> Name Type Description Default <code>learning_system</code> <code>LearningSystem</code> <p>The system to interact with.</p> required Source code in <code>src/controller/learning_system_controller/user_action_handlers/base_handler.py</code> <pre><code>def __init__(\n    self,\n    learning_system: LearningSystem,\n) -&gt; None:\n    \"\"\"Initialise the handler.\n\n    Args:\n        learning_system (LearningSystem): The system to interact with.\n    \"\"\"\n    self.learning_system = learning_system\n</code></pre>"},{"location":"reference/controller/learning_system_controller/user_action_handlers/base_handler/#src.controller.learning_system_controller.user_action_handlers.base_handler.BaseUserActionHandler.handle_action","title":"<code>handle_action(user_action)</code>","text":"<p>Handle the users action. Concrete handlers should override this.</p> <p>If the hander is not successful it will be passed onto the next in the chain.</p> <p>Parameters:</p> Name Type Description Default <code>user_action</code> <code>UserActionMessage</code> <p>the action the handler should consider.</p> required <p>Returns:</p> Name Type Description <code>HandleResult</code> <code>HandleResult</code> <p>weather this handler has been successful.</p> Source code in <code>src/controller/learning_system_controller/user_action_handlers/base_handler.py</code> <pre><code>def handle_action(self, user_action: UserActionMessage) -&gt; HandleResult:\n    \"\"\"Handle the users action. Concrete handlers should override this.\n\n    If the hander is not successful it will be passed onto the next in the\n    chain.\n\n    Args:\n        user_action (UserActionMessage): the action the handler\n            should consider.\n\n    Returns:\n        HandleResult: weather this handler has been successful.\n    \"\"\"\n    return HandleResult.fail\n</code></pre>"},{"location":"reference/controller/learning_system_controller/user_action_handlers/base_handler/#src.controller.learning_system_controller.user_action_handlers.base_handler.BaseUserActionHandler.handle_inaction","title":"<code>handle_inaction()</code>","text":"<p>Handle if there has not been an action provided.</p> <p>Returns:</p> Name Type Description <code>HandleResult</code> <code>HandleResult</code> <p>weather this handler has been successful.</p> Source code in <code>src/controller/learning_system_controller/user_action_handlers/base_handler.py</code> <pre><code>def handle_inaction(self) -&gt; HandleResult:\n    \"\"\"Handle if there has not been an action provided.\n\n    Returns:\n        HandleResult: weather this handler has been successful.\n    \"\"\"\n    return HandleResult.fail\n</code></pre>"},{"location":"reference/controller/learning_system_controller/user_action_handlers/base_handler/#src.controller.learning_system_controller.user_action_handlers.base_handler.BaseUserActionHandler.set_options","title":"<code>set_options(**options)</code>","text":"<p>Shorthand for updating global options.</p> <p>Parameters:</p> Name Type Description Default <code>options</code> <code>Dict[str, Any]</code> <p>the options to change.</p> <code>{}</code> Source code in <code>src/controller/learning_system_controller/user_action_handlers/base_handler.py</code> <pre><code>def set_options(self, **options):\n    \"\"\"Shorthand for updating global options.\n\n    Args:\n        options (Dict[str, Any]): the options to change.\n    \"\"\"\n    self.learning_system.update_options(\n        replace(self.learning_system.options, **options)\n    )\n</code></pre>"},{"location":"reference/controller/learning_system_controller/user_action_handlers/base_handler/#src.controller.learning_system_controller.user_action_handlers.base_handler.BaseUserActionHandler.set_top_level_options","title":"<code>set_top_level_options(**options)</code>","text":"<p>Shorthand for updating entity options.</p> <p>Parameters:</p> Name Type Description Default <code>options</code> <code>Dict[str, Any]</code> <p>the options to change.</p> <code>{}</code> Source code in <code>src/controller/learning_system_controller/user_action_handlers/base_handler.py</code> <pre><code>def set_top_level_options(self, **options):\n    \"\"\"Shorthand for updating entity options.\n\n    Args:\n        options (Dict[str, Any]): the options to change.\n    \"\"\"\n    existing_options = self.learning_system.options\n    top_level_options = replace(\n        existing_options.top_level_options,\n        **options,\n    )\n\n    self.learning_system.update_options(\n        replace(\n            existing_options,\n            top_level_options=top_level_options,\n        )\n    )\n</code></pre>"},{"location":"reference/controller/learning_system_controller/user_action_handlers/base_handler/#src.controller.learning_system_controller.user_action_handlers.base_handler.HandleResult","title":"<code>HandleResult</code>","text":"<p>             Bases: <code>Enum</code></p> <p>Enumerates how a handler has performed.</p> Source code in <code>src/controller/learning_system_controller/user_action_handlers/base_handler.py</code> <pre><code>class HandleResult(Enum):\n    \"\"\"Enumerates how a handler has performed.\"\"\"\n\n    success = 0\n    fail = 1\n</code></pre>"},{"location":"reference/controller/learning_system_controller/user_action_handlers/progress_handler/","title":"Progress Handler","text":""},{"location":"reference/controller/learning_system_controller/user_action_handlers/progress_handler/#src.controller.learning_system_controller.user_action_handlers.progress_handler.ProgressHandler","title":"<code>ProgressHandler</code>","text":"<p>             Bases: <code>BaseUserActionHandler</code></p> <p>Handles the progress button action.</p> <p>this action is contextual on the current state of the model: weather the system is operating automatically.</p> Source code in <code>src/controller/learning_system_controller/user_action_handlers/progress_handler.py</code> <pre><code>class ProgressHandler(BaseUserActionHandler):\n    \"\"\"Handles the progress button action.\n\n    this action is contextual on the current state of the model: weather the\n    system is operating automatically.\n    \"\"\"\n\n    def handle_action(self, user_action: UserActionMessage) -&gt; HandleResult:\n        \"\"\"Handle the progress action.\n\n        Args:\n            user_action (UserActionMessage): the user action provided\n\n        Returns:\n            HandleResult: weather this handler has been able to deal with the\n                request.\n        \"\"\"\n        if user_action.action is not UserAction.progress:\n            return HandleResult.fail\n\n        match self.learning_system.options.automatic:\n            case AutomaticOptions.manual:\n                self.learning_instance.perform_action()\n            case AutomaticOptions.automatic_paused:\n                self.set_options(automatic=AutomaticOptions.automatic_playing)\n            case AutomaticOptions.automatic_playing:\n                self.set_options(automatic=AutomaticOptions.automatic_paused)\n            case _:\n                return HandleResult.fail\n\n        return HandleResult.success\n</code></pre>"},{"location":"reference/controller/learning_system_controller/user_action_handlers/progress_handler/#src.controller.learning_system_controller.user_action_handlers.progress_handler.ProgressHandler.handle_action","title":"<code>handle_action(user_action)</code>","text":"<p>Handle the progress action.</p> <p>Parameters:</p> Name Type Description Default <code>user_action</code> <code>UserActionMessage</code> <p>the user action provided</p> required <p>Returns:</p> Name Type Description <code>HandleResult</code> <code>HandleResult</code> <p>weather this handler has been able to deal with the request.</p> Source code in <code>src/controller/learning_system_controller/user_action_handlers/progress_handler.py</code> <pre><code>def handle_action(self, user_action: UserActionMessage) -&gt; HandleResult:\n    \"\"\"Handle the progress action.\n\n    Args:\n        user_action (UserActionMessage): the user action provided\n\n    Returns:\n        HandleResult: weather this handler has been able to deal with the\n            request.\n    \"\"\"\n    if user_action.action is not UserAction.progress:\n        return HandleResult.fail\n\n    match self.learning_system.options.automatic:\n        case AutomaticOptions.manual:\n            self.learning_instance.perform_action()\n        case AutomaticOptions.automatic_paused:\n            self.set_options(automatic=AutomaticOptions.automatic_playing)\n        case AutomaticOptions.automatic_playing:\n            self.set_options(automatic=AutomaticOptions.automatic_paused)\n        case _:\n            return HandleResult.fail\n\n    return HandleResult.success\n</code></pre>"},{"location":"reference/controller/learning_system_controller/user_action_handlers/responsibility_chain/","title":"Responsibility Chain","text":""},{"location":"reference/controller/learning_system_controller/user_action_handlers/responsibility_chain/#src.controller.learning_system_controller.user_action_handlers.responsibility_chain.UserActionResponsibilityChain","title":"<code>UserActionResponsibilityChain</code>","text":"<p>             Bases: <code>object</code></p> <p>This class represents a whole chain of connected handlers.</p> Source code in <code>src/controller/learning_system_controller/user_action_handlers/responsibility_chain.py</code> <pre><code>class UserActionResponsibilityChain(object):\n    \"\"\"This class represents a whole chain of connected handlers.\"\"\"\n\n    def __init__(self, learning_system: LearningSystem) -&gt; None:\n        \"\"\"Initialise the learning chain.\n\n        Args:\n            learning_system (LearningSystem): the model this chain should\n                interact with.\n        \"\"\"\n        self.learning_system = learning_system\n\n        self.chain: List[BaseUserActionHandler] = [\n            StandardRequestHandler(learning_system),\n            SetOptionsHandler(learning_system),\n            ProgressHandler(learning_system),\n            AutoHandler(learning_system),\n        ]\n\n    def handle_inaction(self) -&gt; bool:\n        \"\"\"Perform busy waiting when there has not been an action from the user.\n\n        Returns:\n            bool: weather there has been an action performed.\n        \"\"\"\n        has_been_handled = False\n        for user_action_handler in self.chain:\n            handle_result = user_action_handler.handle_inaction()\n            has_been_handled = has_been_handled or (\n                handle_result is HandleResult.success\n            )\n        return has_been_handled\n\n    def handle_user_action(self, action: UserActionMessage) -&gt; None:\n        \"\"\"Handle a user action with each handler in turn.\n\n        Args:\n            action (UserActionMessage): the action from the user.\n\n        Raises:\n            RuntimeError: If unable to handle the action provided.\n        \"\"\"\n        for user_action_handler in self.chain:\n            handle_result = user_action_handler.handle_action(action)\n            if handle_result is HandleResult.success:\n                return\n\n        raise RuntimeError(\"unable to handle user action.\")\n</code></pre>"},{"location":"reference/controller/learning_system_controller/user_action_handlers/responsibility_chain/#src.controller.learning_system_controller.user_action_handlers.responsibility_chain.UserActionResponsibilityChain.__init__","title":"<code>__init__(learning_system)</code>","text":"<p>Initialise the learning chain.</p> <p>Parameters:</p> Name Type Description Default <code>learning_system</code> <code>LearningSystem</code> <p>the model this chain should interact with.</p> required Source code in <code>src/controller/learning_system_controller/user_action_handlers/responsibility_chain.py</code> <pre><code>def __init__(self, learning_system: LearningSystem) -&gt; None:\n    \"\"\"Initialise the learning chain.\n\n    Args:\n        learning_system (LearningSystem): the model this chain should\n            interact with.\n    \"\"\"\n    self.learning_system = learning_system\n\n    self.chain: List[BaseUserActionHandler] = [\n        StandardRequestHandler(learning_system),\n        SetOptionsHandler(learning_system),\n        ProgressHandler(learning_system),\n        AutoHandler(learning_system),\n    ]\n</code></pre>"},{"location":"reference/controller/learning_system_controller/user_action_handlers/responsibility_chain/#src.controller.learning_system_controller.user_action_handlers.responsibility_chain.UserActionResponsibilityChain.handle_inaction","title":"<code>handle_inaction()</code>","text":"<p>Perform busy waiting when there has not been an action from the user.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>weather there has been an action performed.</p> Source code in <code>src/controller/learning_system_controller/user_action_handlers/responsibility_chain.py</code> <pre><code>def handle_inaction(self) -&gt; bool:\n    \"\"\"Perform busy waiting when there has not been an action from the user.\n\n    Returns:\n        bool: weather there has been an action performed.\n    \"\"\"\n    has_been_handled = False\n    for user_action_handler in self.chain:\n        handle_result = user_action_handler.handle_inaction()\n        has_been_handled = has_been_handled or (\n            handle_result is HandleResult.success\n        )\n    return has_been_handled\n</code></pre>"},{"location":"reference/controller/learning_system_controller/user_action_handlers/responsibility_chain/#src.controller.learning_system_controller.user_action_handlers.responsibility_chain.UserActionResponsibilityChain.handle_user_action","title":"<code>handle_user_action(action)</code>","text":"<p>Handle a user action with each handler in turn.</p> <p>Parameters:</p> Name Type Description Default <code>action</code> <code>UserActionMessage</code> <p>the action from the user.</p> required <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If unable to handle the action provided.</p> Source code in <code>src/controller/learning_system_controller/user_action_handlers/responsibility_chain.py</code> <pre><code>def handle_user_action(self, action: UserActionMessage) -&gt; None:\n    \"\"\"Handle a user action with each handler in turn.\n\n    Args:\n        action (UserActionMessage): the action from the user.\n\n    Raises:\n        RuntimeError: If unable to handle the action provided.\n    \"\"\"\n    for user_action_handler in self.chain:\n        handle_result = user_action_handler.handle_action(action)\n        if handle_result is HandleResult.success:\n            return\n\n    raise RuntimeError(\"unable to handle user action.\")\n</code></pre>"},{"location":"reference/controller/learning_system_controller/user_action_handlers/set_options_handler/","title":"Set Options Handler","text":""},{"location":"reference/controller/learning_system_controller/user_action_handlers/set_options_handler/#src.controller.learning_system_controller.user_action_handlers.set_options_handler.SetOptionsHandler","title":"<code>SetOptionsHandler</code>","text":"<p>             Bases: <code>BaseUserActionHandler</code></p> <p>Handles requests to set the options.</p> Source code in <code>src/controller/learning_system_controller/user_action_handlers/set_options_handler.py</code> <pre><code>class SetOptionsHandler(BaseUserActionHandler):\n    \"\"\"Handles requests to set the options.\"\"\"\n\n    default_strategies = {\n        AgentOptions.q_learning: ExplorationStrategyOptions.epsilon_greedy,\n        AgentOptions.value_iteration: ExplorationStrategyOptions.not_applicable,\n        AgentOptions.value_iteration_optimised: (\n            ExplorationStrategyOptions.not_applicable\n        ),\n    }\n\n    def handle_action(self, user_action: UserActionMessage) -&gt; HandleResult:\n        \"\"\"Handle the actions that change the options.\n\n        Args:\n            user_action (UserActionMessage): the user action provided\n\n        Returns:\n            HandleResult: weather this handler has been able to deal with the\n                request.\n        \"\"\"\n        match user_action:\n            case UserActionMessage(\n                action=UserAction.set_display_mode, payload=display_mode\n            ):\n                self.set_options(display_mode=display_mode)\n\n            case UserActionMessage(action=UserAction.set_agent, payload=agent):\n                self.set_top_level_options(\n                    agent=agent,\n                    exploration_strategy=self.default_strategies[agent],\n                )\n\n            case UserActionMessage(\n                action=UserAction.set_dynamics, payload=dynamics\n            ):\n                self.set_top_level_options(dynamics=dynamics)\n\n            case UserActionMessage(\n                action=UserAction.set_agent_strategy, payload=agent_strategy\n            ):\n                self.set_top_level_options(exploration_strategy=agent_strategy)\n\n            case _:\n                return HandleResult.fail\n\n        return HandleResult.success\n</code></pre>"},{"location":"reference/controller/learning_system_controller/user_action_handlers/set_options_handler/#src.controller.learning_system_controller.user_action_handlers.set_options_handler.SetOptionsHandler.handle_action","title":"<code>handle_action(user_action)</code>","text":"<p>Handle the actions that change the options.</p> <p>Parameters:</p> Name Type Description Default <code>user_action</code> <code>UserActionMessage</code> <p>the user action provided</p> required <p>Returns:</p> Name Type Description <code>HandleResult</code> <code>HandleResult</code> <p>weather this handler has been able to deal with the request.</p> Source code in <code>src/controller/learning_system_controller/user_action_handlers/set_options_handler.py</code> <pre><code>def handle_action(self, user_action: UserActionMessage) -&gt; HandleResult:\n    \"\"\"Handle the actions that change the options.\n\n    Args:\n        user_action (UserActionMessage): the user action provided\n\n    Returns:\n        HandleResult: weather this handler has been able to deal with the\n            request.\n    \"\"\"\n    match user_action:\n        case UserActionMessage(\n            action=UserAction.set_display_mode, payload=display_mode\n        ):\n            self.set_options(display_mode=display_mode)\n\n        case UserActionMessage(action=UserAction.set_agent, payload=agent):\n            self.set_top_level_options(\n                agent=agent,\n                exploration_strategy=self.default_strategies[agent],\n            )\n\n        case UserActionMessage(\n            action=UserAction.set_dynamics, payload=dynamics\n        ):\n            self.set_top_level_options(dynamics=dynamics)\n\n        case UserActionMessage(\n            action=UserAction.set_agent_strategy, payload=agent_strategy\n        ):\n            self.set_top_level_options(exploration_strategy=agent_strategy)\n\n        case _:\n            return HandleResult.fail\n\n    return HandleResult.success\n</code></pre>"},{"location":"reference/controller/learning_system_controller/user_action_handlers/standard_handler/","title":"Standard Handler","text":""},{"location":"reference/controller/learning_system_controller/user_action_handlers/standard_handler/#src.controller.learning_system_controller.user_action_handlers.standard_handler.StandardRequestHandler","title":"<code>StandardRequestHandler</code>","text":"<p>             Bases: <code>BaseUserActionHandler</code></p> <p>Handles requests that dont involve any processing.</p> Source code in <code>src/controller/learning_system_controller/user_action_handlers/standard_handler.py</code> <pre><code>class StandardRequestHandler(BaseUserActionHandler):\n    \"\"\"Handles requests that dont involve any processing.\"\"\"\n\n    def handle_action(self, user_action: UserActionMessage) -&gt; HandleResult:\n        \"\"\"Handle the actions that involve simple requests.\n\n        Args:\n            user_action (UserActionMessage): the user action provided\n\n        Returns:\n            HandleResult: weather this handler has been able to deal with the\n                request.\n        \"\"\"\n        match user_action:\n            case UserActionMessage(action=UserAction.reset_state):\n                self.learning_instance.reset_state()\n            case UserActionMessage(action=UserAction.fetch_current_state):\n                # no precessing necessary\n                return HandleResult.success\n            case UserActionMessage(action=UserAction.reset_system):\n                self.learning_system.reset_top_level()\n            case _:\n                return HandleResult.fail\n\n        return HandleResult.success\n</code></pre>"},{"location":"reference/controller/learning_system_controller/user_action_handlers/standard_handler/#src.controller.learning_system_controller.user_action_handlers.standard_handler.StandardRequestHandler.handle_action","title":"<code>handle_action(user_action)</code>","text":"<p>Handle the actions that involve simple requests.</p> <p>Parameters:</p> Name Type Description Default <code>user_action</code> <code>UserActionMessage</code> <p>the user action provided</p> required <p>Returns:</p> Name Type Description <code>HandleResult</code> <code>HandleResult</code> <p>weather this handler has been able to deal with the request.</p> Source code in <code>src/controller/learning_system_controller/user_action_handlers/standard_handler.py</code> <pre><code>def handle_action(self, user_action: UserActionMessage) -&gt; HandleResult:\n    \"\"\"Handle the actions that involve simple requests.\n\n    Args:\n        user_action (UserActionMessage): the user action provided\n\n    Returns:\n        HandleResult: weather this handler has been able to deal with the\n            request.\n    \"\"\"\n    match user_action:\n        case UserActionMessage(action=UserAction.reset_state):\n            self.learning_instance.reset_state()\n        case UserActionMessage(action=UserAction.fetch_current_state):\n            # no precessing necessary\n            return HandleResult.success\n        case UserActionMessage(action=UserAction.reset_system):\n            self.learning_system.reset_top_level()\n        case _:\n            return HandleResult.fail\n\n    return HandleResult.success\n</code></pre>"},{"location":"reference/model/","title":"Model","text":"<p>This Package contains the model.</p> <p>The model is the reinforcement learning code</p>"},{"location":"reference/model/transition_information/","title":"Transition Information","text":""},{"location":"reference/model/transition_information/#src.model.transition_information.TransitionInformation","title":"<code>TransitionInformation</code>  <code>dataclass</code>","text":"<p>             Bases: <code>object</code></p> <p>Combine all the transition information in one object.</p> Source code in <code>src/model/transition_information.py</code> <pre><code>@dataclass(frozen=True, slots=True)\nclass TransitionInformation(object):\n    \"\"\"Combine all the transition information in one object.\"\"\"\n\n    previous_state: int\n    previous_action: Action\n    new_state: int\n    reward: float\n</code></pre>"},{"location":"reference/model/agents/","title":"Agents","text":"<p>This package contains the agents.</p> <p>the agents should that will learn and generate policies</p>"},{"location":"reference/model/agents/base_agent/","title":"Base Agent","text":""},{"location":"reference/model/agents/base_agent/#src.model.agents.base_agent.BaseAgent","title":"<code>BaseAgent</code>","text":"<p>             Bases: <code>object</code></p> <p>Provides the common base for different learning agents.</p> Source code in <code>src/model/agents/base_agent.py</code> <pre><code>class BaseAgent(object):\n    \"\"\"Provides the common base for different learning agents.\"\"\"\n\n    def __init__(\n        self, hyper_parameters: BaseHyperParameterStrategy, max_state_count: int\n    ) -&gt; None:\n        \"\"\"Initialise an agent.\n\n        Args:\n            hyper_parameters (BaseHyperParameterStrategy): the hyper parameters\n                the agent should use.\n            max_state_count (int): maximum number of states this agent may need\n                to handle with.\n        \"\"\"\n        self.hyper_parameters = hyper_parameters\n        self.max_state_count = max_state_count\n\n    def evaluate_policy(self, state: int) -&gt; Action:\n        \"\"\"Decide on the action this agent would take in a given state.\n\n        Args:\n            state (int): the state the agent is performing this action\n\n        Raises:\n            NotImplementedError: If this method has not been overridden by\n                concrete agent.\n\n        Returns:\n            Action: the action to take in this state\n        \"\"\"\n        self.__throw_not_implemented()\n        return Action.down\n\n    def record_transition(\n        self, transition_information: TransitionInformation\n    ) -&gt; None:\n        \"\"\"Provide the agent with the information from a transition.\n\n        Args:\n            transition_information (TransitionInformation): The transition\n                information.\n\n        Raises:\n            NotImplementedError: If this method has not been overridden by\n                concrete agent.\n        \"\"\"\n        self.__throw_not_implemented()\n\n    def get_state_value(self, state: int) -&gt; float:\n        \"\"\"Get the agents interpretation of the value of this state.\n\n        Args:\n            state (int): the state to evaluate\n\n        Raises:\n            NotImplementedError: If this method has not been overridden by\n                concrete agent.\n\n        Returns:\n            float: the agents interpretation of the value of this state\n        \"\"\"\n        self.__throw_not_implemented()\n        return 0\n\n    def get_state_action_value(self, state: int, action: Action) -&gt; float:\n        \"\"\"Get the agents interpretation of an actions value.\n\n        allows for visualisations to be made\n\n        Args:\n            state (int): the state to perform the action in\n            action (Action): the action to evaluate\n\n        Raises:\n            NotImplementedError: If this method has not been overridden by\n                concrete agent.\n\n        Returns:\n            float: the agents interpretation of the value of this state and\n            action\n        \"\"\"\n        self.__throw_not_implemented()\n        return 0\n\n    def __throw_not_implemented(self):\n        raise NotImplementedError(\n            \"This method must be overridden by concrete agent\"\n        )\n</code></pre>"},{"location":"reference/model/agents/base_agent/#src.model.agents.base_agent.BaseAgent.__init__","title":"<code>__init__(hyper_parameters, max_state_count)</code>","text":"<p>Initialise an agent.</p> <p>Parameters:</p> Name Type Description Default <code>hyper_parameters</code> <code>BaseHyperParameterStrategy</code> <p>the hyper parameters the agent should use.</p> required <code>max_state_count</code> <code>int</code> <p>maximum number of states this agent may need to handle with.</p> required Source code in <code>src/model/agents/base_agent.py</code> <pre><code>def __init__(\n    self, hyper_parameters: BaseHyperParameterStrategy, max_state_count: int\n) -&gt; None:\n    \"\"\"Initialise an agent.\n\n    Args:\n        hyper_parameters (BaseHyperParameterStrategy): the hyper parameters\n            the agent should use.\n        max_state_count (int): maximum number of states this agent may need\n            to handle with.\n    \"\"\"\n    self.hyper_parameters = hyper_parameters\n    self.max_state_count = max_state_count\n</code></pre>"},{"location":"reference/model/agents/base_agent/#src.model.agents.base_agent.BaseAgent.evaluate_policy","title":"<code>evaluate_policy(state)</code>","text":"<p>Decide on the action this agent would take in a given state.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>int</code> <p>the state the agent is performing this action</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If this method has not been overridden by concrete agent.</p> <p>Returns:</p> Name Type Description <code>Action</code> <code>Action</code> <p>the action to take in this state</p> Source code in <code>src/model/agents/base_agent.py</code> <pre><code>def evaluate_policy(self, state: int) -&gt; Action:\n    \"\"\"Decide on the action this agent would take in a given state.\n\n    Args:\n        state (int): the state the agent is performing this action\n\n    Raises:\n        NotImplementedError: If this method has not been overridden by\n            concrete agent.\n\n    Returns:\n        Action: the action to take in this state\n    \"\"\"\n    self.__throw_not_implemented()\n    return Action.down\n</code></pre>"},{"location":"reference/model/agents/base_agent/#src.model.agents.base_agent.BaseAgent.get_state_action_value","title":"<code>get_state_action_value(state, action)</code>","text":"<p>Get the agents interpretation of an actions value.</p> <p>allows for visualisations to be made</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>int</code> <p>the state to perform the action in</p> required <code>action</code> <code>Action</code> <p>the action to evaluate</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If this method has not been overridden by concrete agent.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the agents interpretation of the value of this state and</p> <code>float</code> <p>action</p> Source code in <code>src/model/agents/base_agent.py</code> <pre><code>def get_state_action_value(self, state: int, action: Action) -&gt; float:\n    \"\"\"Get the agents interpretation of an actions value.\n\n    allows for visualisations to be made\n\n    Args:\n        state (int): the state to perform the action in\n        action (Action): the action to evaluate\n\n    Raises:\n        NotImplementedError: If this method has not been overridden by\n            concrete agent.\n\n    Returns:\n        float: the agents interpretation of the value of this state and\n        action\n    \"\"\"\n    self.__throw_not_implemented()\n    return 0\n</code></pre>"},{"location":"reference/model/agents/base_agent/#src.model.agents.base_agent.BaseAgent.get_state_value","title":"<code>get_state_value(state)</code>","text":"<p>Get the agents interpretation of the value of this state.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>int</code> <p>the state to evaluate</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If this method has not been overridden by concrete agent.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the agents interpretation of the value of this state</p> Source code in <code>src/model/agents/base_agent.py</code> <pre><code>def get_state_value(self, state: int) -&gt; float:\n    \"\"\"Get the agents interpretation of the value of this state.\n\n    Args:\n        state (int): the state to evaluate\n\n    Raises:\n        NotImplementedError: If this method has not been overridden by\n            concrete agent.\n\n    Returns:\n        float: the agents interpretation of the value of this state\n    \"\"\"\n    self.__throw_not_implemented()\n    return 0\n</code></pre>"},{"location":"reference/model/agents/base_agent/#src.model.agents.base_agent.BaseAgent.record_transition","title":"<code>record_transition(transition_information)</code>","text":"<p>Provide the agent with the information from a transition.</p> <p>Parameters:</p> Name Type Description Default <code>transition_information</code> <code>TransitionInformation</code> <p>The transition information.</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If this method has not been overridden by concrete agent.</p> Source code in <code>src/model/agents/base_agent.py</code> <pre><code>def record_transition(\n    self, transition_information: TransitionInformation\n) -&gt; None:\n    \"\"\"Provide the agent with the information from a transition.\n\n    Args:\n        transition_information (TransitionInformation): The transition\n            information.\n\n    Raises:\n        NotImplementedError: If this method has not been overridden by\n            concrete agent.\n    \"\"\"\n    self.__throw_not_implemented()\n</code></pre>"},{"location":"reference/model/agents/q_learning/","title":"Q Learning","text":"<p>This package contains the code for a Q-learning agent.</p>"},{"location":"reference/model/agents/q_learning/agent/","title":"Agent","text":""},{"location":"reference/model/agents/q_learning/agent/#src.model.agents.q_learning.agent.QLearningAgent","title":"<code>QLearningAgent</code>","text":"<p>             Bases: <code>BaseAgent</code></p> <p>Agent that learns q-value table to make decisions.</p> Source code in <code>src/model/agents/q_learning/agent.py</code> <pre><code>class QLearningAgent(BaseAgent):\n    \"\"\"Agent that learns q-value table to make decisions.\"\"\"\n\n    action_count = len(Action)\n\n    def __init__(\n        self,\n        hyper_parameters: BaseHyperParameterStrategy,\n        strategy: ExplorationStrategyOptions,\n        max_state_count: int,\n    ) -&gt; None:\n        \"\"\"Initialise the agent.\n\n        Args:\n            hyper_parameters (BaseHyperParameterStrategy): the hyper parameters\n                the agent should use.\n            strategy (ExplorationStrategyOptions): The strategy the agent should\n                use to select actions.\n            max_state_count (int): maximum number of states this agent may need\n                to handle with.\n        \"\"\"\n        super().__init__(hyper_parameters, max_state_count)\n\n        self.max_queue_length = hyper_parameters.get_integer_value(\n            HyperParameter.replay_queue_length\n        )\n        self.learning_rate = hyper_parameters.get_value(\n            HyperParameter.learning_rate\n        )\n        self.discount_rate = hyper_parameters.get_value(\n            HyperParameter.discount_rate\n        )\n        initial_optimism = hyper_parameters.get_value(\n            HyperParameter.initial_optimism\n        )\n        self.queue: List[TransitionInformation] = []\n        self.table: Dict[int, float] = defaultdict(lambda: initial_optimism)\n        self.strategy = self.set_exploration_strategy(strategy)\n\n    def set_exploration_strategy(\n        self, strategy: ExplorationStrategyOptions\n    ) -&gt; BaseExplorationStrategy:\n        \"\"\"Set the current strategy used by the agent.\n\n        Args:\n            strategy (ExplorationStrategyOptions): specifies the strategy to\n                use.\n\n        Raises:\n            ValueError: if an invalid strategy is provided\n\n        Returns:\n            BaseExplorationStrategy: the new strategy the agent will use.\n        \"\"\"\n        match strategy:\n            case ExplorationStrategyOptions.epsilon_greedy:\n                self.strategy = EpsilonGreedyStrategy(self)\n            case ExplorationStrategyOptions.upper_confidence_bound:\n                self.strategy = UpperConfidenceBoundStrategy(self)\n            case ExplorationStrategyOptions.mf_bpi:\n                self.strategy = MFBPIStrategy(self)\n            case _:\n                raise ValueError(f\"Unknown strategy provided {strategy}\")\n\n        return self.strategy\n\n    def get_state_action_value(self, state: int, action: Action) -&gt; float:\n        \"\"\"Get the agents interpretation value of a given state-action.\n\n        Args:\n            state (int): the state the action is performed in\n            action (Action): the action to get the value of\n\n        Returns:\n            float: the expected value for this state and action\n        \"\"\"\n        return self.table[state * self.action_count + action.value]\n\n    def get_state_value(self, state: int) -&gt; float:\n        \"\"\"Get the agents interpretation of the value of this state.\n\n        Args:\n            state (int): the state to evaluate\n\n        Returns:\n            float: the agents interpretation of the value of this state\n        \"\"\"\n        table = self.table\n        action_count = self.action_count\n        state_index = state * action_count\n        return max(\n            table[state_index + offset] for offset in range(action_count)\n        )\n\n    def evaluate_policy(self, state: int) -&gt; Action:\n        \"\"\"Decide on the action this agent would take in a given state.\n\n        Args:\n            state (int): the state the agent is performing this action\n\n        Returns:\n            Action: the action to take in this state\n        \"\"\"\n        return self.strategy.select_action(state)\n\n    def record_transition(self, transition: TransitionInformation) -&gt; None:\n        \"\"\"Provide the agent with the information from a transition.\n\n        Args:\n            transition (TransitionInformation): The transition information.\n\n        \"\"\"\n        self.strategy.record_transition(transition)\n\n        table = self.table\n        learning_rate = self.learning_rate\n        queue = self.queue\n        table = self.table\n        discount_rate = self.discount_rate\n        action_count = self.action_count\n\n        queue.insert(0, transition)\n        if len(queue) &gt; self.max_queue_length:\n            queue.pop()\n\n        for obs in queue:\n            new_state_index = obs.new_state * action_count\n            new_state_value = max(\n                table[new_state_index + index] for index in range(action_count)\n            )\n\n            observed_value = obs.reward + discount_rate * new_state_value\n            index = (\n                obs.previous_state * action_count + obs.previous_action.value\n            )\n\n            existing_value = table[index]\n            table[index] = existing_value + learning_rate * (\n                observed_value - existing_value\n            )\n</code></pre>"},{"location":"reference/model/agents/q_learning/agent/#src.model.agents.q_learning.agent.QLearningAgent.__init__","title":"<code>__init__(hyper_parameters, strategy, max_state_count)</code>","text":"<p>Initialise the agent.</p> <p>Parameters:</p> Name Type Description Default <code>hyper_parameters</code> <code>BaseHyperParameterStrategy</code> <p>the hyper parameters the agent should use.</p> required <code>strategy</code> <code>ExplorationStrategyOptions</code> <p>The strategy the agent should use to select actions.</p> required <code>max_state_count</code> <code>int</code> <p>maximum number of states this agent may need to handle with.</p> required Source code in <code>src/model/agents/q_learning/agent.py</code> <pre><code>def __init__(\n    self,\n    hyper_parameters: BaseHyperParameterStrategy,\n    strategy: ExplorationStrategyOptions,\n    max_state_count: int,\n) -&gt; None:\n    \"\"\"Initialise the agent.\n\n    Args:\n        hyper_parameters (BaseHyperParameterStrategy): the hyper parameters\n            the agent should use.\n        strategy (ExplorationStrategyOptions): The strategy the agent should\n            use to select actions.\n        max_state_count (int): maximum number of states this agent may need\n            to handle with.\n    \"\"\"\n    super().__init__(hyper_parameters, max_state_count)\n\n    self.max_queue_length = hyper_parameters.get_integer_value(\n        HyperParameter.replay_queue_length\n    )\n    self.learning_rate = hyper_parameters.get_value(\n        HyperParameter.learning_rate\n    )\n    self.discount_rate = hyper_parameters.get_value(\n        HyperParameter.discount_rate\n    )\n    initial_optimism = hyper_parameters.get_value(\n        HyperParameter.initial_optimism\n    )\n    self.queue: List[TransitionInformation] = []\n    self.table: Dict[int, float] = defaultdict(lambda: initial_optimism)\n    self.strategy = self.set_exploration_strategy(strategy)\n</code></pre>"},{"location":"reference/model/agents/q_learning/agent/#src.model.agents.q_learning.agent.QLearningAgent.evaluate_policy","title":"<code>evaluate_policy(state)</code>","text":"<p>Decide on the action this agent would take in a given state.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>int</code> <p>the state the agent is performing this action</p> required <p>Returns:</p> Name Type Description <code>Action</code> <code>Action</code> <p>the action to take in this state</p> Source code in <code>src/model/agents/q_learning/agent.py</code> <pre><code>def evaluate_policy(self, state: int) -&gt; Action:\n    \"\"\"Decide on the action this agent would take in a given state.\n\n    Args:\n        state (int): the state the agent is performing this action\n\n    Returns:\n        Action: the action to take in this state\n    \"\"\"\n    return self.strategy.select_action(state)\n</code></pre>"},{"location":"reference/model/agents/q_learning/agent/#src.model.agents.q_learning.agent.QLearningAgent.get_state_action_value","title":"<code>get_state_action_value(state, action)</code>","text":"<p>Get the agents interpretation value of a given state-action.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>int</code> <p>the state the action is performed in</p> required <code>action</code> <code>Action</code> <p>the action to get the value of</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the expected value for this state and action</p> Source code in <code>src/model/agents/q_learning/agent.py</code> <pre><code>def get_state_action_value(self, state: int, action: Action) -&gt; float:\n    \"\"\"Get the agents interpretation value of a given state-action.\n\n    Args:\n        state (int): the state the action is performed in\n        action (Action): the action to get the value of\n\n    Returns:\n        float: the expected value for this state and action\n    \"\"\"\n    return self.table[state * self.action_count + action.value]\n</code></pre>"},{"location":"reference/model/agents/q_learning/agent/#src.model.agents.q_learning.agent.QLearningAgent.get_state_value","title":"<code>get_state_value(state)</code>","text":"<p>Get the agents interpretation of the value of this state.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>int</code> <p>the state to evaluate</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the agents interpretation of the value of this state</p> Source code in <code>src/model/agents/q_learning/agent.py</code> <pre><code>def get_state_value(self, state: int) -&gt; float:\n    \"\"\"Get the agents interpretation of the value of this state.\n\n    Args:\n        state (int): the state to evaluate\n\n    Returns:\n        float: the agents interpretation of the value of this state\n    \"\"\"\n    table = self.table\n    action_count = self.action_count\n    state_index = state * action_count\n    return max(\n        table[state_index + offset] for offset in range(action_count)\n    )\n</code></pre>"},{"location":"reference/model/agents/q_learning/agent/#src.model.agents.q_learning.agent.QLearningAgent.record_transition","title":"<code>record_transition(transition)</code>","text":"<p>Provide the agent with the information from a transition.</p> <p>Parameters:</p> Name Type Description Default <code>transition</code> <code>TransitionInformation</code> <p>The transition information.</p> required Source code in <code>src/model/agents/q_learning/agent.py</code> <pre><code>def record_transition(self, transition: TransitionInformation) -&gt; None:\n    \"\"\"Provide the agent with the information from a transition.\n\n    Args:\n        transition (TransitionInformation): The transition information.\n\n    \"\"\"\n    self.strategy.record_transition(transition)\n\n    table = self.table\n    learning_rate = self.learning_rate\n    queue = self.queue\n    table = self.table\n    discount_rate = self.discount_rate\n    action_count = self.action_count\n\n    queue.insert(0, transition)\n    if len(queue) &gt; self.max_queue_length:\n        queue.pop()\n\n    for obs in queue:\n        new_state_index = obs.new_state * action_count\n        new_state_value = max(\n            table[new_state_index + index] for index in range(action_count)\n        )\n\n        observed_value = obs.reward + discount_rate * new_state_value\n        index = (\n            obs.previous_state * action_count + obs.previous_action.value\n        )\n\n        existing_value = table[index]\n        table[index] = existing_value + learning_rate * (\n            observed_value - existing_value\n        )\n</code></pre>"},{"location":"reference/model/agents/q_learning/agent/#src.model.agents.q_learning.agent.QLearningAgent.set_exploration_strategy","title":"<code>set_exploration_strategy(strategy)</code>","text":"<p>Set the current strategy used by the agent.</p> <p>Parameters:</p> Name Type Description Default <code>strategy</code> <code>ExplorationStrategyOptions</code> <p>specifies the strategy to use.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>if an invalid strategy is provided</p> <p>Returns:</p> Name Type Description <code>BaseExplorationStrategy</code> <code>BaseExplorationStrategy</code> <p>the new strategy the agent will use.</p> Source code in <code>src/model/agents/q_learning/agent.py</code> <pre><code>def set_exploration_strategy(\n    self, strategy: ExplorationStrategyOptions\n) -&gt; BaseExplorationStrategy:\n    \"\"\"Set the current strategy used by the agent.\n\n    Args:\n        strategy (ExplorationStrategyOptions): specifies the strategy to\n            use.\n\n    Raises:\n        ValueError: if an invalid strategy is provided\n\n    Returns:\n        BaseExplorationStrategy: the new strategy the agent will use.\n    \"\"\"\n    match strategy:\n        case ExplorationStrategyOptions.epsilon_greedy:\n            self.strategy = EpsilonGreedyStrategy(self)\n        case ExplorationStrategyOptions.upper_confidence_bound:\n            self.strategy = UpperConfidenceBoundStrategy(self)\n        case ExplorationStrategyOptions.mf_bpi:\n            self.strategy = MFBPIStrategy(self)\n        case _:\n            raise ValueError(f\"Unknown strategy provided {strategy}\")\n\n    return self.strategy\n</code></pre>"},{"location":"reference/model/agents/q_learning/exploration_strategies/","title":"Exploration Strategies","text":"<p>This packages contains all of the different exploration strategies.</p> <p>the exploration strategies pick actions for the agent based upon some metric.</p>"},{"location":"reference/model/agents/q_learning/exploration_strategies/base_strategy/","title":"Base Strategy","text":""},{"location":"reference/model/agents/q_learning/exploration_strategies/base_strategy/#src.model.agents.q_learning.exploration_strategies.base_strategy.BaseExplorationStrategy","title":"<code>BaseExplorationStrategy</code>","text":"<p>             Bases: <code>object</code></p> <p>Provides the common base for different exploration strategies.</p> Source code in <code>src/model/agents/q_learning/exploration_strategies/base_strategy.py</code> <pre><code>class BaseExplorationStrategy(object):\n    \"\"\"Provides the common base for different exploration strategies.\"\"\"\n\n    def __init__(self, agent: BaseAgent) -&gt; None:\n        \"\"\"Initialise the Exploration strategy.\n\n        Args:\n            agent (BaseAgent): The agent that uses this strategy.\n        \"\"\"\n        self.agent = agent\n\n    def select_action(self, state: int) -&gt; Action:\n        \"\"\"Select the action based upon this strategy.\n\n        Args:\n            state (int): the state where this action will be performed\n\n        Raises:\n            NotImplementedError: If this method has not been overridden by a\n                concrete strategy.\n\n        Returns:\n            Action: The action the agent should perform\n        \"\"\"\n        self.__throw_not_implemented()\n        return Action.up\n\n    def record_transition(self, transition: TransitionInformation) -&gt; None:\n        \"\"\"Provide the strategy with the information from a transition.\n\n        Args:\n            transition (TransitionInformation): The transition information.\n\n        \"\"\"\n        # not implemented\n\n    def __throw_not_implemented(self):\n        raise NotImplementedError(\n            \"This method must be overridden by concrete strategy\"\n        )\n</code></pre>"},{"location":"reference/model/agents/q_learning/exploration_strategies/base_strategy/#src.model.agents.q_learning.exploration_strategies.base_strategy.BaseExplorationStrategy.__init__","title":"<code>__init__(agent)</code>","text":"<p>Initialise the Exploration strategy.</p> <p>Parameters:</p> Name Type Description Default <code>agent</code> <code>BaseAgent</code> <p>The agent that uses this strategy.</p> required Source code in <code>src/model/agents/q_learning/exploration_strategies/base_strategy.py</code> <pre><code>def __init__(self, agent: BaseAgent) -&gt; None:\n    \"\"\"Initialise the Exploration strategy.\n\n    Args:\n        agent (BaseAgent): The agent that uses this strategy.\n    \"\"\"\n    self.agent = agent\n</code></pre>"},{"location":"reference/model/agents/q_learning/exploration_strategies/base_strategy/#src.model.agents.q_learning.exploration_strategies.base_strategy.BaseExplorationStrategy.record_transition","title":"<code>record_transition(transition)</code>","text":"<p>Provide the strategy with the information from a transition.</p> <p>Parameters:</p> Name Type Description Default <code>transition</code> <code>TransitionInformation</code> <p>The transition information.</p> required Source code in <code>src/model/agents/q_learning/exploration_strategies/base_strategy.py</code> <pre><code>def record_transition(self, transition: TransitionInformation) -&gt; None:\n    \"\"\"Provide the strategy with the information from a transition.\n\n    Args:\n        transition (TransitionInformation): The transition information.\n\n    \"\"\"\n</code></pre>"},{"location":"reference/model/agents/q_learning/exploration_strategies/base_strategy/#src.model.agents.q_learning.exploration_strategies.base_strategy.BaseExplorationStrategy.select_action","title":"<code>select_action(state)</code>","text":"<p>Select the action based upon this strategy.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>int</code> <p>the state where this action will be performed</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If this method has not been overridden by a concrete strategy.</p> <p>Returns:</p> Name Type Description <code>Action</code> <code>Action</code> <p>The action the agent should perform</p> Source code in <code>src/model/agents/q_learning/exploration_strategies/base_strategy.py</code> <pre><code>def select_action(self, state: int) -&gt; Action:\n    \"\"\"Select the action based upon this strategy.\n\n    Args:\n        state (int): the state where this action will be performed\n\n    Raises:\n        NotImplementedError: If this method has not been overridden by a\n            concrete strategy.\n\n    Returns:\n        Action: The action the agent should perform\n    \"\"\"\n    self.__throw_not_implemented()\n    return Action.up\n</code></pre>"},{"location":"reference/model/agents/q_learning/exploration_strategies/epsilon_greedy_strategy/","title":"Epsilon Greedy Strategy","text":""},{"location":"reference/model/agents/q_learning/exploration_strategies/epsilon_greedy_strategy/#src.model.agents.q_learning.exploration_strategies.epsilon_greedy_strategy.EpsilonGreedyStrategy","title":"<code>EpsilonGreedyStrategy</code>","text":"<p>             Bases: <code>BaseExplorationStrategy</code></p> <p>This class implements the epsilon greedy strategy.</p> <p>Selects the agents current understanding of what the best action is with a fixed probability of exploring. to explore the agent picks any action at random.</p> <p>In the case of ties this strategy selects randomly between the best options.</p> Source code in <code>src/model/agents/q_learning/exploration_strategies/epsilon_greedy_strategy.py</code> <pre><code>class EpsilonGreedyStrategy(BaseExplorationStrategy):\n    \"\"\"This class implements the epsilon greedy strategy.\n\n    Selects the agents current understanding of what the best action is with a\n    fixed probability of exploring. to explore the agent picks any action at\n    random.\n\n    In the case of ties this strategy selects randomly between the best options.\n    \"\"\"\n\n    min_safe_exploration_ratio = float(np.finfo(float).eps) * 100\n\n    def __init__(self, agent: BaseAgent) -&gt; None:\n        \"\"\"Initialise the Epsilon greedy strategy.\n\n        Args:\n            agent (BaseAgent): The agent using this strategy\n        \"\"\"\n        super().__init__(agent)\n        self.exploration_ratio = agent.hyper_parameters.get_value(\n            HyperParameter.eg_initial_exploration_ratio\n        )\n        self.decay_rate = agent.hyper_parameters.get_value(\n            HyperParameter.eg_decay_rate\n        )\n\n    def select_action(self, state: int) -&gt; Action:\n        \"\"\"Select the action based upon the epsilon greedy strategy.\n\n        this strategy picks the best action based upon the value table with a\n        given chance of selecting any action.\n\n        Args:\n            state (int): the state to select the action for.\n\n        Returns:\n            Action: the action the agent should select.\n        \"\"\"\n        if random() &lt; self.exploration_ratio:\n            return choice(list(Action))\n\n        state_action_value = self.agent.get_state_action_value\n\n        def key(action: Action) -&gt; float:\n            return state_action_value(state, action)\n\n        return max(Action, key=key)\n\n    def record_transition(self, *args: Any) -&gt; None:\n        \"\"\"Record that a transition has taken place.\n\n        this is used by this strategy to discount its parameter.\n\n        Args:\n            args (Any): not used.\n        \"\"\"\n        self.exploration_ratio = max(\n            self.exploration_ratio * self.decay_rate,\n            self.min_safe_exploration_ratio,\n        )\n</code></pre>"},{"location":"reference/model/agents/q_learning/exploration_strategies/epsilon_greedy_strategy/#src.model.agents.q_learning.exploration_strategies.epsilon_greedy_strategy.EpsilonGreedyStrategy.__init__","title":"<code>__init__(agent)</code>","text":"<p>Initialise the Epsilon greedy strategy.</p> <p>Parameters:</p> Name Type Description Default <code>agent</code> <code>BaseAgent</code> <p>The agent using this strategy</p> required Source code in <code>src/model/agents/q_learning/exploration_strategies/epsilon_greedy_strategy.py</code> <pre><code>def __init__(self, agent: BaseAgent) -&gt; None:\n    \"\"\"Initialise the Epsilon greedy strategy.\n\n    Args:\n        agent (BaseAgent): The agent using this strategy\n    \"\"\"\n    super().__init__(agent)\n    self.exploration_ratio = agent.hyper_parameters.get_value(\n        HyperParameter.eg_initial_exploration_ratio\n    )\n    self.decay_rate = agent.hyper_parameters.get_value(\n        HyperParameter.eg_decay_rate\n    )\n</code></pre>"},{"location":"reference/model/agents/q_learning/exploration_strategies/epsilon_greedy_strategy/#src.model.agents.q_learning.exploration_strategies.epsilon_greedy_strategy.EpsilonGreedyStrategy.record_transition","title":"<code>record_transition(*args)</code>","text":"<p>Record that a transition has taken place.</p> <p>this is used by this strategy to discount its parameter.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Any</code> <p>not used.</p> <code>()</code> Source code in <code>src/model/agents/q_learning/exploration_strategies/epsilon_greedy_strategy.py</code> <pre><code>def record_transition(self, *args: Any) -&gt; None:\n    \"\"\"Record that a transition has taken place.\n\n    this is used by this strategy to discount its parameter.\n\n    Args:\n        args (Any): not used.\n    \"\"\"\n    self.exploration_ratio = max(\n        self.exploration_ratio * self.decay_rate,\n        self.min_safe_exploration_ratio,\n    )\n</code></pre>"},{"location":"reference/model/agents/q_learning/exploration_strategies/epsilon_greedy_strategy/#src.model.agents.q_learning.exploration_strategies.epsilon_greedy_strategy.EpsilonGreedyStrategy.select_action","title":"<code>select_action(state)</code>","text":"<p>Select the action based upon the epsilon greedy strategy.</p> <p>this strategy picks the best action based upon the value table with a given chance of selecting any action.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>int</code> <p>the state to select the action for.</p> required <p>Returns:</p> Name Type Description <code>Action</code> <code>Action</code> <p>the action the agent should select.</p> Source code in <code>src/model/agents/q_learning/exploration_strategies/epsilon_greedy_strategy.py</code> <pre><code>def select_action(self, state: int) -&gt; Action:\n    \"\"\"Select the action based upon the epsilon greedy strategy.\n\n    this strategy picks the best action based upon the value table with a\n    given chance of selecting any action.\n\n    Args:\n        state (int): the state to select the action for.\n\n    Returns:\n        Action: the action the agent should select.\n    \"\"\"\n    if random() &lt; self.exploration_ratio:\n        return choice(list(Action))\n\n    state_action_value = self.agent.get_state_action_value\n\n    def key(action: Action) -&gt; float:\n        return state_action_value(state, action)\n\n    return max(Action, key=key)\n</code></pre>"},{"location":"reference/model/agents/q_learning/exploration_strategies/mf_bpi/","title":"Mf Bpi","text":""},{"location":"reference/model/agents/q_learning/exploration_strategies/mf_bpi/#src.model.agents.q_learning.exploration_strategies.mf_bpi.MFBPIStrategy","title":"<code>MFBPIStrategy</code>","text":"<p>             Bases: <code>BaseExplorationStrategy</code></p> <p>Model Free best policy identification strategy.</p> <p>https://openreview.net/forum?id=YEtstXIpP3</p> <p>adapted from the authors implementation: https://github.com/rssalessio/ModelFreeActiveExplorationRL/blob/main/RiverSwim/agents/mfbpi.py</p> Source code in <code>src/model/agents/q_learning/exploration_strategies/mf_bpi.py</code> <pre><code>class MFBPIStrategy(BaseExplorationStrategy):\n    \"\"\"Model Free best policy identification strategy.\n\n    https://openreview.net/forum?id=YEtstXIpP3\n\n    adapted from the authors implementation:\n    https://github.com/rssalessio/ModelFreeActiveExplorationRL/blob/main/RiverSwim/agents/mfbpi.py\n\n    \"\"\"\n\n    float_min = 1e-8\n    m_table_learning_rate_factor = 1.1\n    action_count = len(Action)\n    ensemble_subset_factor = 0.7\n\n    def __init__(self, agent: BaseAgent):\n        \"\"\"Initialise the MFBPI strategy.\n\n        Args:\n            agent (BaseAgent): the agent, mostly unused except for the max state\n                count\n        \"\"\"\n        super().__init__(agent)\n\n        # Initialize parent class with agent parameters\n        self.state_count = agent.max_state_count\n        self.discount_factor = self.agent.hyper_parameters.get_value(\n            HyperParameter.discount_rate\n        )\n        self.ensemble_size = self.agent.hyper_parameters.get_integer_value(\n            HyperParameter.mf_bpi_ensemble_size\n        )\n        error_sensitivity_parameter = (\n            self.agent.hyper_parameters.get_integer_value(\n                HyperParameter.mf_error_sensitivity\n            )\n        )\n        self.error_sensitivity: int = 2**error_sensitivity_parameter\n        self.exploration_parameter = self.agent.hyper_parameters.get_value(\n            HyperParameter.mf_exploration_parameter\n        )\n\n        self._state_visits = np.zeros(self.state_count)\n\n        # Initialize a visits matrix for each ensemble member\n        self._ensemble_state_action_visits = np.zeros(\n            (\n                self.ensemble_size,\n                self.state_count,\n                self.action_count,\n                self.state_count,\n            )\n        )\n        # Initialize policy matrix\n        self._policy = np.ones(shape=(self.state_count, self.action_count)) / (\n            self.action_count\n        )\n\n        # Initialize Q-table and M-table for each ensemble member\n        # Q -&gt; the understanding of value like normal\n        # M -&gt; the amount of uncertainty based on TD errors\n\n        tables = self.q_m_initial_value()\n        self._q_table = tables[0]\n        self._m_table = tables[1]\n\n    def q_m_initial_value(self) -&gt; Tuple[Q_table_type, Q_table_type]:\n        \"\"\"Get the initial values for the Q and M table.\n\n        Returns:\n            Tuple[Q_table_type, Q_table_type]: the initial table values. The\n                first table is the Q table and the second is the M table.\n        \"\"\"\n        non_discounted_factor = 1 - self.discount_factor\n        if self.ensemble_size == 1:\n            q_table = (\n                np.ones((1, self.state_count, self.action_count))\n                / non_discounted_factor\n            )\n            m_table = np.ones((1, self.state_count, self.action_count)) / (\n                non_discounted_factor**self.error_sensitivity\n            )\n            return q_table, m_table\n\n        q_table = (\n            np.tile(\n                np.linspace(0, 1, self.ensemble_size)[:, None, None],\n                (1, self.state_count, self.action_count),\n            )\n            / non_discounted_factor\n        )\n        m_table = np.tile(\n            np.linspace(0, 1, self.ensemble_size)[:, None, None],\n            (1, self.state_count, self.action_count),\n        ) / (non_discounted_factor**self.error_sensitivity)\n\n        q_table = q_table.flatten()\n        m_table = m_table.flatten()\n\n        # Shuffle the Q and M matrices\n        np.random.shuffle(q_table)\n        np.random.shuffle(m_table)\n\n        q_table = q_table.reshape(\n            self.ensemble_size, self.state_count, self.action_count\n        )\n        m_table = m_table.reshape(\n            self.ensemble_size, self.state_count, self.action_count\n        )\n        return q_table, m_table\n\n    def select_action(self, state: int) -&gt; Action:\n        \"\"\"Select the action for this agent to explore.\n\n        Originally called the forwards pass.\n\n        Args:\n            state (int): the state the agents action will act upon.\n\n        Returns:\n            Action: the action to be chosen.\n        \"\"\"\n        forced_exploration_probability = max(\n            self.float_min,\n            (1 / max(1, self._state_visits[state]))\n            ** self.exploration_parameter,\n        )\n        omega = (1 - forced_exploration_probability) * self._policy[\n            state\n        ] + forced_exploration_probability * np.ones((self.action_count)) / (\n            self.action_count\n        )\n\n        action_value = np.random.choice(self.action_count, p=omega)\n        return Action(action_value)\n\n    def record_transition(self, experience: TransitionInformation) -&gt; None:\n        \"\"\"Update the exploration strategy's policy with the information.\n\n        Method for backward pass (update agent).\n\n        Args:\n            experience (TransitionInformation): the information from a\n                transition.\n        \"\"\"\n        state, action, reward, new_state = (\n            experience.previous_state,\n            experience.previous_action.value,\n            experience.reward,\n            experience.new_state,\n        )\n\n        # Increment visit count for the current state pair\n        self._state_visits[state] += 1\n\n        # Randomly select a subset of the ensemble\n        indexes = np.random.choice(\n            self.ensemble_size,\n            size=int(self.ensemble_subset_factor * self.ensemble_size),\n            replace=False,\n        )\n\n        # Update visit counts\n        self._ensemble_state_action_visits[\n            indexes, state, action, new_state\n        ] += 1\n        current_visit_count = (\n            self._ensemble_state_action_visits[  # noqa: WPS204\n                indexes, state, action\n            ].sum(-1)\n        )\n        # visit count horizon exploration vs exploration\n        visit_count_horizon = 1 / (1 - self.discount_factor)\n        # learning rate for Q-values\n        q_learning_rate = (visit_count_horizon + 1) / (\n            visit_count_horizon + current_visit_count\n        )\n\n        # Compute beta_t\n        m_learning_rate = q_learning_rate**self.m_table_learning_rate_factor\n\n        # Calculate target Q value\n        target_q_value = reward + self.discount_factor * self._q_table[\n            indexes, new_state\n        ].max(-1)\n        self._q_table[indexes, state, action] = (\n            1 - q_learning_rate\n        ) * self._q_table[\n            indexes, state, action\n        ] + q_learning_rate * target_q_value\n\n        # Update M values\n        delta = (\n            reward\n            + self.discount_factor * self._q_table[indexes, new_state].max(-1)\n            - self._q_table[indexes, state, action]\n        ) / self.discount_factor\n\n        self._m_table[indexes, state, action] = (\n            1 - m_learning_rate\n        ) * self._m_table[indexes, state, action] + m_learning_rate * (\n            delta**self.error_sensitivity\n        )\n\n        # Update the ensemble head\n        self._head = np.random.choice(self.ensemble_size)\n\n        # Recompute omega values and update the policy\n        self.__compute_omega()\n\n    def __compute_omega(self):\n        \"\"\"Compute the omega values.\n\n        which are used to weight different actions in the policy based on their\n        estimated value and uncertainty.\n        \"\"\"\n        if self.ensemble_size == 1:\n            # If there's only one ensemble member, use its Q and M values\n            q_values = self._q_table[0]\n            m_values = self._m_table[0]\n        else:\n            # If there are multiple ensemble members, sample a random value from\n            # the uniform distribution\n            table_quantile = np.random.uniform()\n            q_values = np.quantile(self._q_table, table_quantile, axis=0)\n            m_values = np.quantile(self._m_table, table_quantile, axis=0)\n\n        # Compute the greedy policy\n        greedy_policy = q_values.argmax(1)\n\n        # Identify the suboptimal actions\n        subopt_action_indexes = np.array(\n            [\n                [\n                    greedy_policy[state] != action\n                    for action in range(self.action_count)\n                ]\n                for state in range(self.state_count)\n            ]\n        ).astype(np.bool_)\n\n        # Compute Delta\n        delta = np.clip(\n            (q_values.max(-1, keepdims=True) - q_values),\n            a_min=self.float_min,\n            a_max=None,\n            out=None,\n        )\n        delta_subopt = delta[subopt_action_indexes]\n        delta_min = delta_subopt.min()\n\n        # Update Delta for optimal actions\n        delta[~subopt_action_indexes] = (\n            delta_min * (1 - self.discount_factor) / (1 + self.discount_factor)\n        )\n\n        # Compute Hsa\n        # h_sa = how long the state action should\n        # be explored.\n        h_sa = (2 + 8 * golden_ratio_sq * m_values) / (delta**2)\n\n        c_value = np.max(\n            np.maximum(\n                4,\n                (4**2)\n                * (self.discount_factor**2)\n                * golden_ratio_sq\n                * m_values[~subopt_action_indexes],\n            )\n        )\n\n        h_opt = c_value / (delta[~subopt_action_indexes] ** 2)\n\n        # Update Hsa for optimal actions\n        h_sa[~subopt_action_indexes] = np.sqrt(\n            h_opt * h_sa[subopt_action_indexes].sum() / self.state_count,\n        )\n\n        # Compute omega and update policy\n        omega = h_sa / h_sa.sum()\n        self._policy = omega / omega.sum(-1, keepdims=True)\n</code></pre>"},{"location":"reference/model/agents/q_learning/exploration_strategies/mf_bpi/#src.model.agents.q_learning.exploration_strategies.mf_bpi.MFBPIStrategy.__compute_omega","title":"<code>__compute_omega()</code>","text":"<p>Compute the omega values.</p> <p>which are used to weight different actions in the policy based on their estimated value and uncertainty.</p> Source code in <code>src/model/agents/q_learning/exploration_strategies/mf_bpi.py</code> <pre><code>def __compute_omega(self):\n    \"\"\"Compute the omega values.\n\n    which are used to weight different actions in the policy based on their\n    estimated value and uncertainty.\n    \"\"\"\n    if self.ensemble_size == 1:\n        # If there's only one ensemble member, use its Q and M values\n        q_values = self._q_table[0]\n        m_values = self._m_table[0]\n    else:\n        # If there are multiple ensemble members, sample a random value from\n        # the uniform distribution\n        table_quantile = np.random.uniform()\n        q_values = np.quantile(self._q_table, table_quantile, axis=0)\n        m_values = np.quantile(self._m_table, table_quantile, axis=0)\n\n    # Compute the greedy policy\n    greedy_policy = q_values.argmax(1)\n\n    # Identify the suboptimal actions\n    subopt_action_indexes = np.array(\n        [\n            [\n                greedy_policy[state] != action\n                for action in range(self.action_count)\n            ]\n            for state in range(self.state_count)\n        ]\n    ).astype(np.bool_)\n\n    # Compute Delta\n    delta = np.clip(\n        (q_values.max(-1, keepdims=True) - q_values),\n        a_min=self.float_min,\n        a_max=None,\n        out=None,\n    )\n    delta_subopt = delta[subopt_action_indexes]\n    delta_min = delta_subopt.min()\n\n    # Update Delta for optimal actions\n    delta[~subopt_action_indexes] = (\n        delta_min * (1 - self.discount_factor) / (1 + self.discount_factor)\n    )\n\n    # Compute Hsa\n    # h_sa = how long the state action should\n    # be explored.\n    h_sa = (2 + 8 * golden_ratio_sq * m_values) / (delta**2)\n\n    c_value = np.max(\n        np.maximum(\n            4,\n            (4**2)\n            * (self.discount_factor**2)\n            * golden_ratio_sq\n            * m_values[~subopt_action_indexes],\n        )\n    )\n\n    h_opt = c_value / (delta[~subopt_action_indexes] ** 2)\n\n    # Update Hsa for optimal actions\n    h_sa[~subopt_action_indexes] = np.sqrt(\n        h_opt * h_sa[subopt_action_indexes].sum() / self.state_count,\n    )\n\n    # Compute omega and update policy\n    omega = h_sa / h_sa.sum()\n    self._policy = omega / omega.sum(-1, keepdims=True)\n</code></pre>"},{"location":"reference/model/agents/q_learning/exploration_strategies/mf_bpi/#src.model.agents.q_learning.exploration_strategies.mf_bpi.MFBPIStrategy.__init__","title":"<code>__init__(agent)</code>","text":"<p>Initialise the MFBPI strategy.</p> <p>Parameters:</p> Name Type Description Default <code>agent</code> <code>BaseAgent</code> <p>the agent, mostly unused except for the max state count</p> required Source code in <code>src/model/agents/q_learning/exploration_strategies/mf_bpi.py</code> <pre><code>def __init__(self, agent: BaseAgent):\n    \"\"\"Initialise the MFBPI strategy.\n\n    Args:\n        agent (BaseAgent): the agent, mostly unused except for the max state\n            count\n    \"\"\"\n    super().__init__(agent)\n\n    # Initialize parent class with agent parameters\n    self.state_count = agent.max_state_count\n    self.discount_factor = self.agent.hyper_parameters.get_value(\n        HyperParameter.discount_rate\n    )\n    self.ensemble_size = self.agent.hyper_parameters.get_integer_value(\n        HyperParameter.mf_bpi_ensemble_size\n    )\n    error_sensitivity_parameter = (\n        self.agent.hyper_parameters.get_integer_value(\n            HyperParameter.mf_error_sensitivity\n        )\n    )\n    self.error_sensitivity: int = 2**error_sensitivity_parameter\n    self.exploration_parameter = self.agent.hyper_parameters.get_value(\n        HyperParameter.mf_exploration_parameter\n    )\n\n    self._state_visits = np.zeros(self.state_count)\n\n    # Initialize a visits matrix for each ensemble member\n    self._ensemble_state_action_visits = np.zeros(\n        (\n            self.ensemble_size,\n            self.state_count,\n            self.action_count,\n            self.state_count,\n        )\n    )\n    # Initialize policy matrix\n    self._policy = np.ones(shape=(self.state_count, self.action_count)) / (\n        self.action_count\n    )\n\n    # Initialize Q-table and M-table for each ensemble member\n    # Q -&gt; the understanding of value like normal\n    # M -&gt; the amount of uncertainty based on TD errors\n\n    tables = self.q_m_initial_value()\n    self._q_table = tables[0]\n    self._m_table = tables[1]\n</code></pre>"},{"location":"reference/model/agents/q_learning/exploration_strategies/mf_bpi/#src.model.agents.q_learning.exploration_strategies.mf_bpi.MFBPIStrategy.q_m_initial_value","title":"<code>q_m_initial_value()</code>","text":"<p>Get the initial values for the Q and M table.</p> <p>Returns:</p> Type Description <code>Tuple[Q_table_type, Q_table_type]</code> <p>Tuple[Q_table_type, Q_table_type]: the initial table values. The first table is the Q table and the second is the M table.</p> Source code in <code>src/model/agents/q_learning/exploration_strategies/mf_bpi.py</code> <pre><code>def q_m_initial_value(self) -&gt; Tuple[Q_table_type, Q_table_type]:\n    \"\"\"Get the initial values for the Q and M table.\n\n    Returns:\n        Tuple[Q_table_type, Q_table_type]: the initial table values. The\n            first table is the Q table and the second is the M table.\n    \"\"\"\n    non_discounted_factor = 1 - self.discount_factor\n    if self.ensemble_size == 1:\n        q_table = (\n            np.ones((1, self.state_count, self.action_count))\n            / non_discounted_factor\n        )\n        m_table = np.ones((1, self.state_count, self.action_count)) / (\n            non_discounted_factor**self.error_sensitivity\n        )\n        return q_table, m_table\n\n    q_table = (\n        np.tile(\n            np.linspace(0, 1, self.ensemble_size)[:, None, None],\n            (1, self.state_count, self.action_count),\n        )\n        / non_discounted_factor\n    )\n    m_table = np.tile(\n        np.linspace(0, 1, self.ensemble_size)[:, None, None],\n        (1, self.state_count, self.action_count),\n    ) / (non_discounted_factor**self.error_sensitivity)\n\n    q_table = q_table.flatten()\n    m_table = m_table.flatten()\n\n    # Shuffle the Q and M matrices\n    np.random.shuffle(q_table)\n    np.random.shuffle(m_table)\n\n    q_table = q_table.reshape(\n        self.ensemble_size, self.state_count, self.action_count\n    )\n    m_table = m_table.reshape(\n        self.ensemble_size, self.state_count, self.action_count\n    )\n    return q_table, m_table\n</code></pre>"},{"location":"reference/model/agents/q_learning/exploration_strategies/mf_bpi/#src.model.agents.q_learning.exploration_strategies.mf_bpi.MFBPIStrategy.record_transition","title":"<code>record_transition(experience)</code>","text":"<p>Update the exploration strategy's policy with the information.</p> <p>Method for backward pass (update agent).</p> <p>Parameters:</p> Name Type Description Default <code>experience</code> <code>TransitionInformation</code> <p>the information from a transition.</p> required Source code in <code>src/model/agents/q_learning/exploration_strategies/mf_bpi.py</code> <pre><code>def record_transition(self, experience: TransitionInformation) -&gt; None:\n    \"\"\"Update the exploration strategy's policy with the information.\n\n    Method for backward pass (update agent).\n\n    Args:\n        experience (TransitionInformation): the information from a\n            transition.\n    \"\"\"\n    state, action, reward, new_state = (\n        experience.previous_state,\n        experience.previous_action.value,\n        experience.reward,\n        experience.new_state,\n    )\n\n    # Increment visit count for the current state pair\n    self._state_visits[state] += 1\n\n    # Randomly select a subset of the ensemble\n    indexes = np.random.choice(\n        self.ensemble_size,\n        size=int(self.ensemble_subset_factor * self.ensemble_size),\n        replace=False,\n    )\n\n    # Update visit counts\n    self._ensemble_state_action_visits[\n        indexes, state, action, new_state\n    ] += 1\n    current_visit_count = (\n        self._ensemble_state_action_visits[  # noqa: WPS204\n            indexes, state, action\n        ].sum(-1)\n    )\n    # visit count horizon exploration vs exploration\n    visit_count_horizon = 1 / (1 - self.discount_factor)\n    # learning rate for Q-values\n    q_learning_rate = (visit_count_horizon + 1) / (\n        visit_count_horizon + current_visit_count\n    )\n\n    # Compute beta_t\n    m_learning_rate = q_learning_rate**self.m_table_learning_rate_factor\n\n    # Calculate target Q value\n    target_q_value = reward + self.discount_factor * self._q_table[\n        indexes, new_state\n    ].max(-1)\n    self._q_table[indexes, state, action] = (\n        1 - q_learning_rate\n    ) * self._q_table[\n        indexes, state, action\n    ] + q_learning_rate * target_q_value\n\n    # Update M values\n    delta = (\n        reward\n        + self.discount_factor * self._q_table[indexes, new_state].max(-1)\n        - self._q_table[indexes, state, action]\n    ) / self.discount_factor\n\n    self._m_table[indexes, state, action] = (\n        1 - m_learning_rate\n    ) * self._m_table[indexes, state, action] + m_learning_rate * (\n        delta**self.error_sensitivity\n    )\n\n    # Update the ensemble head\n    self._head = np.random.choice(self.ensemble_size)\n\n    # Recompute omega values and update the policy\n    self.__compute_omega()\n</code></pre>"},{"location":"reference/model/agents/q_learning/exploration_strategies/mf_bpi/#src.model.agents.q_learning.exploration_strategies.mf_bpi.MFBPIStrategy.select_action","title":"<code>select_action(state)</code>","text":"<p>Select the action for this agent to explore.</p> <p>Originally called the forwards pass.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>int</code> <p>the state the agents action will act upon.</p> required <p>Returns:</p> Name Type Description <code>Action</code> <code>Action</code> <p>the action to be chosen.</p> Source code in <code>src/model/agents/q_learning/exploration_strategies/mf_bpi.py</code> <pre><code>def select_action(self, state: int) -&gt; Action:\n    \"\"\"Select the action for this agent to explore.\n\n    Originally called the forwards pass.\n\n    Args:\n        state (int): the state the agents action will act upon.\n\n    Returns:\n        Action: the action to be chosen.\n    \"\"\"\n    forced_exploration_probability = max(\n        self.float_min,\n        (1 / max(1, self._state_visits[state]))\n        ** self.exploration_parameter,\n    )\n    omega = (1 - forced_exploration_probability) * self._policy[\n        state\n    ] + forced_exploration_probability * np.ones((self.action_count)) / (\n        self.action_count\n    )\n\n    action_value = np.random.choice(self.action_count, p=omega)\n    return Action(action_value)\n</code></pre>"},{"location":"reference/model/agents/q_learning/exploration_strategies/options/","title":"Options","text":""},{"location":"reference/model/agents/q_learning/exploration_strategies/options/#src.model.agents.q_learning.exploration_strategies.options.ExplorationStrategyOptions","title":"<code>ExplorationStrategyOptions</code>","text":"<p>             Bases: <code>Enum</code></p> <p>Enumerates all exploration strategies.</p> Source code in <code>src/model/agents/q_learning/exploration_strategies/options.py</code> <pre><code>class ExplorationStrategyOptions(Enum):\n    \"\"\"Enumerates all exploration strategies.\"\"\"\n\n    not_applicable = 0\n    epsilon_greedy = 1\n    upper_confidence_bound = 2\n    mf_bpi = 3\n</code></pre>"},{"location":"reference/model/agents/q_learning/exploration_strategies/upper_confidence_bound/","title":"Upper Confidence Bound","text":""},{"location":"reference/model/agents/q_learning/exploration_strategies/upper_confidence_bound/#src.model.agents.q_learning.exploration_strategies.upper_confidence_bound.UpperConfidenceBoundStrategy","title":"<code>UpperConfidenceBoundStrategy</code>","text":"<p>             Bases: <code>BaseExplorationStrategy</code></p> <p>This class implements the upper confidence bound strategy.</p> <p>Selects the action that has the highest upper confidence bound (potential).</p> <p>In the case of ties this strategy selects randomly between the best options.</p> Source code in <code>src/model/agents/q_learning/exploration_strategies/upper_confidence_bound.py</code> <pre><code>class UpperConfidenceBoundStrategy(BaseExplorationStrategy):\n    \"\"\"This class implements the upper confidence bound strategy.\n\n    Selects the action that has the highest upper confidence bound (potential).\n\n    In the case of ties this strategy selects randomly between the best options.\n    \"\"\"\n\n    number_of_actions = len(Action)\n    initial_action_count = 0\n    # divide by zero adjustment\n    epsilon = float(np.finfo(float).eps)\n\n    def __init__(self, agent: BaseAgent) -&gt; None:\n        \"\"\"Initialise the Exploration strategy.\n\n        Args:\n            agent (BaseAgent): The agent that uses this strategy.\n        \"\"\"\n        super().__init__(agent)\n\n        self.state_action_count: defaultdict[int, int] = defaultdict(\n            lambda: self.initial_action_count\n        )\n        self.time_steps = 1\n        self.exploration_bias = self.agent.hyper_parameters.get_value(\n            HyperParameter.ucb_exploration_bias\n        )\n\n    def select_action(self, state: int) -&gt; Action:\n        \"\"\"Select the action based upon the upper confidence bound strategy.\n\n        this strategy picks the best action based upon the value table weighted\n        by a an uncertainty term.\n\n        Args:\n            state (int): the state to select the action for.\n\n        Returns:\n            Action: the action the agent should select.\n        \"\"\"\n        get_state_action_value = self.agent.get_state_action_value\n        exploration_bias = self.exploration_bias\n        state_action_count = self.state_action_count\n        epsilon = self.epsilon\n        log_time = log(self.time_steps)\n        state_index = state * self.number_of_actions\n\n        def ucb(action: Action) -&gt; float:\n            q_value = get_state_action_value(state, action)\n            action_count = (\n                state_action_count[state_index + action.value] + epsilon\n            )\n            confidence_bound = sqrt(log_time / action_count)\n            return q_value + confidence_bound * exploration_bias\n\n        return max(Action, key=ucb)\n\n    def record_transition(self, transition: TransitionInformation) -&gt; None:\n        \"\"\"Use transition information to update internal statics.\n\n        Args:\n            transition (TransitionInformation): The transition\n                information.\n\n        \"\"\"\n        key = (\n            transition.previous_state * self.number_of_actions\n            + transition.previous_action.value\n        )\n        count = self.state_action_count\n        count[key] = count[key] + 1\n        self.time_steps += 1\n</code></pre>"},{"location":"reference/model/agents/q_learning/exploration_strategies/upper_confidence_bound/#src.model.agents.q_learning.exploration_strategies.upper_confidence_bound.UpperConfidenceBoundStrategy.__init__","title":"<code>__init__(agent)</code>","text":"<p>Initialise the Exploration strategy.</p> <p>Parameters:</p> Name Type Description Default <code>agent</code> <code>BaseAgent</code> <p>The agent that uses this strategy.</p> required Source code in <code>src/model/agents/q_learning/exploration_strategies/upper_confidence_bound.py</code> <pre><code>def __init__(self, agent: BaseAgent) -&gt; None:\n    \"\"\"Initialise the Exploration strategy.\n\n    Args:\n        agent (BaseAgent): The agent that uses this strategy.\n    \"\"\"\n    super().__init__(agent)\n\n    self.state_action_count: defaultdict[int, int] = defaultdict(\n        lambda: self.initial_action_count\n    )\n    self.time_steps = 1\n    self.exploration_bias = self.agent.hyper_parameters.get_value(\n        HyperParameter.ucb_exploration_bias\n    )\n</code></pre>"},{"location":"reference/model/agents/q_learning/exploration_strategies/upper_confidence_bound/#src.model.agents.q_learning.exploration_strategies.upper_confidence_bound.UpperConfidenceBoundStrategy.record_transition","title":"<code>record_transition(transition)</code>","text":"<p>Use transition information to update internal statics.</p> <p>Parameters:</p> Name Type Description Default <code>transition</code> <code>TransitionInformation</code> <p>The transition information.</p> required Source code in <code>src/model/agents/q_learning/exploration_strategies/upper_confidence_bound.py</code> <pre><code>def record_transition(self, transition: TransitionInformation) -&gt; None:\n    \"\"\"Use transition information to update internal statics.\n\n    Args:\n        transition (TransitionInformation): The transition\n            information.\n\n    \"\"\"\n    key = (\n        transition.previous_state * self.number_of_actions\n        + transition.previous_action.value\n    )\n    count = self.state_action_count\n    count[key] = count[key] + 1\n    self.time_steps += 1\n</code></pre>"},{"location":"reference/model/agents/q_learning/exploration_strategies/upper_confidence_bound/#src.model.agents.q_learning.exploration_strategies.upper_confidence_bound.UpperConfidenceBoundStrategy.select_action","title":"<code>select_action(state)</code>","text":"<p>Select the action based upon the upper confidence bound strategy.</p> <p>this strategy picks the best action based upon the value table weighted by a an uncertainty term.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>int</code> <p>the state to select the action for.</p> required <p>Returns:</p> Name Type Description <code>Action</code> <code>Action</code> <p>the action the agent should select.</p> Source code in <code>src/model/agents/q_learning/exploration_strategies/upper_confidence_bound.py</code> <pre><code>def select_action(self, state: int) -&gt; Action:\n    \"\"\"Select the action based upon the upper confidence bound strategy.\n\n    this strategy picks the best action based upon the value table weighted\n    by a an uncertainty term.\n\n    Args:\n        state (int): the state to select the action for.\n\n    Returns:\n        Action: the action the agent should select.\n    \"\"\"\n    get_state_action_value = self.agent.get_state_action_value\n    exploration_bias = self.exploration_bias\n    state_action_count = self.state_action_count\n    epsilon = self.epsilon\n    log_time = log(self.time_steps)\n    state_index = state * self.number_of_actions\n\n    def ucb(action: Action) -&gt; float:\n        q_value = get_state_action_value(state, action)\n        action_count = (\n            state_action_count[state_index + action.value] + epsilon\n        )\n        confidence_bound = sqrt(log_time / action_count)\n        return q_value + confidence_bound * exploration_bias\n\n    return max(Action, key=ucb)\n</code></pre>"},{"location":"reference/model/agents/value_iteration/","title":"Value Iteration","text":"<p>This package contains the implementation of value iteration.</p> <p>This value iteration is used to drive an optimal agent.</p>"},{"location":"reference/model/agents/value_iteration/agent/","title":"Agent","text":""},{"location":"reference/model/agents/value_iteration/agent/#src.model.agents.value_iteration.agent.ValueIterationAgent","title":"<code>ValueIterationAgent</code>","text":"<p>             Bases: <code>BaseAgent</code></p> <p>Computes the optimal value table for a given dynamics.</p> <p>This agent uses that table with the dynamics to pick optimal actions.</p> Source code in <code>src/model/agents/value_iteration/agent.py</code> <pre><code>class ValueIterationAgent(BaseAgent):\n    \"\"\"Computes the optimal value table for a given dynamics.\n\n    This agent uses that table with the dynamics to pick optimal actions.\n    \"\"\"\n\n    def __init__(\n        self,\n        hyper_parameters: BaseHyperParameterStrategy,\n        dynamics: BaseDynamics,\n    ) -&gt; None:\n        \"\"\"Initialise the agent.\n\n        Args:\n            hyper_parameters (BaseHyperParameterStrategy): the hyper parameters\n                the agent should use.\n            dynamics (BaseDynamics): the dynamics function used to build the\n                value table and pick optimal actions\n        \"\"\"\n        super().__init__(hyper_parameters, dynamics.state_count_upper_bound())\n        self.dynamics = dynamics\n        self.stopping_epsilon = hyper_parameters.get_value(\n            HyperParameter.stopping_epsilon\n        )\n        self.discount_rate = hyper_parameters.get_value(\n            HyperParameter.discount_rate\n        )\n        sample_count = hyper_parameters.get_integer_value(\n            HyperParameter.sample_count\n        )\n        self.value_table: Optional[value_table_type] = None\n\n        self.dynamics_distribution = DynamicsDistribution(\n            sample_count, dynamics\n        )\n\n    def get_value_table(self) -&gt; value_table_type:\n        \"\"\"Get the value table for the provided dynamics.\n\n        If the value table has already been computed it will provide that. if\n        not it will compute a new value table, this can be quite costly based\n        upon the epsilon, number of states and discount rate.\n\n        Returns:\n            value_table_type: the value table for this mdp\n        \"\"\"\n        if self.value_table is not None:\n            return self.value_table\n\n        if not self.dynamics_distribution.has_compiled():\n            self.dynamics_distribution.compile()\n\n        self.value_table = self.compute_value_table()\n\n        return self.value_table\n\n    def compute_value_table(self) -&gt; value_table_type:\n        \"\"\"Compute the optimal value table with value iteration.\n\n        Returns:\n            value_table_type: the value table for the dynamics\n        \"\"\"\n        state_list = self.dynamics_distribution.list_states()\n        value_table = np.random.rand(len(state_list))\n        stopping_epsilon = self.stopping_epsilon\n        maximum_epsilon: float = 1\n        while maximum_epsilon &gt; stopping_epsilon:\n            maximum_epsilon = float(0)\n            for state in state_list:\n                new_value = self.compute_updated_value(value_table, state)\n                epsilon = abs(float(value_table[state]) - new_value)\n                value_table[state] = new_value\n                maximum_epsilon = max(epsilon, maximum_epsilon)\n        return value_table\n\n    def compute_updated_value(\n        self,\n        value_table: value_table_type,\n        state: int,\n    ) -&gt; float:\n        \"\"\"Compute the new value of the state based upon the latest value table.\n\n        Args:\n            value_table (value_table_type): our current expectation of value in\n                future states to base our estimate.\n            state (int): the state to calculate the value for.\n\n\n        Returns:\n            float: the new value for this state.\n        \"\"\"\n        action_observations = self.dynamics_distribution.observations[state]\n        state_value = float(0)\n        for action in Action:\n            state_value = max(\n                state_value,\n                self.distribution_value(\n                    action_observations[action.value],\n                    value_table,\n                ),\n            )\n        return state_value\n\n    def distribution_value(\n        self,\n        distribution: distribution_result,\n        value_table: value_table_type,\n    ) -&gt; float:\n        \"\"\"Compute the expected action-value from its distribution.\n\n        Args:\n            distribution (distribution_result): the distribution of\n                results to weight the rewards\n            value_table (value_table_type): our current expectation of value in\n                future states to base our estimate.\n\n        Returns:\n            float: the expected value for this state and action\n        \"\"\"\n        expected_value = 0\n        discount_rate = self.discount_rate\n        for next_state, (reward, frequency) in distribution.items():\n            expected_value += frequency * (\n                reward + discount_rate * value_table[next_state]\n            )\n        return expected_value\n\n    def get_state_action_value(self, state: int, action: Action) -&gt; float:\n        \"\"\"Compute the expected action-value of a given state.\n\n        Args:\n            state (int): the state the action is performed in\n            action (Action): the action to get the value of\n\n        Returns:\n            float: the expected value for this state and action\n        \"\"\"\n        value_table = self.get_value_table()\n        return self.distribution_value(\n            self.dynamics_distribution.observations[state][action.value],\n            value_table,\n        )\n\n    def get_state_value(self, state: int) -&gt; float:\n        \"\"\"Get the agents interpretation of the value of this state.\n\n        Args:\n            state (int): the state to evaluate\n\n        Returns:\n            float: the agents interpretation of the value of this state\n        \"\"\"\n        return self.get_value_table()[state]\n\n    def evaluate_policy(self, state: int) -&gt; Action:\n        \"\"\"Decide on the action this agent would take in a given state.\n\n        picks the best action based upon the value table.\n\n        Args:\n            state (int): the state the agent is performing this action\n\n\n        Returns:\n            Action: the action to take in this state\n        \"\"\"\n        best_action = random.choice(list(Action))\n        best_value = self.get_state_action_value(state, best_action)\n        # random default action to help break ties evenly\n        for action in Action:\n            if action is best_action:\n                continue\n            action_value = self.get_state_action_value(state, action)\n            if action_value &gt; best_value:\n                best_value = action_value\n                best_action = action\n\n        return best_action\n\n    def record_transition(self, *args: Any) -&gt; None:\n        \"\"\"Provide the agent with the information from a transition.\n\n        (not used by this agent)\n\n        Args:\n            args (Any): not used.\n\n        \"\"\"\n</code></pre>"},{"location":"reference/model/agents/value_iteration/agent/#src.model.agents.value_iteration.agent.ValueIterationAgent.__init__","title":"<code>__init__(hyper_parameters, dynamics)</code>","text":"<p>Initialise the agent.</p> <p>Parameters:</p> Name Type Description Default <code>hyper_parameters</code> <code>BaseHyperParameterStrategy</code> <p>the hyper parameters the agent should use.</p> required <code>dynamics</code> <code>BaseDynamics</code> <p>the dynamics function used to build the value table and pick optimal actions</p> required Source code in <code>src/model/agents/value_iteration/agent.py</code> <pre><code>def __init__(\n    self,\n    hyper_parameters: BaseHyperParameterStrategy,\n    dynamics: BaseDynamics,\n) -&gt; None:\n    \"\"\"Initialise the agent.\n\n    Args:\n        hyper_parameters (BaseHyperParameterStrategy): the hyper parameters\n            the agent should use.\n        dynamics (BaseDynamics): the dynamics function used to build the\n            value table and pick optimal actions\n    \"\"\"\n    super().__init__(hyper_parameters, dynamics.state_count_upper_bound())\n    self.dynamics = dynamics\n    self.stopping_epsilon = hyper_parameters.get_value(\n        HyperParameter.stopping_epsilon\n    )\n    self.discount_rate = hyper_parameters.get_value(\n        HyperParameter.discount_rate\n    )\n    sample_count = hyper_parameters.get_integer_value(\n        HyperParameter.sample_count\n    )\n    self.value_table: Optional[value_table_type] = None\n\n    self.dynamics_distribution = DynamicsDistribution(\n        sample_count, dynamics\n    )\n</code></pre>"},{"location":"reference/model/agents/value_iteration/agent/#src.model.agents.value_iteration.agent.ValueIterationAgent.compute_updated_value","title":"<code>compute_updated_value(value_table, state)</code>","text":"<p>Compute the new value of the state based upon the latest value table.</p> <p>Parameters:</p> Name Type Description Default <code>value_table</code> <code>value_table_type</code> <p>our current expectation of value in future states to base our estimate.</p> required <code>state</code> <code>int</code> <p>the state to calculate the value for.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the new value for this state.</p> Source code in <code>src/model/agents/value_iteration/agent.py</code> <pre><code>def compute_updated_value(\n    self,\n    value_table: value_table_type,\n    state: int,\n) -&gt; float:\n    \"\"\"Compute the new value of the state based upon the latest value table.\n\n    Args:\n        value_table (value_table_type): our current expectation of value in\n            future states to base our estimate.\n        state (int): the state to calculate the value for.\n\n\n    Returns:\n        float: the new value for this state.\n    \"\"\"\n    action_observations = self.dynamics_distribution.observations[state]\n    state_value = float(0)\n    for action in Action:\n        state_value = max(\n            state_value,\n            self.distribution_value(\n                action_observations[action.value],\n                value_table,\n            ),\n        )\n    return state_value\n</code></pre>"},{"location":"reference/model/agents/value_iteration/agent/#src.model.agents.value_iteration.agent.ValueIterationAgent.compute_value_table","title":"<code>compute_value_table()</code>","text":"<p>Compute the optimal value table with value iteration.</p> <p>Returns:</p> Name Type Description <code>value_table_type</code> <code>value_table_type</code> <p>the value table for the dynamics</p> Source code in <code>src/model/agents/value_iteration/agent.py</code> <pre><code>def compute_value_table(self) -&gt; value_table_type:\n    \"\"\"Compute the optimal value table with value iteration.\n\n    Returns:\n        value_table_type: the value table for the dynamics\n    \"\"\"\n    state_list = self.dynamics_distribution.list_states()\n    value_table = np.random.rand(len(state_list))\n    stopping_epsilon = self.stopping_epsilon\n    maximum_epsilon: float = 1\n    while maximum_epsilon &gt; stopping_epsilon:\n        maximum_epsilon = float(0)\n        for state in state_list:\n            new_value = self.compute_updated_value(value_table, state)\n            epsilon = abs(float(value_table[state]) - new_value)\n            value_table[state] = new_value\n            maximum_epsilon = max(epsilon, maximum_epsilon)\n    return value_table\n</code></pre>"},{"location":"reference/model/agents/value_iteration/agent/#src.model.agents.value_iteration.agent.ValueIterationAgent.distribution_value","title":"<code>distribution_value(distribution, value_table)</code>","text":"<p>Compute the expected action-value from its distribution.</p> <p>Parameters:</p> Name Type Description Default <code>distribution</code> <code>distribution_result</code> <p>the distribution of results to weight the rewards</p> required <code>value_table</code> <code>value_table_type</code> <p>our current expectation of value in future states to base our estimate.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the expected value for this state and action</p> Source code in <code>src/model/agents/value_iteration/agent.py</code> <pre><code>def distribution_value(\n    self,\n    distribution: distribution_result,\n    value_table: value_table_type,\n) -&gt; float:\n    \"\"\"Compute the expected action-value from its distribution.\n\n    Args:\n        distribution (distribution_result): the distribution of\n            results to weight the rewards\n        value_table (value_table_type): our current expectation of value in\n            future states to base our estimate.\n\n    Returns:\n        float: the expected value for this state and action\n    \"\"\"\n    expected_value = 0\n    discount_rate = self.discount_rate\n    for next_state, (reward, frequency) in distribution.items():\n        expected_value += frequency * (\n            reward + discount_rate * value_table[next_state]\n        )\n    return expected_value\n</code></pre>"},{"location":"reference/model/agents/value_iteration/agent/#src.model.agents.value_iteration.agent.ValueIterationAgent.evaluate_policy","title":"<code>evaluate_policy(state)</code>","text":"<p>Decide on the action this agent would take in a given state.</p> <p>picks the best action based upon the value table.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>int</code> <p>the state the agent is performing this action</p> required <p>Returns:</p> Name Type Description <code>Action</code> <code>Action</code> <p>the action to take in this state</p> Source code in <code>src/model/agents/value_iteration/agent.py</code> <pre><code>def evaluate_policy(self, state: int) -&gt; Action:\n    \"\"\"Decide on the action this agent would take in a given state.\n\n    picks the best action based upon the value table.\n\n    Args:\n        state (int): the state the agent is performing this action\n\n\n    Returns:\n        Action: the action to take in this state\n    \"\"\"\n    best_action = random.choice(list(Action))\n    best_value = self.get_state_action_value(state, best_action)\n    # random default action to help break ties evenly\n    for action in Action:\n        if action is best_action:\n            continue\n        action_value = self.get_state_action_value(state, action)\n        if action_value &gt; best_value:\n            best_value = action_value\n            best_action = action\n\n    return best_action\n</code></pre>"},{"location":"reference/model/agents/value_iteration/agent/#src.model.agents.value_iteration.agent.ValueIterationAgent.get_state_action_value","title":"<code>get_state_action_value(state, action)</code>","text":"<p>Compute the expected action-value of a given state.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>int</code> <p>the state the action is performed in</p> required <code>action</code> <code>Action</code> <p>the action to get the value of</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the expected value for this state and action</p> Source code in <code>src/model/agents/value_iteration/agent.py</code> <pre><code>def get_state_action_value(self, state: int, action: Action) -&gt; float:\n    \"\"\"Compute the expected action-value of a given state.\n\n    Args:\n        state (int): the state the action is performed in\n        action (Action): the action to get the value of\n\n    Returns:\n        float: the expected value for this state and action\n    \"\"\"\n    value_table = self.get_value_table()\n    return self.distribution_value(\n        self.dynamics_distribution.observations[state][action.value],\n        value_table,\n    )\n</code></pre>"},{"location":"reference/model/agents/value_iteration/agent/#src.model.agents.value_iteration.agent.ValueIterationAgent.get_state_value","title":"<code>get_state_value(state)</code>","text":"<p>Get the agents interpretation of the value of this state.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>int</code> <p>the state to evaluate</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the agents interpretation of the value of this state</p> Source code in <code>src/model/agents/value_iteration/agent.py</code> <pre><code>def get_state_value(self, state: int) -&gt; float:\n    \"\"\"Get the agents interpretation of the value of this state.\n\n    Args:\n        state (int): the state to evaluate\n\n    Returns:\n        float: the agents interpretation of the value of this state\n    \"\"\"\n    return self.get_value_table()[state]\n</code></pre>"},{"location":"reference/model/agents/value_iteration/agent/#src.model.agents.value_iteration.agent.ValueIterationAgent.get_value_table","title":"<code>get_value_table()</code>","text":"<p>Get the value table for the provided dynamics.</p> <p>If the value table has already been computed it will provide that. if not it will compute a new value table, this can be quite costly based upon the epsilon, number of states and discount rate.</p> <p>Returns:</p> Name Type Description <code>value_table_type</code> <code>value_table_type</code> <p>the value table for this mdp</p> Source code in <code>src/model/agents/value_iteration/agent.py</code> <pre><code>def get_value_table(self) -&gt; value_table_type:\n    \"\"\"Get the value table for the provided dynamics.\n\n    If the value table has already been computed it will provide that. if\n    not it will compute a new value table, this can be quite costly based\n    upon the epsilon, number of states and discount rate.\n\n    Returns:\n        value_table_type: the value table for this mdp\n    \"\"\"\n    if self.value_table is not None:\n        return self.value_table\n\n    if not self.dynamics_distribution.has_compiled():\n        self.dynamics_distribution.compile()\n\n    self.value_table = self.compute_value_table()\n\n    return self.value_table\n</code></pre>"},{"location":"reference/model/agents/value_iteration/agent/#src.model.agents.value_iteration.agent.ValueIterationAgent.record_transition","title":"<code>record_transition(*args)</code>","text":"<p>Provide the agent with the information from a transition.</p> <p>(not used by this agent)</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Any</code> <p>not used.</p> <code>()</code> Source code in <code>src/model/agents/value_iteration/agent.py</code> <pre><code>def record_transition(self, *args: Any) -&gt; None:\n    \"\"\"Provide the agent with the information from a transition.\n\n    (not used by this agent)\n\n    Args:\n        args (Any): not used.\n\n    \"\"\"\n</code></pre>"},{"location":"reference/model/agents/value_iteration/agent_optimised/","title":"Agent Optimised","text":""},{"location":"reference/model/agents/value_iteration/agent_optimised/#src.model.agents.value_iteration.agent_optimised.ValueIterationAgentOptimised","title":"<code>ValueIterationAgentOptimised</code>","text":"<p>             Bases: <code>ValueIterationAgent</code></p> <p>Computes the optimal value table for a given dynamics.</p> <p>This agent uses that table with the dynamics to pick optimal actions.</p> Source code in <code>src/model/agents/value_iteration/agent_optimised.py</code> <pre><code>class ValueIterationAgentOptimised(ValueIterationAgent):\n    \"\"\"Computes the optimal value table for a given dynamics.\n\n    This agent uses that table with the dynamics to pick optimal actions.\n    \"\"\"\n\n    def compute_value_table(self) -&gt; value_table_type:\n        \"\"\"Compute the optimal value table with value iteration.\n\n        Uses numba to improve performance\n\n        Returns:\n            value_table_type: the value table for the dynamics\n        \"\"\"\n        (\n            lookup_table,\n            next_state,\n            expected_reward,\n            frequency,\n        ) = self.dynamics_distribution.get_array_representation()\n        return compute_value_table(\n            self.discount_rate,\n            self.stopping_epsilon,\n            lookup_table,\n            next_state,\n            expected_reward,\n            frequency,\n        )\n</code></pre>"},{"location":"reference/model/agents/value_iteration/agent_optimised/#src.model.agents.value_iteration.agent_optimised.ValueIterationAgentOptimised.compute_value_table","title":"<code>compute_value_table()</code>","text":"<p>Compute the optimal value table with value iteration.</p> <p>Uses numba to improve performance</p> <p>Returns:</p> Name Type Description <code>value_table_type</code> <code>value_table_type</code> <p>the value table for the dynamics</p> Source code in <code>src/model/agents/value_iteration/agent_optimised.py</code> <pre><code>def compute_value_table(self) -&gt; value_table_type:\n    \"\"\"Compute the optimal value table with value iteration.\n\n    Uses numba to improve performance\n\n    Returns:\n        value_table_type: the value table for the dynamics\n    \"\"\"\n    (\n        lookup_table,\n        next_state,\n        expected_reward,\n        frequency,\n    ) = self.dynamics_distribution.get_array_representation()\n    return compute_value_table(\n        self.discount_rate,\n        self.stopping_epsilon,\n        lookup_table,\n        next_state,\n        expected_reward,\n        frequency,\n    )\n</code></pre>"},{"location":"reference/model/agents/value_iteration/agent_optimised/#src.model.agents.value_iteration.agent_optimised.compute_updated_value","title":"<code>compute_updated_value(value_table, state, discount_rate, lookup_table, next_state, expected_reward, frequency)</code>","text":"<p>Compute the new value of the state based upon the latest value table.</p> <p>Parameters:</p> Name Type Description Default <code>value_table</code> <code>value_table_type</code> <p>our current expectation of value in future states to base our estimate.</p> required <code>state</code> <code>int</code> <p>the state to calculate the value for.</p> required <code>discount_rate</code> <code>float</code> <p>The rate to discount future rewards</p> required <code>lookup_table</code> <code>numpy_int</code> <p>maps state and actions to observed transitions</p> required <code>next_state</code> <code>numpy_int</code> <p>the following state after some state and action</p> required <code>expected_reward</code> <code>numpy_float</code> <p>the average reward after completing some action.</p> required <code>frequency</code> <code>numpy_float</code> <p>The relative frequency of this transition compared to others under the same initial state and action.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the new value for this state.</p> Source code in <code>src/model/agents/value_iteration/agent_optimised.py</code> <pre><code>@jit(nopython=True, cache=True, fastmath=True)\ndef compute_updated_value(  # noqa: WPS211\n    value_table: value_table_type,\n    state: int,\n    discount_rate: float,\n    lookup_table: numpy_int,\n    next_state: numpy_int,\n    expected_reward: numpy_float,\n    frequency: numpy_float,\n) -&gt; float:\n    \"\"\"Compute the new value of the state based upon the latest value table.\n\n    Args:\n        value_table (value_table_type): our current expectation of value in\n            future states to base our estimate.\n        state (int): the state to calculate the value for.\n        discount_rate (float): The rate to discount future rewards\n        lookup_table (numpy_int): maps state and actions to observed transitions\n        next_state (numpy_int): the following state after some state and action\n        expected_reward (numpy_float): the average reward after completing some\n            action.\n        frequency (numpy_float): The relative frequency of this transition\n            compared to others under the same initial state and action.\n\n\n    Returns:\n        float: the new value for this state.\n    \"\"\"\n    state_value = -math.inf\n    for observation_range in lookup_table[state]:\n        start = observation_range[0]\n        end = observation_range[1]\n\n        subsequent_values = discount_rate * value_table[next_state[start:end]]\n        weighted_rewards = frequency[start:end] * (\n            expected_reward[start:end] + subsequent_values\n        )\n\n        state_value = max(state_value, weighted_rewards.mean())\n    return state_value\n</code></pre>"},{"location":"reference/model/agents/value_iteration/agent_optimised/#src.model.agents.value_iteration.agent_optimised.compute_value_table","title":"<code>compute_value_table(discount_rate, stopping_epsilon, lookup_table, next_state, expected_reward, frequency)</code>","text":"<p>Compute the optimal value table with value iteration.</p> <p>Parameters:</p> Name Type Description Default <code>discount_rate</code> <code>float</code> <p>The rate to discount future rewards</p> required <code>stopping_epsilon</code> <code>float</code> <p>The error amount that is acceptable.</p> required <code>lookup_table</code> <code>numpy_int</code> <p>maps state and actions to observed transitions</p> required <code>next_state</code> <code>numpy_int</code> <p>the following state after some state and action</p> required <code>expected_reward</code> <code>numpy_float</code> <p>the average reward after completing some action.</p> required <code>frequency</code> <code>numpy_float</code> <p>The relative frequency of this transition compared to others under the same initial state and action.</p> required <p>Returns:</p> Name Type Description <code>value_table_type</code> <code>value_table_type</code> <p>the value table for the dynamics</p> Source code in <code>src/model/agents/value_iteration/agent_optimised.py</code> <pre><code>@jit(nopython=True, cache=True, fastmath=True)\ndef compute_value_table(  # noqa: WPS211\n    discount_rate: float,\n    stopping_epsilon: float,\n    lookup_table: numpy_int,\n    next_state: numpy_int,\n    expected_reward: numpy_float,\n    frequency: numpy_float,\n) -&gt; value_table_type:\n    \"\"\"Compute the optimal value table with value iteration.\n\n    Args:\n        discount_rate (float): The rate to discount future rewards\n        stopping_epsilon (float): The error amount that is acceptable.\n        lookup_table (numpy_int): maps state and actions to observed transitions\n        next_state (numpy_int): the following state after some state and action\n        expected_reward (numpy_float): the average reward after completing some\n            action.\n        frequency (numpy_float): The relative frequency of this transition\n            compared to others under the same initial state and action.\n\n    Returns:\n        value_table_type: the value table for the dynamics\n    \"\"\"\n    number_of_states = lookup_table.shape[0]\n    value_table = np.random.rand(number_of_states)\n    maximum_epsilon: float = 1\n    while maximum_epsilon &gt; stopping_epsilon:\n        maximum_epsilon = 0\n        for state in range(number_of_states):\n            new_value = compute_updated_value(\n                value_table,\n                state,\n                discount_rate,\n                lookup_table,\n                next_state,\n                expected_reward,\n                frequency,\n            )\n            epsilon = abs(value_table[state] - new_value)\n            value_table[state] = new_value\n            maximum_epsilon = max(epsilon, maximum_epsilon)\n    return value_table\n</code></pre>"},{"location":"reference/model/agents/value_iteration/dynamics_distribution/","title":"Dynamics Distribution","text":""},{"location":"reference/model/agents/value_iteration/dynamics_distribution/#src.model.agents.value_iteration.dynamics_distribution.DynamicsDistribution","title":"<code>DynamicsDistribution</code>","text":"<p>             Bases: <code>object</code></p> <p>Calculates a dynamics distribution.</p> Source code in <code>src/model/agents/value_iteration/dynamics_distribution.py</code> <pre><code>class DynamicsDistribution(object):\n    \"\"\"Calculates a dynamics distribution.\"\"\"\n\n    def __init__(\n        self, per_state_sample_count: int, dynamics: BaseDynamics\n    ) -&gt; None:\n        \"\"\"Initialise the dynamics distribution.\n\n        Args:\n            per_state_sample_count (int): the number of samples to collect\n                from each state, for deterministic dynamics only one is needed.\n            dynamics (BaseDynamics): the dynamics to get the distribution for.\n        \"\"\"\n        self.sample_count = (\n            per_state_sample_count if dynamics.is_stochastic() else 1\n        )\n        self.dynamics = dynamics\n\n        # state, action, new_state -&gt; reward, freq\n        self.observations: observations_type = {}\n\n    def compute_state_action_distribution(\n        self, state: int, action: Action\n    ) -&gt; distribution_result:\n        \"\"\"Compute the subsequent distribution for a given action and state.\n\n        Args:\n            state (int): the state to to get the distribution for.\n            action (Action): the action to get the distribution for.\n\n        Returns:\n            distribution_result: the distribution of states and their\n            expected immediate rewards.\n        \"\"\"\n        observed_states: DefaultDict[int, List[float]] = defaultdict(list)\n\n        for _ in range(self.sample_count):\n            next_id, reward = self.dynamics.next_state_id(state, action)\n            observed_states[next_id].append(reward)\n\n        reduced_output: distribution_result = {}\n        for new_state, observations in observed_states.items():\n            frequency = len(observations) / self.sample_count\n            average_reward = np.array(observations).mean()\n            reduced_output[new_state] = (average_reward, frequency)\n        return reduced_output\n\n    def compile(self):\n        \"\"\"Compile the dynamics state distribution for analysis.\n\n        for some dynamics certain states are not reachable from the initial\n        state. if the initial state was changed to be one of these unreachable\n        states the distribution would need to be recalculated, and thus the\n        value table. The existing value table and distributions could be reused\n        but this is not within scope.\n        \"\"\"\n        frontier: List[int] = [self.dynamics.initial_state_id()]\n        seen_states: Set[int] = set(frontier)\n\n        seen_add = seen_states.add  # performance tweak\n        frontier_add = frontier.append\n\n        def add_states(states: Iterable[int]):\n            for state in states:\n                if state not in seen_states:\n                    seen_add(state)\n                    frontier_add(state)\n\n        while frontier:\n            current_state = frontier.pop(0)\n            current_state_observations = {}\n            self.observations[current_state] = current_state_observations\n            for action in Action:\n                distribution = self.compute_state_action_distribution(\n                    current_state, action\n                )\n                current_state_observations[action.value] = distribution\n                add_states(distribution.keys())\n\n    def has_compiled(self) -&gt; bool:\n        \"\"\"Check weather the observations have been compiled yet.\n\n        Returns:\n            bool: true when the distribution has been compiled.\n        \"\"\"\n        return bool(self.observations)\n\n    def check_compiled(self) -&gt; None:\n        \"\"\"Throw error if not compiled yet.\n\n        Raises:\n            RuntimeError: Thrown if the class has not compiled the observations.\n        \"\"\"\n        if not self.has_compiled():\n            raise RuntimeError(\"not yet compiled\")\n\n    def get_state_count(self) -&gt; int:\n        \"\"\"Get the number of states in the MDP.\n\n        Returns:\n            int: the number of states\n        \"\"\"\n        self.check_compiled()\n        return len(self.observations)\n\n    def list_states(self) -&gt; np.ndarray[Any, np.dtype[np.integer]]:\n        \"\"\"Get array of all the states.\n\n        Returns:\n            np.ndarray[Any, np.dtype[np.integer]]: all possible states as an\n            array.\n        \"\"\"\n        return np.array(list(self.observations.keys()))\n\n    def get_array_representation(\n        self,\n    ) -&gt; numpy_distribution_information_type:\n        \"\"\"Convert the observations data to an array representation.\n\n        lookup table -&gt; maps a state and action to a range of observations\n\n        the lookup table provides the start and end of a range of observed\n        subsequent states.\n\n        next state -&gt; the observed next state\n        expected_reward -&gt; the expected reward for transitioning to this state\n        frequency -&gt; how often under these state and action do we perform this\n        transition\n\n        Returns:\n            numpy_distribution_information_type: lookup_table, next_state,\n            expected_reward, frequency\n        \"\"\"\n        # 3d array state action to index the start and end of the observations\n        # states index to ranges in the corresponding arrays\n\n        empty_list_item = [None]\n\n        lookup_table: List[Any] = empty_list_item * len(self.observations)\n\n        next_state: List[Any] = []\n        expected_reward: List[Any] = []\n        frequency: List[Any] = []\n\n        for state, actions in self.observations.items():\n            state_lookup_table: List[Any] = empty_list_item * len(actions)\n            for action, observations in actions.items():\n                start = len(next_state)\n                end = start + len(observations)\n                state_lookup_table[action - 1] = [start, end]\n\n                next_state.extend(empty_list_item * len(observations))\n                expected_reward.extend(empty_list_item * len(observations))\n                frequency.extend(empty_list_item * len(observations))\n\n                for raw_index, observation in enumerate(observations.items()):\n                    (\n                        next_state_observation,\n                        (reward_observation, frequency_observation),\n                    ) = observation\n                    index = start + raw_index\n                    next_state[index] = next_state_observation\n                    expected_reward[index] = reward_observation\n                    frequency[index] = frequency_observation\n            lookup_table[state] = state_lookup_table\n\n        return (\n            np.array(lookup_table, dtype=np.int64),\n            np.array(next_state, dtype=np.int64),\n            np.array(expected_reward, dtype=np.float64),\n            np.array(frequency, dtype=np.float64),\n        )\n</code></pre>"},{"location":"reference/model/agents/value_iteration/dynamics_distribution/#src.model.agents.value_iteration.dynamics_distribution.DynamicsDistribution.__init__","title":"<code>__init__(per_state_sample_count, dynamics)</code>","text":"<p>Initialise the dynamics distribution.</p> <p>Parameters:</p> Name Type Description Default <code>per_state_sample_count</code> <code>int</code> <p>the number of samples to collect from each state, for deterministic dynamics only one is needed.</p> required <code>dynamics</code> <code>BaseDynamics</code> <p>the dynamics to get the distribution for.</p> required Source code in <code>src/model/agents/value_iteration/dynamics_distribution.py</code> <pre><code>def __init__(\n    self, per_state_sample_count: int, dynamics: BaseDynamics\n) -&gt; None:\n    \"\"\"Initialise the dynamics distribution.\n\n    Args:\n        per_state_sample_count (int): the number of samples to collect\n            from each state, for deterministic dynamics only one is needed.\n        dynamics (BaseDynamics): the dynamics to get the distribution for.\n    \"\"\"\n    self.sample_count = (\n        per_state_sample_count if dynamics.is_stochastic() else 1\n    )\n    self.dynamics = dynamics\n\n    # state, action, new_state -&gt; reward, freq\n    self.observations: observations_type = {}\n</code></pre>"},{"location":"reference/model/agents/value_iteration/dynamics_distribution/#src.model.agents.value_iteration.dynamics_distribution.DynamicsDistribution.check_compiled","title":"<code>check_compiled()</code>","text":"<p>Throw error if not compiled yet.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>Thrown if the class has not compiled the observations.</p> Source code in <code>src/model/agents/value_iteration/dynamics_distribution.py</code> <pre><code>def check_compiled(self) -&gt; None:\n    \"\"\"Throw error if not compiled yet.\n\n    Raises:\n        RuntimeError: Thrown if the class has not compiled the observations.\n    \"\"\"\n    if not self.has_compiled():\n        raise RuntimeError(\"not yet compiled\")\n</code></pre>"},{"location":"reference/model/agents/value_iteration/dynamics_distribution/#src.model.agents.value_iteration.dynamics_distribution.DynamicsDistribution.compile","title":"<code>compile()</code>","text":"<p>Compile the dynamics state distribution for analysis.</p> <p>for some dynamics certain states are not reachable from the initial state. if the initial state was changed to be one of these unreachable states the distribution would need to be recalculated, and thus the value table. The existing value table and distributions could be reused but this is not within scope.</p> Source code in <code>src/model/agents/value_iteration/dynamics_distribution.py</code> <pre><code>def compile(self):\n    \"\"\"Compile the dynamics state distribution for analysis.\n\n    for some dynamics certain states are not reachable from the initial\n    state. if the initial state was changed to be one of these unreachable\n    states the distribution would need to be recalculated, and thus the\n    value table. The existing value table and distributions could be reused\n    but this is not within scope.\n    \"\"\"\n    frontier: List[int] = [self.dynamics.initial_state_id()]\n    seen_states: Set[int] = set(frontier)\n\n    seen_add = seen_states.add  # performance tweak\n    frontier_add = frontier.append\n\n    def add_states(states: Iterable[int]):\n        for state in states:\n            if state not in seen_states:\n                seen_add(state)\n                frontier_add(state)\n\n    while frontier:\n        current_state = frontier.pop(0)\n        current_state_observations = {}\n        self.observations[current_state] = current_state_observations\n        for action in Action:\n            distribution = self.compute_state_action_distribution(\n                current_state, action\n            )\n            current_state_observations[action.value] = distribution\n            add_states(distribution.keys())\n</code></pre>"},{"location":"reference/model/agents/value_iteration/dynamics_distribution/#src.model.agents.value_iteration.dynamics_distribution.DynamicsDistribution.compute_state_action_distribution","title":"<code>compute_state_action_distribution(state, action)</code>","text":"<p>Compute the subsequent distribution for a given action and state.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>int</code> <p>the state to to get the distribution for.</p> required <code>action</code> <code>Action</code> <p>the action to get the distribution for.</p> required <p>Returns:</p> Name Type Description <code>distribution_result</code> <code>distribution_result</code> <p>the distribution of states and their</p> <code>distribution_result</code> <p>expected immediate rewards.</p> Source code in <code>src/model/agents/value_iteration/dynamics_distribution.py</code> <pre><code>def compute_state_action_distribution(\n    self, state: int, action: Action\n) -&gt; distribution_result:\n    \"\"\"Compute the subsequent distribution for a given action and state.\n\n    Args:\n        state (int): the state to to get the distribution for.\n        action (Action): the action to get the distribution for.\n\n    Returns:\n        distribution_result: the distribution of states and their\n        expected immediate rewards.\n    \"\"\"\n    observed_states: DefaultDict[int, List[float]] = defaultdict(list)\n\n    for _ in range(self.sample_count):\n        next_id, reward = self.dynamics.next_state_id(state, action)\n        observed_states[next_id].append(reward)\n\n    reduced_output: distribution_result = {}\n    for new_state, observations in observed_states.items():\n        frequency = len(observations) / self.sample_count\n        average_reward = np.array(observations).mean()\n        reduced_output[new_state] = (average_reward, frequency)\n    return reduced_output\n</code></pre>"},{"location":"reference/model/agents/value_iteration/dynamics_distribution/#src.model.agents.value_iteration.dynamics_distribution.DynamicsDistribution.get_array_representation","title":"<code>get_array_representation()</code>","text":"<p>Convert the observations data to an array representation.</p> <p>lookup table -&gt; maps a state and action to a range of observations</p> <p>the lookup table provides the start and end of a range of observed subsequent states.</p> <p>next state -&gt; the observed next state expected_reward -&gt; the expected reward for transitioning to this state frequency -&gt; how often under these state and action do we perform this transition</p> <p>Returns:</p> Name Type Description <code>numpy_distribution_information_type</code> <code>numpy_distribution_information_type</code> <p>lookup_table, next_state,</p> <code>numpy_distribution_information_type</code> <p>expected_reward, frequency</p> Source code in <code>src/model/agents/value_iteration/dynamics_distribution.py</code> <pre><code>def get_array_representation(\n    self,\n) -&gt; numpy_distribution_information_type:\n    \"\"\"Convert the observations data to an array representation.\n\n    lookup table -&gt; maps a state and action to a range of observations\n\n    the lookup table provides the start and end of a range of observed\n    subsequent states.\n\n    next state -&gt; the observed next state\n    expected_reward -&gt; the expected reward for transitioning to this state\n    frequency -&gt; how often under these state and action do we perform this\n    transition\n\n    Returns:\n        numpy_distribution_information_type: lookup_table, next_state,\n        expected_reward, frequency\n    \"\"\"\n    # 3d array state action to index the start and end of the observations\n    # states index to ranges in the corresponding arrays\n\n    empty_list_item = [None]\n\n    lookup_table: List[Any] = empty_list_item * len(self.observations)\n\n    next_state: List[Any] = []\n    expected_reward: List[Any] = []\n    frequency: List[Any] = []\n\n    for state, actions in self.observations.items():\n        state_lookup_table: List[Any] = empty_list_item * len(actions)\n        for action, observations in actions.items():\n            start = len(next_state)\n            end = start + len(observations)\n            state_lookup_table[action - 1] = [start, end]\n\n            next_state.extend(empty_list_item * len(observations))\n            expected_reward.extend(empty_list_item * len(observations))\n            frequency.extend(empty_list_item * len(observations))\n\n            for raw_index, observation in enumerate(observations.items()):\n                (\n                    next_state_observation,\n                    (reward_observation, frequency_observation),\n                ) = observation\n                index = start + raw_index\n                next_state[index] = next_state_observation\n                expected_reward[index] = reward_observation\n                frequency[index] = frequency_observation\n        lookup_table[state] = state_lookup_table\n\n    return (\n        np.array(lookup_table, dtype=np.int64),\n        np.array(next_state, dtype=np.int64),\n        np.array(expected_reward, dtype=np.float64),\n        np.array(frequency, dtype=np.float64),\n    )\n</code></pre>"},{"location":"reference/model/agents/value_iteration/dynamics_distribution/#src.model.agents.value_iteration.dynamics_distribution.DynamicsDistribution.get_state_count","title":"<code>get_state_count()</code>","text":"<p>Get the number of states in the MDP.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>the number of states</p> Source code in <code>src/model/agents/value_iteration/dynamics_distribution.py</code> <pre><code>def get_state_count(self) -&gt; int:\n    \"\"\"Get the number of states in the MDP.\n\n    Returns:\n        int: the number of states\n    \"\"\"\n    self.check_compiled()\n    return len(self.observations)\n</code></pre>"},{"location":"reference/model/agents/value_iteration/dynamics_distribution/#src.model.agents.value_iteration.dynamics_distribution.DynamicsDistribution.has_compiled","title":"<code>has_compiled()</code>","text":"<p>Check weather the observations have been compiled yet.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>true when the distribution has been compiled.</p> Source code in <code>src/model/agents/value_iteration/dynamics_distribution.py</code> <pre><code>def has_compiled(self) -&gt; bool:\n    \"\"\"Check weather the observations have been compiled yet.\n\n    Returns:\n        bool: true when the distribution has been compiled.\n    \"\"\"\n    return bool(self.observations)\n</code></pre>"},{"location":"reference/model/agents/value_iteration/dynamics_distribution/#src.model.agents.value_iteration.dynamics_distribution.DynamicsDistribution.list_states","title":"<code>list_states()</code>","text":"<p>Get array of all the states.</p> <p>Returns:</p> Type Description <code>ndarray[Any, dtype[integer]]</code> <p>np.ndarray[Any, np.dtype[np.integer]]: all possible states as an</p> <code>ndarray[Any, dtype[integer]]</code> <p>array.</p> Source code in <code>src/model/agents/value_iteration/dynamics_distribution.py</code> <pre><code>def list_states(self) -&gt; np.ndarray[Any, np.dtype[np.integer]]:\n    \"\"\"Get array of all the states.\n\n    Returns:\n        np.ndarray[Any, np.dtype[np.integer]]: all possible states as an\n        array.\n    \"\"\"\n    return np.array(list(self.observations.keys()))\n</code></pre>"},{"location":"reference/model/agents/value_iteration/types/","title":"Types","text":""},{"location":"reference/model/config/","title":"Config","text":"<p>Configuration Reader.</p> <p>This package contains the functionality for reading and validating the configuration.</p>"},{"location":"reference/model/config/base_section/","title":"Base Section","text":""},{"location":"reference/model/config/base_section/#src.model.config.base_section.BaseConfigSection","title":"<code>BaseConfigSection</code>","text":"<p>             Bases: <code>object</code></p> <p>Base class for all config section views.</p> Source code in <code>src/model/config/base_section.py</code> <pre><code>class BaseConfigSection(object):\n    \"\"\"Base class for all config section views.\"\"\"\n\n    def __init__(\n        self,\n        section_name: str,\n        schema: Dict[str, Any],\n        subsections: List[\"BaseConfigSection\"],\n    ) -&gt; None:\n        \"\"\"Instantiate the basic data required for a config section.\n\n        Args:\n            section_name (str): the name of the section as it should appear in\n                the config file\n            schema (Dict): the schema to validate the data within this\n                section.\n            subsections (Dict[str, BaseConfigSection]): any subsections in this\n                section.\n        \"\"\"\n        self.schema = schema\n        self.section_name = section_name\n        self.subsections = subsections\n        self.configuration: Any = None\n\n    def initialise(self, configuration: Any) -&gt; None:\n        \"\"\"Populate section with data.\n\n        This method lets the configuration reader to populate the view with\n        data, it also performs validation at this stage, it will through an\n        error if the data is not valid for this section\n\n        Raises:\n            Exception: thrown when the configuration file data is incorrect\n\n        Args:\n            configuration (Any): the raw configuration data to be used thought\n                the application\n        \"\"\"\n        # add the keys for the subsection so they dont cause an error\n        subsection_keys = {\n            subsection.section_name: object for subsection in self.subsections\n        }\n\n        self.configuration = Schema(\n            {**self.schema, **subsection_keys}\n        ).validate(configuration)\n\n        for subsection in self.subsections:\n            sub_configuration = configuration[subsection.section_name]\n            subsection.initialise(sub_configuration)\n</code></pre>"},{"location":"reference/model/config/base_section/#src.model.config.base_section.BaseConfigSection.__init__","title":"<code>__init__(section_name, schema, subsections)</code>","text":"<p>Instantiate the basic data required for a config section.</p> <p>Parameters:</p> Name Type Description Default <code>section_name</code> <code>str</code> <p>the name of the section as it should appear in the config file</p> required <code>schema</code> <code>Dict</code> <p>the schema to validate the data within this section.</p> required <code>subsections</code> <code>Dict[str, BaseConfigSection]</code> <p>any subsections in this section.</p> required Source code in <code>src/model/config/base_section.py</code> <pre><code>def __init__(\n    self,\n    section_name: str,\n    schema: Dict[str, Any],\n    subsections: List[\"BaseConfigSection\"],\n) -&gt; None:\n    \"\"\"Instantiate the basic data required for a config section.\n\n    Args:\n        section_name (str): the name of the section as it should appear in\n            the config file\n        schema (Dict): the schema to validate the data within this\n            section.\n        subsections (Dict[str, BaseConfigSection]): any subsections in this\n            section.\n    \"\"\"\n    self.schema = schema\n    self.section_name = section_name\n    self.subsections = subsections\n    self.configuration: Any = None\n</code></pre>"},{"location":"reference/model/config/base_section/#src.model.config.base_section.BaseConfigSection.initialise","title":"<code>initialise(configuration)</code>","text":"<p>Populate section with data.</p> <p>This method lets the configuration reader to populate the view with data, it also performs validation at this stage, it will through an error if the data is not valid for this section</p> <p>Raises:</p> Type Description <code>Exception</code> <p>thrown when the configuration file data is incorrect</p> <p>Parameters:</p> Name Type Description Default <code>configuration</code> <code>Any</code> <p>the raw configuration data to be used thought the application</p> required Source code in <code>src/model/config/base_section.py</code> <pre><code>def initialise(self, configuration: Any) -&gt; None:\n    \"\"\"Populate section with data.\n\n    This method lets the configuration reader to populate the view with\n    data, it also performs validation at this stage, it will through an\n    error if the data is not valid for this section\n\n    Raises:\n        Exception: thrown when the configuration file data is incorrect\n\n    Args:\n        configuration (Any): the raw configuration data to be used thought\n            the application\n    \"\"\"\n    # add the keys for the subsection so they dont cause an error\n    subsection_keys = {\n        subsection.section_name: object for subsection in self.subsections\n    }\n\n    self.configuration = Schema(\n        {**self.schema, **subsection_keys}\n    ).validate(configuration)\n\n    for subsection in self.subsections:\n        sub_configuration = configuration[subsection.section_name]\n        subsection.initialise(sub_configuration)\n</code></pre>"},{"location":"reference/model/config/grid_world_section/","title":"Grid World Section","text":""},{"location":"reference/model/config/grid_world_section/#src.model.config.grid_world_section.GridWorldConfig","title":"<code>GridWorldConfig</code>","text":"<p>             Bases: <code>BaseConfigSection</code></p> <p>Gets configuration related to the environment.</p> Source code in <code>src/model/config/grid_world_section.py</code> <pre><code>class GridWorldConfig(BaseConfigSection):\n    \"\"\"Gets configuration related to the environment.\"\"\"\n\n    width_property = \"width\"\n    height_property = \"height\"\n    entity_count_property = \"entity_count\"\n    location_section = \"agent_location\"\n    location_x_property = \"x\"\n    location_y_property = \"y\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Instantiate Grid world section config.\"\"\"\n        data_schema = {\n            self.width_property: int,\n            self.height_property: int,\n            self.entity_count_property: int,\n            self.location_section: {\n                self.location_x_property: int,\n                self.location_y_property: int,\n            },\n        }\n\n        super().__init__(\"grid_world\", data_schema, [])\n\n    @property\n    def width(self) -&gt; int:\n        \"\"\"Get the default width of the grid world.\n\n        Returns:\n            int: the requested width\n        \"\"\"\n        return self.configuration[self.width_property]\n\n    @property\n    def height(self) -&gt; int:\n        \"\"\"Get the default height of the grid world.\n\n        Returns:\n            int: the requested height\n        \"\"\"\n        return self.configuration[self.height_property]\n\n    @property\n    def agent_location(self) -&gt; tuple[int, int]:\n        \"\"\"Get the default agent location.\n\n        Returns:\n            tuple[int, int]: the agents location x,y\n        \"\"\"\n        pos_x = self.configuration[self.location_section][\n            self.location_x_property\n        ]\n        pos_y = self.configuration[self.location_section][\n            self.location_y_property\n        ]\n        return pos_x, pos_y\n\n    @property\n    def entity_count(self) -&gt; int:\n        \"\"\"Get the number of entities to be spawned on the grid.\n\n        Returns:\n            int: The default number of entities to be spawned\n        \"\"\"\n        return self.configuration[self.entity_count_property]\n</code></pre>"},{"location":"reference/model/config/grid_world_section/#src.model.config.grid_world_section.GridWorldConfig.agent_location","title":"<code>agent_location: tuple[int, int]</code>  <code>property</code>","text":"<p>Get the default agent location.</p> <p>Returns:</p> Type Description <code>tuple[int, int]</code> <p>tuple[int, int]: the agents location x,y</p>"},{"location":"reference/model/config/grid_world_section/#src.model.config.grid_world_section.GridWorldConfig.entity_count","title":"<code>entity_count: int</code>  <code>property</code>","text":"<p>Get the number of entities to be spawned on the grid.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The default number of entities to be spawned</p>"},{"location":"reference/model/config/grid_world_section/#src.model.config.grid_world_section.GridWorldConfig.height","title":"<code>height: int</code>  <code>property</code>","text":"<p>Get the default height of the grid world.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>the requested height</p>"},{"location":"reference/model/config/grid_world_section/#src.model.config.grid_world_section.GridWorldConfig.width","title":"<code>width: int</code>  <code>property</code>","text":"<p>Get the default width of the grid world.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>the requested width</p>"},{"location":"reference/model/config/grid_world_section/#src.model.config.grid_world_section.GridWorldConfig.__init__","title":"<code>__init__()</code>","text":"<p>Instantiate Grid world section config.</p> Source code in <code>src/model/config/grid_world_section.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Instantiate Grid world section config.\"\"\"\n    data_schema = {\n        self.width_property: int,\n        self.height_property: int,\n        self.entity_count_property: int,\n        self.location_section: {\n            self.location_x_property: int,\n            self.location_y_property: int,\n        },\n    }\n\n    super().__init__(\"grid_world\", data_schema, [])\n</code></pre>"},{"location":"reference/model/config/gui_section/","title":"Gui Section","text":""},{"location":"reference/model/config/gui_section/#src.model.config.gui_section.GUIConfig","title":"<code>GUIConfig</code>","text":"<p>             Bases: <code>BaseConfigSection</code></p> <p>Gets configuration related to the GUI.</p> Source code in <code>src/model/config/gui_section.py</code> <pre><code>class GUIConfig(BaseConfigSection):\n    \"\"\"Gets configuration related to the GUI.\"\"\"\n\n    appearance_mode_property = \"appearance_mode\"\n    color_theme_property = \"color_theme\"\n    initial_size_section = \"initial_size\"\n    width = \"width\"\n    height = \"height\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Instantiate Grid world section config.\"\"\"\n        data_schema = {\n            self.appearance_mode_property: str,\n            self.color_theme_property: str,\n            self.initial_size_section: {self.width: int, self.height: int},\n        }\n\n        super().__init__(\"gui\", data_schema, [])\n\n    @property\n    def appearance_mode(self) -&gt; str:\n        \"\"\"Get the theme style, e.g. light or dark.\n\n        Returns:\n            str: The theme style.\n        \"\"\"\n        return self.configuration[self.appearance_mode_property]\n\n    @property\n    def color_theme(self) -&gt; str:\n        \"\"\"Get the theme color.\n\n        e.g \"blue\" (standard), \"green\", \"dark-blue\"\n\n\n        Returns:\n            str: The palate color.\n        \"\"\"\n        return self.configuration[self.color_theme_property]\n\n    @property\n    def initial_size(self) -&gt; Tuple[int, int]:\n        \"\"\"Get the initial size of the window.\n\n        Returns:\n            Tuple[int, int]: the width and hight of the window\n        \"\"\"\n        section = self.configuration[self.initial_size_section]\n        return (section[self.width], section[self.height])\n</code></pre>"},{"location":"reference/model/config/gui_section/#src.model.config.gui_section.GUIConfig.appearance_mode","title":"<code>appearance_mode: str</code>  <code>property</code>","text":"<p>Get the theme style, e.g. light or dark.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The theme style.</p>"},{"location":"reference/model/config/gui_section/#src.model.config.gui_section.GUIConfig.color_theme","title":"<code>color_theme: str</code>  <code>property</code>","text":"<p>Get the theme color.</p> <p>e.g \"blue\" (standard), \"green\", \"dark-blue\"</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The palate color.</p>"},{"location":"reference/model/config/gui_section/#src.model.config.gui_section.GUIConfig.initial_size","title":"<code>initial_size: Tuple[int, int]</code>  <code>property</code>","text":"<p>Get the initial size of the window.</p> <p>Returns:</p> Type Description <code>Tuple[int, int]</code> <p>Tuple[int, int]: the width and hight of the window</p>"},{"location":"reference/model/config/gui_section/#src.model.config.gui_section.GUIConfig.__init__","title":"<code>__init__()</code>","text":"<p>Instantiate Grid world section config.</p> Source code in <code>src/model/config/gui_section.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Instantiate Grid world section config.\"\"\"\n    data_schema = {\n        self.appearance_mode_property: str,\n        self.color_theme_property: str,\n        self.initial_size_section: {self.width: int, self.height: int},\n    }\n\n    super().__init__(\"gui\", data_schema, [])\n</code></pre>"},{"location":"reference/model/config/reader/","title":"Reader","text":""},{"location":"reference/model/config/reader/#src.model.config.reader.ConfigReader","title":"<code>ConfigReader</code>","text":"<p>             Bases: <code>object</code></p> <p>Configuration Reader.</p> <p>loads the program's configuration into memory and provides access to the sections of variables within. This class is a singleton to avoid redundant loading</p> Source code in <code>src/model/config/reader.py</code> <pre><code>class ConfigReader(object):\n    \"\"\"\n    Configuration Reader.\n\n    loads the program's configuration into memory and provides access to the\n    sections of variables within. This class is a singleton to avoid redundant\n    loading\n    \"\"\"\n\n    config_file_name = \"config.toml\"\n    _instance = None\n\n    def __new__(cls) -&gt; Self:\n        \"\"\"Create a config object.\n\n        Overridden to provide the singleton patten, there must only be one\n        config object. to avoid redundant loading\n\n        Returns:\n            Self: The config object with the loaded data\n        \"\"\"\n        # https://python-patterns.guide/gang-of-four/singleton/\n        if cls._instance is None:\n            cls._instance = super().__new__(cls)\n            cls._instance.load_config()\n        return cls._instance\n\n    def load_config(self):\n        \"\"\"Load or reload the configuration from the disk.\"\"\"\n        config_file_path = path.abspath(\n            path.join(path.dirname(__file__), \"..\", \"..\", self.config_file_name)\n        )\n\n        with open(config_file_path, \"r\") as config_file:\n            self.__raw_config = toml.load(config_file)\n\n    @property\n    def grid_world(self) -&gt; GridWorldConfig:\n        \"\"\"Get the configuration for the environment.\n\n        Returns:\n            GridWorldConfig: an object that describes the environment\n            configuration\n        \"\"\"\n        return self.__initialise_section(GridWorldConfig())\n\n    @property\n    def gui(self) -&gt; GUIConfig:\n        \"\"\"Get the configuration for the GUI.\n\n        Returns:\n            GUIConfig: an object that describes the gui\n            configuration\n        \"\"\"\n        return self.__initialise_section(GUIConfig())\n\n    @property\n    def agent(self) -&gt; AgentConfig:\n        \"\"\"Get the configuration for agents.\n\n        Returns:\n            AgentConfig: an object that describes the agent\n            configuration\n        \"\"\"\n        return self.__initialise_section(AgentConfig())\n\n    def __initialise_section(self, section: BaseConfigSection) -&gt; Any:\n        \"\"\"Populate a section object with data.\n\n        This is an internal method\n\n        Args:\n            section (BaseConfigSection): the section to populate\n\n        Returns:\n            Any: the section object that has been populated\n        \"\"\"\n        section_raw_data = self.__raw_config[section.section_name]\n        section.initialise(section_raw_data)\n        return section\n</code></pre>"},{"location":"reference/model/config/reader/#src.model.config.reader.ConfigReader.agent","title":"<code>agent: AgentConfig</code>  <code>property</code>","text":"<p>Get the configuration for agents.</p> <p>Returns:</p> Name Type Description <code>AgentConfig</code> <code>AgentConfig</code> <p>an object that describes the agent</p> <code>AgentConfig</code> <p>configuration</p>"},{"location":"reference/model/config/reader/#src.model.config.reader.ConfigReader.grid_world","title":"<code>grid_world: GridWorldConfig</code>  <code>property</code>","text":"<p>Get the configuration for the environment.</p> <p>Returns:</p> Name Type Description <code>GridWorldConfig</code> <code>GridWorldConfig</code> <p>an object that describes the environment</p> <code>GridWorldConfig</code> <p>configuration</p>"},{"location":"reference/model/config/reader/#src.model.config.reader.ConfigReader.gui","title":"<code>gui: GUIConfig</code>  <code>property</code>","text":"<p>Get the configuration for the GUI.</p> <p>Returns:</p> Name Type Description <code>GUIConfig</code> <code>GUIConfig</code> <p>an object that describes the gui</p> <code>GUIConfig</code> <p>configuration</p>"},{"location":"reference/model/config/reader/#src.model.config.reader.ConfigReader.__initialise_section","title":"<code>__initialise_section(section)</code>","text":"<p>Populate a section object with data.</p> <p>This is an internal method</p> <p>Parameters:</p> Name Type Description Default <code>section</code> <code>BaseConfigSection</code> <p>the section to populate</p> required <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>the section object that has been populated</p> Source code in <code>src/model/config/reader.py</code> <pre><code>def __initialise_section(self, section: BaseConfigSection) -&gt; Any:\n    \"\"\"Populate a section object with data.\n\n    This is an internal method\n\n    Args:\n        section (BaseConfigSection): the section to populate\n\n    Returns:\n        Any: the section object that has been populated\n    \"\"\"\n    section_raw_data = self.__raw_config[section.section_name]\n    section.initialise(section_raw_data)\n    return section\n</code></pre>"},{"location":"reference/model/config/reader/#src.model.config.reader.ConfigReader.__new__","title":"<code>__new__()</code>","text":"<p>Create a config object.</p> <p>Overridden to provide the singleton patten, there must only be one config object. to avoid redundant loading</p> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The config object with the loaded data</p> Source code in <code>src/model/config/reader.py</code> <pre><code>def __new__(cls) -&gt; Self:\n    \"\"\"Create a config object.\n\n    Overridden to provide the singleton patten, there must only be one\n    config object. to avoid redundant loading\n\n    Returns:\n        Self: The config object with the loaded data\n    \"\"\"\n    # https://python-patterns.guide/gang-of-four/singleton/\n    if cls._instance is None:\n        cls._instance = super().__new__(cls)\n        cls._instance.load_config()\n    return cls._instance\n</code></pre>"},{"location":"reference/model/config/reader/#src.model.config.reader.ConfigReader.load_config","title":"<code>load_config()</code>","text":"<p>Load or reload the configuration from the disk.</p> Source code in <code>src/model/config/reader.py</code> <pre><code>def load_config(self):\n    \"\"\"Load or reload the configuration from the disk.\"\"\"\n    config_file_path = path.abspath(\n        path.join(path.dirname(__file__), \"..\", \"..\", self.config_file_name)\n    )\n\n    with open(config_file_path, \"r\") as config_file:\n        self.__raw_config = toml.load(config_file)\n</code></pre>"},{"location":"reference/model/config/agent_section/","title":"Agent Section","text":"<p>This package contains the configuration readers for agent configuration.</p>"},{"location":"reference/model/config/agent_section/agent_section/","title":"Agent Section","text":""},{"location":"reference/model/config/agent_section/agent_section/#src.model.config.agent_section.agent_section.AgentConfig","title":"<code>AgentConfig</code>","text":"<p>             Bases: <code>BaseConfigSection</code></p> <p>Gets configuration related to agents.</p> Source code in <code>src/model/config/agent_section/agent_section.py</code> <pre><code>class AgentConfig(BaseConfigSection):\n    \"\"\"Gets configuration related to agents.\"\"\"\n\n    discount_rate_property = \"discount_rate\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Instantiate agent section config.\"\"\"\n        data_schema = {\n            self.discount_rate_property: float,\n        }\n        self.q_learning = QLearningConfig()\n        self.value_iteration = ValueIterationConfig()\n\n        super().__init__(\n            \"agent\",\n            data_schema,\n            [self.q_learning, self.value_iteration],\n        )\n\n    @property\n    def discount_rate(self) -&gt; float:\n        \"\"\"Get the discount rate.\n\n        Returns:\n            float: the amount to discount future reward\n        \"\"\"\n        return self.configuration[self.discount_rate_property]\n</code></pre>"},{"location":"reference/model/config/agent_section/agent_section/#src.model.config.agent_section.agent_section.AgentConfig.discount_rate","title":"<code>discount_rate: float</code>  <code>property</code>","text":"<p>Get the discount rate.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the amount to discount future reward</p>"},{"location":"reference/model/config/agent_section/agent_section/#src.model.config.agent_section.agent_section.AgentConfig.__init__","title":"<code>__init__()</code>","text":"<p>Instantiate agent section config.</p> Source code in <code>src/model/config/agent_section/agent_section.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Instantiate agent section config.\"\"\"\n    data_schema = {\n        self.discount_rate_property: float,\n    }\n    self.q_learning = QLearningConfig()\n    self.value_iteration = ValueIterationConfig()\n\n    super().__init__(\n        \"agent\",\n        data_schema,\n        [self.q_learning, self.value_iteration],\n    )\n</code></pre>"},{"location":"reference/model/config/agent_section/epsilon_greedy/","title":"Epsilon Greedy","text":""},{"location":"reference/model/config/agent_section/epsilon_greedy/#src.model.config.agent_section.epsilon_greedy.EpsilonGreedyStrategyConfig","title":"<code>EpsilonGreedyStrategyConfig</code>","text":"<p>             Bases: <code>BaseConfigSection</code></p> <p>Gets configuration related to the epsilon greedy exploration strategy.</p> Source code in <code>src/model/config/agent_section/epsilon_greedy.py</code> <pre><code>class EpsilonGreedyStrategyConfig(BaseConfigSection):\n    \"\"\"Gets configuration related to the epsilon greedy exploration strategy.\"\"\"\n\n    exploration_ratio_property = \"initial_exploration_ratio\"\n    decay_rate_property = \"decay_rate\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Instantiate epsilon greedy section config.\"\"\"\n        data_schema = {\n            self.exploration_ratio_property: float,\n            self.decay_rate_property: float,\n        }\n\n        super().__init__(\"epsilon_greedy\", data_schema, [])\n\n    @property\n    def initial_exploration_ratio(self) -&gt; float:\n        \"\"\"Get the ratio the agent should explore vs exploit initially.\n\n        also known as epsilon in epsilon greedy and soft strategies\n\n        Returns:\n            float: the ratio for exploring, 1 represents always exploring. 0\n                never exploring.\n        \"\"\"\n        return self.configuration[self.exploration_ratio_property]\n\n    @property\n    def decay_rate(self) -&gt; float:\n        \"\"\"Get the rate at witch the exploration rate should decay.\n\n        Returns:\n            float: the ratio for decay, 1 represents no decay 0.1 represents a\n                quick decay.\n        \"\"\"\n        return self.configuration[self.decay_rate_property]\n</code></pre>"},{"location":"reference/model/config/agent_section/epsilon_greedy/#src.model.config.agent_section.epsilon_greedy.EpsilonGreedyStrategyConfig.decay_rate","title":"<code>decay_rate: float</code>  <code>property</code>","text":"<p>Get the rate at witch the exploration rate should decay.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the ratio for decay, 1 represents no decay 0.1 represents a quick decay.</p>"},{"location":"reference/model/config/agent_section/epsilon_greedy/#src.model.config.agent_section.epsilon_greedy.EpsilonGreedyStrategyConfig.initial_exploration_ratio","title":"<code>initial_exploration_ratio: float</code>  <code>property</code>","text":"<p>Get the ratio the agent should explore vs exploit initially.</p> <p>also known as epsilon in epsilon greedy and soft strategies</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the ratio for exploring, 1 represents always exploring. 0 never exploring.</p>"},{"location":"reference/model/config/agent_section/epsilon_greedy/#src.model.config.agent_section.epsilon_greedy.EpsilonGreedyStrategyConfig.__init__","title":"<code>__init__()</code>","text":"<p>Instantiate epsilon greedy section config.</p> Source code in <code>src/model/config/agent_section/epsilon_greedy.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Instantiate epsilon greedy section config.\"\"\"\n    data_schema = {\n        self.exploration_ratio_property: float,\n        self.decay_rate_property: float,\n    }\n\n    super().__init__(\"epsilon_greedy\", data_schema, [])\n</code></pre>"},{"location":"reference/model/config/agent_section/mf_bpi/","title":"Mf Bpi","text":""},{"location":"reference/model/config/agent_section/mf_bpi/#src.model.config.agent_section.mf_bpi.MFBPIConfig","title":"<code>MFBPIConfig</code>","text":"<p>             Bases: <code>BaseConfigSection</code></p> <p>Gets configuration related to the value iteration agent.</p> Source code in <code>src/model/config/agent_section/mf_bpi.py</code> <pre><code>class MFBPIConfig(BaseConfigSection):\n    \"\"\"Gets configuration related to the value iteration agent.\"\"\"\n\n    error_sensitivity_property = \"error_sensitivity\"\n    ensemble_size_property = \"ensemble_size\"\n    exploration_parameter_property = \"exploration_parameter\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Instantiate value iteration section config.\"\"\"\n        data_schema = {\n            self.error_sensitivity_property: int,\n            self.ensemble_size_property: int,\n            self.exploration_parameter_property: float,\n        }\n\n        super().__init__(\"mf_bpi\", data_schema, [])\n\n    @property\n    def error_sensitivity(self) -&gt; int:\n        \"\"\"Get the error sensitivity. Measure that effects uncertainty.\n\n        higher error sensitivity increases uncertainty, therefore more\n        exploration. although becomes more sensitive to noise.\n\n        Returns:\n            int: the sensitivity to TD errors.\n        \"\"\"\n        return self.configuration[self.error_sensitivity_property]\n\n    @property\n    def ensemble_size(self) -&gt; int:\n        \"\"\"Get the number of Q-value tables to maintain in the ensemble.\n\n        Returns:\n            int: the number of Q-value tables.\n        \"\"\"\n        return self.configuration[self.ensemble_size_property]\n\n    @property\n    def exploration_parameter(self) -&gt; float:\n        \"\"\"Get the amount of forced exploration.\n\n        Recommended value is 1, higher values equate to more exploration.\n\n        Returns:\n            float: exploration amount.\n        \"\"\"\n        return self.configuration[self.ensemble_size_property]\n</code></pre>"},{"location":"reference/model/config/agent_section/mf_bpi/#src.model.config.agent_section.mf_bpi.MFBPIConfig.ensemble_size","title":"<code>ensemble_size: int</code>  <code>property</code>","text":"<p>Get the number of Q-value tables to maintain in the ensemble.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>the number of Q-value tables.</p>"},{"location":"reference/model/config/agent_section/mf_bpi/#src.model.config.agent_section.mf_bpi.MFBPIConfig.error_sensitivity","title":"<code>error_sensitivity: int</code>  <code>property</code>","text":"<p>Get the error sensitivity. Measure that effects uncertainty.</p> <p>higher error sensitivity increases uncertainty, therefore more exploration. although becomes more sensitive to noise.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>the sensitivity to TD errors.</p>"},{"location":"reference/model/config/agent_section/mf_bpi/#src.model.config.agent_section.mf_bpi.MFBPIConfig.exploration_parameter","title":"<code>exploration_parameter: float</code>  <code>property</code>","text":"<p>Get the amount of forced exploration.</p> <p>Recommended value is 1, higher values equate to more exploration.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>exploration amount.</p>"},{"location":"reference/model/config/agent_section/mf_bpi/#src.model.config.agent_section.mf_bpi.MFBPIConfig.__init__","title":"<code>__init__()</code>","text":"<p>Instantiate value iteration section config.</p> Source code in <code>src/model/config/agent_section/mf_bpi.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Instantiate value iteration section config.\"\"\"\n    data_schema = {\n        self.error_sensitivity_property: int,\n        self.ensemble_size_property: int,\n        self.exploration_parameter_property: float,\n    }\n\n    super().__init__(\"mf_bpi\", data_schema, [])\n</code></pre>"},{"location":"reference/model/config/agent_section/q_learning/","title":"Q Learning","text":""},{"location":"reference/model/config/agent_section/q_learning/#src.model.config.agent_section.q_learning.QLearningConfig","title":"<code>QLearningConfig</code>","text":"<p>             Bases: <code>BaseConfigSection</code></p> <p>Gets configuration related to Q learning.</p> Source code in <code>src/model/config/agent_section/q_learning.py</code> <pre><code>class QLearningConfig(BaseConfigSection):\n    \"\"\"Gets configuration related to Q learning.\"\"\"\n\n    learning_rate_property = \"learning_rate\"\n    initial_optimism_property = \"initial_optimism\"\n    replay_queue_length_property = \"replay_queue_length\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Instantiate q-learning section config.\"\"\"\n        data_schema = {\n            self.learning_rate_property: float,\n            self.initial_optimism_property: float,\n            self.replay_queue_length_property: int,\n        }\n\n        self.epsilon_greedy = EpsilonGreedyStrategyConfig()\n        self.upper_confidence_bound = UCBStrategyConfig()\n        self.mf_bpi = MFBPIConfig()\n        super().__init__(\n            \"q_learning\",\n            data_schema,\n            [self.epsilon_greedy, self.upper_confidence_bound, self.mf_bpi],\n        )\n\n    @property\n    def learning_rate(self) -&gt; float:\n        \"\"\"Get the learning rate.\n\n        Returns:\n            float: the amount to update the value table with each observation\n        \"\"\"\n        return self.configuration[self.learning_rate_property]\n\n    @property\n    def initial_optimism(self) -&gt; float:\n        \"\"\"Get the initial optimism of the value table.\n\n        this is the average value of the initial guess of the q-value table\n        before any data has been collected. Could be negative for a pessimistic\n        world view.\n\n        Returns:\n            float: The average value in the value table initially.\n        \"\"\"\n        return self.configuration[self.initial_optimism_property]\n\n    @property\n    def replay_queue_length(self) -&gt; int:\n        \"\"\"Get the number of previous actions to retain in the replay queue.\n\n        Returns:\n            int: the maximum size of the replay queue.\n        \"\"\"\n        return self.configuration[self.replay_queue_length_property]\n</code></pre>"},{"location":"reference/model/config/agent_section/q_learning/#src.model.config.agent_section.q_learning.QLearningConfig.initial_optimism","title":"<code>initial_optimism: float</code>  <code>property</code>","text":"<p>Get the initial optimism of the value table.</p> <p>this is the average value of the initial guess of the q-value table before any data has been collected. Could be negative for a pessimistic world view.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The average value in the value table initially.</p>"},{"location":"reference/model/config/agent_section/q_learning/#src.model.config.agent_section.q_learning.QLearningConfig.learning_rate","title":"<code>learning_rate: float</code>  <code>property</code>","text":"<p>Get the learning rate.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the amount to update the value table with each observation</p>"},{"location":"reference/model/config/agent_section/q_learning/#src.model.config.agent_section.q_learning.QLearningConfig.replay_queue_length","title":"<code>replay_queue_length: int</code>  <code>property</code>","text":"<p>Get the number of previous actions to retain in the replay queue.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>the maximum size of the replay queue.</p>"},{"location":"reference/model/config/agent_section/q_learning/#src.model.config.agent_section.q_learning.QLearningConfig.__init__","title":"<code>__init__()</code>","text":"<p>Instantiate q-learning section config.</p> Source code in <code>src/model/config/agent_section/q_learning.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Instantiate q-learning section config.\"\"\"\n    data_schema = {\n        self.learning_rate_property: float,\n        self.initial_optimism_property: float,\n        self.replay_queue_length_property: int,\n    }\n\n    self.epsilon_greedy = EpsilonGreedyStrategyConfig()\n    self.upper_confidence_bound = UCBStrategyConfig()\n    self.mf_bpi = MFBPIConfig()\n    super().__init__(\n        \"q_learning\",\n        data_schema,\n        [self.epsilon_greedy, self.upper_confidence_bound, self.mf_bpi],\n    )\n</code></pre>"},{"location":"reference/model/config/agent_section/upper_confidence_bound/","title":"Upper Confidence Bound","text":""},{"location":"reference/model/config/agent_section/upper_confidence_bound/#src.model.config.agent_section.upper_confidence_bound.UCBStrategyConfig","title":"<code>UCBStrategyConfig</code>","text":"<p>             Bases: <code>BaseConfigSection</code></p> <p>Gets configuration related to the UCB exploration strategy.</p> Source code in <code>src/model/config/agent_section/upper_confidence_bound.py</code> <pre><code>class UCBStrategyConfig(BaseConfigSection):\n    \"\"\"Gets configuration related to the UCB exploration strategy.\"\"\"\n\n    exploration_bias_property = \"exploration_bias\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Instantiate upper confidence bound section config.\"\"\"\n        data_schema = {\n            self.exploration_bias_property: float,\n        }\n\n        super().__init__(\"upper_confidence_bound\", data_schema, [])\n\n    @property\n    def exploration_bias(self) -&gt; float:\n        \"\"\"Weighting applied to the uncertainty in the recorded data.\n\n        Higher values encourage more exploration.\n\n        Returns:\n            float: The value of potential reward.\n        \"\"\"\n        return self.configuration[self.exploration_bias_property]\n</code></pre>"},{"location":"reference/model/config/agent_section/upper_confidence_bound/#src.model.config.agent_section.upper_confidence_bound.UCBStrategyConfig.exploration_bias","title":"<code>exploration_bias: float</code>  <code>property</code>","text":"<p>Weighting applied to the uncertainty in the recorded data.</p> <p>Higher values encourage more exploration.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The value of potential reward.</p>"},{"location":"reference/model/config/agent_section/upper_confidence_bound/#src.model.config.agent_section.upper_confidence_bound.UCBStrategyConfig.__init__","title":"<code>__init__()</code>","text":"<p>Instantiate upper confidence bound section config.</p> Source code in <code>src/model/config/agent_section/upper_confidence_bound.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Instantiate upper confidence bound section config.\"\"\"\n    data_schema = {\n        self.exploration_bias_property: float,\n    }\n\n    super().__init__(\"upper_confidence_bound\", data_schema, [])\n</code></pre>"},{"location":"reference/model/config/agent_section/value_iteration/","title":"Value Iteration","text":""},{"location":"reference/model/config/agent_section/value_iteration/#src.model.config.agent_section.value_iteration.ValueIterationConfig","title":"<code>ValueIterationConfig</code>","text":"<p>             Bases: <code>BaseConfigSection</code></p> <p>Gets configuration related to the value iteration agent.</p> Source code in <code>src/model/config/agent_section/value_iteration.py</code> <pre><code>class ValueIterationConfig(BaseConfigSection):\n    \"\"\"Gets configuration related to the value iteration agent.\"\"\"\n\n    sample_count_property = \"sample_count\"\n    stopping_epsilon_property = \"stopping_epsilon\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Instantiate value iteration section config.\"\"\"\n        data_schema = {\n            self.stopping_epsilon_property: float,\n            self.sample_count_property: int,\n        }\n\n        super().__init__(\"value_iteration\", data_schema, [])\n\n    @property\n    def stopping_epsilon(self) -&gt; float:\n        \"\"\"Get the stopping epsilon.\n\n        Returns:\n            float: the maximum error allowable in a value table\n        \"\"\"\n        return self.configuration[self.stopping_epsilon_property]\n\n    @property\n    def sample_count(self) -&gt; int:\n        \"\"\"Get the sample count.\n\n        Returns:\n            int: the number of samples to use for distribution analysis.\n        \"\"\"\n        return self.configuration[self.sample_count_property]\n</code></pre>"},{"location":"reference/model/config/agent_section/value_iteration/#src.model.config.agent_section.value_iteration.ValueIterationConfig.sample_count","title":"<code>sample_count: int</code>  <code>property</code>","text":"<p>Get the sample count.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>the number of samples to use for distribution analysis.</p>"},{"location":"reference/model/config/agent_section/value_iteration/#src.model.config.agent_section.value_iteration.ValueIterationConfig.stopping_epsilon","title":"<code>stopping_epsilon: float</code>  <code>property</code>","text":"<p>Get the stopping epsilon.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the maximum error allowable in a value table</p>"},{"location":"reference/model/config/agent_section/value_iteration/#src.model.config.agent_section.value_iteration.ValueIterationConfig.__init__","title":"<code>__init__()</code>","text":"<p>Instantiate value iteration section config.</p> Source code in <code>src/model/config/agent_section/value_iteration.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Instantiate value iteration section config.\"\"\"\n    data_schema = {\n        self.stopping_epsilon_property: float,\n        self.sample_count_property: int,\n    }\n\n    super().__init__(\"value_iteration\", data_schema, [])\n</code></pre>"},{"location":"reference/model/dynamics/","title":"Dynamics","text":"<p>This package provides different dynamics models.</p>"},{"location":"reference/model/dynamics/actions/","title":"Actions","text":""},{"location":"reference/model/dynamics/actions/#src.model.dynamics.actions.Action","title":"<code>Action</code>","text":"<p>             Bases: <code>IntEnum</code></p> <p>Enumerates all possible actions.</p> Source code in <code>src/model/dynamics/actions.py</code> <pre><code>class Action(IntEnum):\n    \"\"\"Enumerates all possible actions.\"\"\"\n\n    up = 0\n    down = 1\n    left = 2\n    right = 3\n</code></pre>"},{"location":"reference/model/dynamics/base_dynamics/","title":"Base Dynamics","text":""},{"location":"reference/model/dynamics/base_dynamics/#src.model.dynamics.base_dynamics.BaseDynamics","title":"<code>BaseDynamics</code>","text":"<p>             Bases: <code>object</code></p> <p>The abstract base class for dynamics classes.</p> <p>This class provides the basic methods a dynamics class is expected to implement and some common functionality</p> Source code in <code>src/model/dynamics/base_dynamics.py</code> <pre><code>class BaseDynamics(object):\n    \"\"\"The abstract base class for dynamics classes.\n\n    This class provides the basic methods a dynamics class is expected to\n    implement and some common functionality\n    \"\"\"\n\n    def __init__(self, config: GridWorldConfig) -&gt; None:\n        \"\"\"Instantiate a dynamics, provides the minimal required properties.\n\n        Args:\n            config (GridWorldConfig): the config used by this dynamics such as\n                the size of the grid world.\n        \"\"\"\n        self.state_pool = StatePool()\n        self.config = config\n        self.grid_world = GridWorld(config.width, config.height)\n\n    def is_stochastic(self) -&gt; bool:\n        \"\"\"Determine weather the dynamics behave stochastically.\n\n        If stochastic then there is random variability in the output of `next`.\n        However variability distribution must still be markovian.\n\n        Raises:\n            NotImplementedError: If this method has not been overridden\n\n        Should Return:\n            bool: weather this dynamics behaves stochastically.\n\n        \"\"\"\n        raise NotImplementedError(\n            \"This method must be overridden by concrete dynamics classes\"\n        )\n\n    def state_count_upper_bound(self) -&gt; int:\n        \"\"\"Get an upper bound on the number of states.\n\n        used for pre-allocating memory.\n\n        Returns:\n            int: an upper bound on the number of state.\n        \"\"\"\n        return sys.maxsize\n\n    def initial_state(self) -&gt; StateInstance:\n        \"\"\"Provide the initial state of this environment.\n\n        Raises:\n            NotImplementedError: If this method has not been overridden\n\n        Should Return:\n            StateInstance: the starting state.\n        \"\"\"\n        raise NotImplementedError(\n            \"This method must be overridden by concrete dynamics classes\"\n        )\n\n    def next(\n        self, current_state: StateInstance, action: Action\n    ) -&gt; tuple[StateInstance, float]:\n        \"\"\"Compute the next state and reward.\n\n        Must only compute the next reward and state based on only the provided\n        current state and reward to obey the markov property.\n\n        Args:\n            current_state (StateInstance): the state that the action is\n                performed in\n            action (Action): the action the agent has chosen\n\n\n        Raises:\n            NotImplementedError: If this method has not been overridden\n\n        Should Return:\n            tuple[StateInstance, float]: the resulting state after the action\n            has been performed and the reward from this action\n        \"\"\"\n        raise NotImplementedError(\n            \"This method must be overridden by concrete dynamics classes\"\n        )\n\n    def initial_state_id(self) -&gt; int:\n        \"\"\"Provide the initial state id of this environment.\n\n        Raises:\n            NotImplementedError: If this method has not been overridden\n\n        Returns:\n            int: the starting state id.\n        \"\"\"\n        return self.state_pool.get_state_id(self.initial_state())\n\n    def next_state_id(\n        self, current_state_id: int, action: Action\n    ) -&gt; tuple[int, float]:\n        \"\"\"Compute the next state and reward.\n\n        Must only compute the next reward and state based on only the provided\n        current state and reward to obey the markov property.\n\n        Args:\n            current_state_id (int): the state that the action is\n                performed in\n            action (Action): the action the agent has chosen\n\n\n        Raises:\n            NotImplementedError: If this method has not been overridden\n\n        Returns:\n            tuple[int, float]: the resulting state after the action has been\n            performed and the reward from this action\n        \"\"\"\n        current_state = self.state_pool.get_state_from_id(current_state_id)\n        next_state, reward = self.next(current_state, action)\n        return self.state_pool.get_state_id(next_state), reward\n</code></pre>"},{"location":"reference/model/dynamics/base_dynamics/#src.model.dynamics.base_dynamics.BaseDynamics.__init__","title":"<code>__init__(config)</code>","text":"<p>Instantiate a dynamics, provides the minimal required properties.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>GridWorldConfig</code> <p>the config used by this dynamics such as the size of the grid world.</p> required Source code in <code>src/model/dynamics/base_dynamics.py</code> <pre><code>def __init__(self, config: GridWorldConfig) -&gt; None:\n    \"\"\"Instantiate a dynamics, provides the minimal required properties.\n\n    Args:\n        config (GridWorldConfig): the config used by this dynamics such as\n            the size of the grid world.\n    \"\"\"\n    self.state_pool = StatePool()\n    self.config = config\n    self.grid_world = GridWorld(config.width, config.height)\n</code></pre>"},{"location":"reference/model/dynamics/base_dynamics/#src.model.dynamics.base_dynamics.BaseDynamics.initial_state","title":"<code>initial_state()</code>","text":"<p>Provide the initial state of this environment.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If this method has not been overridden</p> Should Return <p>StateInstance: the starting state.</p> Source code in <code>src/model/dynamics/base_dynamics.py</code> <pre><code>def initial_state(self) -&gt; StateInstance:\n    \"\"\"Provide the initial state of this environment.\n\n    Raises:\n        NotImplementedError: If this method has not been overridden\n\n    Should Return:\n        StateInstance: the starting state.\n    \"\"\"\n    raise NotImplementedError(\n        \"This method must be overridden by concrete dynamics classes\"\n    )\n</code></pre>"},{"location":"reference/model/dynamics/base_dynamics/#src.model.dynamics.base_dynamics.BaseDynamics.initial_state_id","title":"<code>initial_state_id()</code>","text":"<p>Provide the initial state id of this environment.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If this method has not been overridden</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>the starting state id.</p> Source code in <code>src/model/dynamics/base_dynamics.py</code> <pre><code>def initial_state_id(self) -&gt; int:\n    \"\"\"Provide the initial state id of this environment.\n\n    Raises:\n        NotImplementedError: If this method has not been overridden\n\n    Returns:\n        int: the starting state id.\n    \"\"\"\n    return self.state_pool.get_state_id(self.initial_state())\n</code></pre>"},{"location":"reference/model/dynamics/base_dynamics/#src.model.dynamics.base_dynamics.BaseDynamics.is_stochastic","title":"<code>is_stochastic()</code>","text":"<p>Determine weather the dynamics behave stochastically.</p> <p>If stochastic then there is random variability in the output of <code>next</code>. However variability distribution must still be markovian.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If this method has not been overridden</p> Should Return <p>bool: weather this dynamics behaves stochastically.</p> Source code in <code>src/model/dynamics/base_dynamics.py</code> <pre><code>def is_stochastic(self) -&gt; bool:\n    \"\"\"Determine weather the dynamics behave stochastically.\n\n    If stochastic then there is random variability in the output of `next`.\n    However variability distribution must still be markovian.\n\n    Raises:\n        NotImplementedError: If this method has not been overridden\n\n    Should Return:\n        bool: weather this dynamics behaves stochastically.\n\n    \"\"\"\n    raise NotImplementedError(\n        \"This method must be overridden by concrete dynamics classes\"\n    )\n</code></pre>"},{"location":"reference/model/dynamics/base_dynamics/#src.model.dynamics.base_dynamics.BaseDynamics.next","title":"<code>next(current_state, action)</code>","text":"<p>Compute the next state and reward.</p> <p>Must only compute the next reward and state based on only the provided current state and reward to obey the markov property.</p> <p>Parameters:</p> Name Type Description Default <code>current_state</code> <code>StateInstance</code> <p>the state that the action is performed in</p> required <code>action</code> <code>Action</code> <p>the action the agent has chosen</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If this method has not been overridden</p> Should Return <p>tuple[StateInstance, float]: the resulting state after the action has been performed and the reward from this action</p> Source code in <code>src/model/dynamics/base_dynamics.py</code> <pre><code>def next(\n    self, current_state: StateInstance, action: Action\n) -&gt; tuple[StateInstance, float]:\n    \"\"\"Compute the next state and reward.\n\n    Must only compute the next reward and state based on only the provided\n    current state and reward to obey the markov property.\n\n    Args:\n        current_state (StateInstance): the state that the action is\n            performed in\n        action (Action): the action the agent has chosen\n\n\n    Raises:\n        NotImplementedError: If this method has not been overridden\n\n    Should Return:\n        tuple[StateInstance, float]: the resulting state after the action\n        has been performed and the reward from this action\n    \"\"\"\n    raise NotImplementedError(\n        \"This method must be overridden by concrete dynamics classes\"\n    )\n</code></pre>"},{"location":"reference/model/dynamics/base_dynamics/#src.model.dynamics.base_dynamics.BaseDynamics.next_state_id","title":"<code>next_state_id(current_state_id, action)</code>","text":"<p>Compute the next state and reward.</p> <p>Must only compute the next reward and state based on only the provided current state and reward to obey the markov property.</p> <p>Parameters:</p> Name Type Description Default <code>current_state_id</code> <code>int</code> <p>the state that the action is performed in</p> required <code>action</code> <code>Action</code> <p>the action the agent has chosen</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If this method has not been overridden</p> <p>Returns:</p> Type Description <code>int</code> <p>tuple[int, float]: the resulting state after the action has been</p> <code>float</code> <p>performed and the reward from this action</p> Source code in <code>src/model/dynamics/base_dynamics.py</code> <pre><code>def next_state_id(\n    self, current_state_id: int, action: Action\n) -&gt; tuple[int, float]:\n    \"\"\"Compute the next state and reward.\n\n    Must only compute the next reward and state based on only the provided\n    current state and reward to obey the markov property.\n\n    Args:\n        current_state_id (int): the state that the action is\n            performed in\n        action (Action): the action the agent has chosen\n\n\n    Raises:\n        NotImplementedError: If this method has not been overridden\n\n    Returns:\n        tuple[int, float]: the resulting state after the action has been\n        performed and the reward from this action\n    \"\"\"\n    current_state = self.state_pool.get_state_from_id(current_state_id)\n    next_state, reward = self.next(current_state, action)\n    return self.state_pool.get_state_id(next_state), reward\n</code></pre>"},{"location":"reference/model/dynamics/base_dynamics/#src.model.dynamics.base_dynamics.BaseDynamics.state_count_upper_bound","title":"<code>state_count_upper_bound()</code>","text":"<p>Get an upper bound on the number of states.</p> <p>used for pre-allocating memory.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>an upper bound on the number of state.</p> Source code in <code>src/model/dynamics/base_dynamics.py</code> <pre><code>def state_count_upper_bound(self) -&gt; int:\n    \"\"\"Get an upper bound on the number of states.\n\n    used for pre-allocating memory.\n\n    Returns:\n        int: an upper bound on the number of state.\n    \"\"\"\n    return sys.maxsize\n</code></pre>"},{"location":"reference/model/dynamics/cliff_dynamics/","title":"Cliff Dynamics","text":""},{"location":"reference/model/dynamics/cliff_dynamics/#src.model.dynamics.cliff_dynamics.CliffDynamics","title":"<code>CliffDynamics</code>","text":"<p>             Bases: <code>BaseDynamics</code></p> <p>Simple Dynamics where the agent should avoid the cliff.</p> Source code in <code>src/model/dynamics/cliff_dynamics.py</code> <pre><code>class CliffDynamics(BaseDynamics):\n    \"\"\"Simple Dynamics where the agent should avoid the cliff.\"\"\"\n\n    def __init__(self, config: GridWorldConfig) -&gt; None:\n        \"\"\"Initialise collection dynamics.\n\n        Args:\n            config (GridWorldConfig): the configuration used by this dynamics.\n        \"\"\"\n        super().__init__(config)\n        self.reset_location = (0, config.height - 1)\n\n    def is_stochastic(self) -&gt; bool:\n        \"\"\"Determine weather the dynamics behave stochastically.\n\n        Returns:\n            bool: false, this dynamics is deterministic\n        \"\"\"\n        return False\n\n    def state_count_upper_bound(self) -&gt; int:\n        \"\"\"Get an upper bound on the number of states.\n\n        used for pre-allocating memory.\n\n        Returns:\n            int: an upper bound on the number of state.\n        \"\"\"\n        return self.grid_world.width * self.grid_world.height\n\n    def initial_state(self) -&gt; StateInstance:\n        \"\"\"Provide the initial state of this environment.\n\n        Raises:\n            ValueError: if the config specifies an invalid state. such as the\n                agent location being outside the bounds of the grid.\n\n        Returns:\n            StateInstance: the starting state.\n\n        \"\"\"\n        if not self.grid_world.is_in_bounds(self.config.agent_location):\n            raise ValueError(\"config agent location outside of map bounds\")\n\n        initial_state_builder = StateBuilder().set_agent_location(\n            self.reset_location\n        )\n        cliff_y = self.config.height - 1\n        cliff_end_x = self.config.width - 1\n        for cliff_x in range(1, cliff_end_x):\n            position = (cliff_x, cliff_y)\n            initial_state_builder.set_entity(position, CellEntity.warning)\n\n        goal_position = (cliff_end_x, cliff_y)\n        initial_state_builder.set_entity(goal_position, CellEntity.goal)\n        return initial_state_builder.build()\n\n    def next(\n        self, current_state: StateInstance, action: Action\n    ) -&gt; tuple[StateInstance, float]:\n        \"\"\"Compute the next state and reward.\n\n        Must only compute the next reward and state based on only the provided\n        current state and reward to obey the markov property.\n\n        Args:\n            current_state (StateInstance): the state that the action is\n                performed in\n            action (Action): the action the agent has chosen\n\n\n        Returns:\n            tuple[StateInstance, float]: the resulting state after the action\n            has been performed and the reward from this action\n        \"\"\"\n        next_state_builder = StateBuilder(current_state)\n\n        entity = current_state.entities.get(current_state.agent_location, None)\n        if entity is not None:\n            next_state_builder.set_agent_location(self.reset_location)\n            reset_state = next_state_builder.build()\n\n            if entity is CellEntity.warning:\n                return reset_state, -100\n\n            return reset_state, 100\n\n        next_agent_location = self.grid_world.movement_action(\n            current_state.agent_location, action\n        )\n        if not self.grid_world.is_in_bounds(next_agent_location):\n            return current_state, -1\n\n        next_state_builder.set_agent_location(next_agent_location)\n\n        return next_state_builder.build(), -1\n</code></pre>"},{"location":"reference/model/dynamics/cliff_dynamics/#src.model.dynamics.cliff_dynamics.CliffDynamics.__init__","title":"<code>__init__(config)</code>","text":"<p>Initialise collection dynamics.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>GridWorldConfig</code> <p>the configuration used by this dynamics.</p> required Source code in <code>src/model/dynamics/cliff_dynamics.py</code> <pre><code>def __init__(self, config: GridWorldConfig) -&gt; None:\n    \"\"\"Initialise collection dynamics.\n\n    Args:\n        config (GridWorldConfig): the configuration used by this dynamics.\n    \"\"\"\n    super().__init__(config)\n    self.reset_location = (0, config.height - 1)\n</code></pre>"},{"location":"reference/model/dynamics/cliff_dynamics/#src.model.dynamics.cliff_dynamics.CliffDynamics.initial_state","title":"<code>initial_state()</code>","text":"<p>Provide the initial state of this environment.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if the config specifies an invalid state. such as the agent location being outside the bounds of the grid.</p> <p>Returns:</p> Name Type Description <code>StateInstance</code> <code>StateInstance</code> <p>the starting state.</p> Source code in <code>src/model/dynamics/cliff_dynamics.py</code> <pre><code>def initial_state(self) -&gt; StateInstance:\n    \"\"\"Provide the initial state of this environment.\n\n    Raises:\n        ValueError: if the config specifies an invalid state. such as the\n            agent location being outside the bounds of the grid.\n\n    Returns:\n        StateInstance: the starting state.\n\n    \"\"\"\n    if not self.grid_world.is_in_bounds(self.config.agent_location):\n        raise ValueError(\"config agent location outside of map bounds\")\n\n    initial_state_builder = StateBuilder().set_agent_location(\n        self.reset_location\n    )\n    cliff_y = self.config.height - 1\n    cliff_end_x = self.config.width - 1\n    for cliff_x in range(1, cliff_end_x):\n        position = (cliff_x, cliff_y)\n        initial_state_builder.set_entity(position, CellEntity.warning)\n\n    goal_position = (cliff_end_x, cliff_y)\n    initial_state_builder.set_entity(goal_position, CellEntity.goal)\n    return initial_state_builder.build()\n</code></pre>"},{"location":"reference/model/dynamics/cliff_dynamics/#src.model.dynamics.cliff_dynamics.CliffDynamics.is_stochastic","title":"<code>is_stochastic()</code>","text":"<p>Determine weather the dynamics behave stochastically.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>false, this dynamics is deterministic</p> Source code in <code>src/model/dynamics/cliff_dynamics.py</code> <pre><code>def is_stochastic(self) -&gt; bool:\n    \"\"\"Determine weather the dynamics behave stochastically.\n\n    Returns:\n        bool: false, this dynamics is deterministic\n    \"\"\"\n    return False\n</code></pre>"},{"location":"reference/model/dynamics/cliff_dynamics/#src.model.dynamics.cliff_dynamics.CliffDynamics.next","title":"<code>next(current_state, action)</code>","text":"<p>Compute the next state and reward.</p> <p>Must only compute the next reward and state based on only the provided current state and reward to obey the markov property.</p> <p>Parameters:</p> Name Type Description Default <code>current_state</code> <code>StateInstance</code> <p>the state that the action is performed in</p> required <code>action</code> <code>Action</code> <p>the action the agent has chosen</p> required <p>Returns:</p> Type Description <code>StateInstance</code> <p>tuple[StateInstance, float]: the resulting state after the action</p> <code>float</code> <p>has been performed and the reward from this action</p> Source code in <code>src/model/dynamics/cliff_dynamics.py</code> <pre><code>def next(\n    self, current_state: StateInstance, action: Action\n) -&gt; tuple[StateInstance, float]:\n    \"\"\"Compute the next state and reward.\n\n    Must only compute the next reward and state based on only the provided\n    current state and reward to obey the markov property.\n\n    Args:\n        current_state (StateInstance): the state that the action is\n            performed in\n        action (Action): the action the agent has chosen\n\n\n    Returns:\n        tuple[StateInstance, float]: the resulting state after the action\n        has been performed and the reward from this action\n    \"\"\"\n    next_state_builder = StateBuilder(current_state)\n\n    entity = current_state.entities.get(current_state.agent_location, None)\n    if entity is not None:\n        next_state_builder.set_agent_location(self.reset_location)\n        reset_state = next_state_builder.build()\n\n        if entity is CellEntity.warning:\n            return reset_state, -100\n\n        return reset_state, 100\n\n    next_agent_location = self.grid_world.movement_action(\n        current_state.agent_location, action\n    )\n    if not self.grid_world.is_in_bounds(next_agent_location):\n        return current_state, -1\n\n    next_state_builder.set_agent_location(next_agent_location)\n\n    return next_state_builder.build(), -1\n</code></pre>"},{"location":"reference/model/dynamics/cliff_dynamics/#src.model.dynamics.cliff_dynamics.CliffDynamics.state_count_upper_bound","title":"<code>state_count_upper_bound()</code>","text":"<p>Get an upper bound on the number of states.</p> <p>used for pre-allocating memory.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>an upper bound on the number of state.</p> Source code in <code>src/model/dynamics/cliff_dynamics.py</code> <pre><code>def state_count_upper_bound(self) -&gt; int:\n    \"\"\"Get an upper bound on the number of states.\n\n    used for pre-allocating memory.\n\n    Returns:\n        int: an upper bound on the number of state.\n    \"\"\"\n    return self.grid_world.width * self.grid_world.height\n</code></pre>"},{"location":"reference/model/dynamics/collection_dynamics/","title":"Collection Dynamics","text":""},{"location":"reference/model/dynamics/collection_dynamics/#src.model.dynamics.collection_dynamics.CollectionDynamics","title":"<code>CollectionDynamics</code>","text":"<p>             Bases: <code>BaseDynamics</code></p> <p>Simple Dynamics where the agent can move to cells to collect goals.</p> Source code in <code>src/model/dynamics/collection_dynamics.py</code> <pre><code>class CollectionDynamics(BaseDynamics):\n    \"\"\"Simple Dynamics where the agent can move to cells to collect goals.\"\"\"\n\n    location_seed = Value(c_size_t, int(time() * 10), lock=False)\n\n    def __init__(self, config: GridWorldConfig) -&gt; None:\n        \"\"\"Initialise collection dynamics.\n\n        Args:\n            config (GridWorldConfig): the configuration used by this dynamics.\n        \"\"\"\n        super().__init__(config)\n        self.spawn_positions: Optional[spawn_positions_type] = None\n\n    def is_stochastic(self) -&gt; bool:\n        \"\"\"Determine weather the dynamics behave stochastically.\n\n        Returns:\n            bool: false, this dynamics is deterministic\n        \"\"\"\n        return False\n\n    def state_count_upper_bound(self) -&gt; int:\n        \"\"\"Get an upper bound on the number of states.\n\n        used for pre-allocating memory.\n\n        Returns:\n            int: an upper bound on the number of state.\n        \"\"\"\n        return (\n            self.grid_world.width\n            * self.grid_world.height\n            * (2**self.config.entity_count)\n        )\n\n    def get_spawn_positions(self) -&gt; spawn_positions_type:\n        \"\"\"Get the positions where flags can be spawned.\n\n        these will be a number of unique positions in the grid world bounds.\n        Initially chosen at random but then fixed for subsequent calls\n\n        Returns:\n            spawn_positions_type: the set of positions where goals can be\n            spawned.\n        \"\"\"\n        generator = np.random.default_rng(self.location_seed.value)\n        if self.spawn_positions is not None:\n            return self.spawn_positions\n        agent_location = self.config.agent_location\n        self.spawn_positions = set()\n        while len(self.spawn_positions) &lt; self.config.entity_count:\n            location = self.grid_world.random_in_bounds_cell(generator)\n            if location != agent_location:\n                self.spawn_positions.add(location)\n        return self.spawn_positions\n\n    def initial_state(self) -&gt; StateInstance:\n        \"\"\"Provide the initial state of this environment.\n\n        Raises:\n            ValueError: if the config specifies an invalid state. such as the\n                agent location being outside the bounds of the grid.\n\n        Returns:\n            StateInstance: the starting state.\n\n        \"\"\"\n        if not self.grid_world.is_in_bounds(self.config.agent_location):\n            raise ValueError(\"config agent location outside of map bounds\")\n\n        initial_state_builder = StateBuilder().set_agent_location(\n            self.config.agent_location\n        )\n\n        for goal in self.get_spawn_positions():\n            initial_state_builder.set_entity(goal, CellEntity.goal)\n\n        return initial_state_builder.build()\n\n    def next(\n        self, current_state: StateInstance, action: Action\n    ) -&gt; tuple[StateInstance, float]:\n        \"\"\"Compute the next state and reward.\n\n        Must only compute the next reward and state based on only the provided\n        current state and reward to obey the markov property.\n\n        Args:\n            current_state (StateInstance): the state that the action is\n                performed in\n            action (Action): the action the agent has chosen\n\n\n        Returns:\n            tuple[StateInstance, float]: the resulting state after the action\n            has been performed and the reward from this action\n        \"\"\"\n        next_state_builder = StateBuilder(current_state)\n\n        got_goal = current_state.agent_location in current_state.entities\n        if got_goal:\n            next_state_builder.remove_entity(current_state.agent_location)\n\n            if not next_state_builder.entities:\n                # Terminal state all goals have been collected, loop to\n                # beginning to make task continuous\n                return self.initial_state(), 10\n\n        next_agent_location = self.grid_world.movement_action(\n            current_state.agent_location, action\n        )\n        if not self.grid_world.is_in_bounds(next_agent_location):\n            return next_state_builder.build(), -1\n\n        next_state_builder.set_agent_location(next_agent_location)\n\n        reward = 10 if got_goal else -1\n\n        return next_state_builder.build(), reward\n</code></pre>"},{"location":"reference/model/dynamics/collection_dynamics/#src.model.dynamics.collection_dynamics.CollectionDynamics.__init__","title":"<code>__init__(config)</code>","text":"<p>Initialise collection dynamics.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>GridWorldConfig</code> <p>the configuration used by this dynamics.</p> required Source code in <code>src/model/dynamics/collection_dynamics.py</code> <pre><code>def __init__(self, config: GridWorldConfig) -&gt; None:\n    \"\"\"Initialise collection dynamics.\n\n    Args:\n        config (GridWorldConfig): the configuration used by this dynamics.\n    \"\"\"\n    super().__init__(config)\n    self.spawn_positions: Optional[spawn_positions_type] = None\n</code></pre>"},{"location":"reference/model/dynamics/collection_dynamics/#src.model.dynamics.collection_dynamics.CollectionDynamics.get_spawn_positions","title":"<code>get_spawn_positions()</code>","text":"<p>Get the positions where flags can be spawned.</p> <p>these will be a number of unique positions in the grid world bounds. Initially chosen at random but then fixed for subsequent calls</p> <p>Returns:</p> Name Type Description <code>spawn_positions_type</code> <code>spawn_positions_type</code> <p>the set of positions where goals can be</p> <code>spawn_positions_type</code> <p>spawned.</p> Source code in <code>src/model/dynamics/collection_dynamics.py</code> <pre><code>def get_spawn_positions(self) -&gt; spawn_positions_type:\n    \"\"\"Get the positions where flags can be spawned.\n\n    these will be a number of unique positions in the grid world bounds.\n    Initially chosen at random but then fixed for subsequent calls\n\n    Returns:\n        spawn_positions_type: the set of positions where goals can be\n        spawned.\n    \"\"\"\n    generator = np.random.default_rng(self.location_seed.value)\n    if self.spawn_positions is not None:\n        return self.spawn_positions\n    agent_location = self.config.agent_location\n    self.spawn_positions = set()\n    while len(self.spawn_positions) &lt; self.config.entity_count:\n        location = self.grid_world.random_in_bounds_cell(generator)\n        if location != agent_location:\n            self.spawn_positions.add(location)\n    return self.spawn_positions\n</code></pre>"},{"location":"reference/model/dynamics/collection_dynamics/#src.model.dynamics.collection_dynamics.CollectionDynamics.initial_state","title":"<code>initial_state()</code>","text":"<p>Provide the initial state of this environment.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if the config specifies an invalid state. such as the agent location being outside the bounds of the grid.</p> <p>Returns:</p> Name Type Description <code>StateInstance</code> <code>StateInstance</code> <p>the starting state.</p> Source code in <code>src/model/dynamics/collection_dynamics.py</code> <pre><code>def initial_state(self) -&gt; StateInstance:\n    \"\"\"Provide the initial state of this environment.\n\n    Raises:\n        ValueError: if the config specifies an invalid state. such as the\n            agent location being outside the bounds of the grid.\n\n    Returns:\n        StateInstance: the starting state.\n\n    \"\"\"\n    if not self.grid_world.is_in_bounds(self.config.agent_location):\n        raise ValueError(\"config agent location outside of map bounds\")\n\n    initial_state_builder = StateBuilder().set_agent_location(\n        self.config.agent_location\n    )\n\n    for goal in self.get_spawn_positions():\n        initial_state_builder.set_entity(goal, CellEntity.goal)\n\n    return initial_state_builder.build()\n</code></pre>"},{"location":"reference/model/dynamics/collection_dynamics/#src.model.dynamics.collection_dynamics.CollectionDynamics.is_stochastic","title":"<code>is_stochastic()</code>","text":"<p>Determine weather the dynamics behave stochastically.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>false, this dynamics is deterministic</p> Source code in <code>src/model/dynamics/collection_dynamics.py</code> <pre><code>def is_stochastic(self) -&gt; bool:\n    \"\"\"Determine weather the dynamics behave stochastically.\n\n    Returns:\n        bool: false, this dynamics is deterministic\n    \"\"\"\n    return False\n</code></pre>"},{"location":"reference/model/dynamics/collection_dynamics/#src.model.dynamics.collection_dynamics.CollectionDynamics.next","title":"<code>next(current_state, action)</code>","text":"<p>Compute the next state and reward.</p> <p>Must only compute the next reward and state based on only the provided current state and reward to obey the markov property.</p> <p>Parameters:</p> Name Type Description Default <code>current_state</code> <code>StateInstance</code> <p>the state that the action is performed in</p> required <code>action</code> <code>Action</code> <p>the action the agent has chosen</p> required <p>Returns:</p> Type Description <code>StateInstance</code> <p>tuple[StateInstance, float]: the resulting state after the action</p> <code>float</code> <p>has been performed and the reward from this action</p> Source code in <code>src/model/dynamics/collection_dynamics.py</code> <pre><code>def next(\n    self, current_state: StateInstance, action: Action\n) -&gt; tuple[StateInstance, float]:\n    \"\"\"Compute the next state and reward.\n\n    Must only compute the next reward and state based on only the provided\n    current state and reward to obey the markov property.\n\n    Args:\n        current_state (StateInstance): the state that the action is\n            performed in\n        action (Action): the action the agent has chosen\n\n\n    Returns:\n        tuple[StateInstance, float]: the resulting state after the action\n        has been performed and the reward from this action\n    \"\"\"\n    next_state_builder = StateBuilder(current_state)\n\n    got_goal = current_state.agent_location in current_state.entities\n    if got_goal:\n        next_state_builder.remove_entity(current_state.agent_location)\n\n        if not next_state_builder.entities:\n            # Terminal state all goals have been collected, loop to\n            # beginning to make task continuous\n            return self.initial_state(), 10\n\n    next_agent_location = self.grid_world.movement_action(\n        current_state.agent_location, action\n    )\n    if not self.grid_world.is_in_bounds(next_agent_location):\n        return next_state_builder.build(), -1\n\n    next_state_builder.set_agent_location(next_agent_location)\n\n    reward = 10 if got_goal else -1\n\n    return next_state_builder.build(), reward\n</code></pre>"},{"location":"reference/model/dynamics/collection_dynamics/#src.model.dynamics.collection_dynamics.CollectionDynamics.state_count_upper_bound","title":"<code>state_count_upper_bound()</code>","text":"<p>Get an upper bound on the number of states.</p> <p>used for pre-allocating memory.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>an upper bound on the number of state.</p> Source code in <code>src/model/dynamics/collection_dynamics.py</code> <pre><code>def state_count_upper_bound(self) -&gt; int:\n    \"\"\"Get an upper bound on the number of states.\n\n    used for pre-allocating memory.\n\n    Returns:\n        int: an upper bound on the number of state.\n    \"\"\"\n    return (\n        self.grid_world.width\n        * self.grid_world.height\n        * (2**self.config.entity_count)\n    )\n</code></pre>"},{"location":"reference/model/dynamics/grid_world/","title":"Grid World","text":""},{"location":"reference/model/dynamics/grid_world/#src.model.dynamics.grid_world.GridWorld","title":"<code>GridWorld</code>","text":"<p>             Bases: <code>object</code></p> <p>Provide common functionality for working with a grid world.</p> Source code in <code>src/model/dynamics/grid_world.py</code> <pre><code>class GridWorld(object):\n    \"\"\"Provide common functionality for working with a grid world.\"\"\"\n\n    def __init__(self, width: int, height: int) -&gt; None:\n        \"\"\"Initialise a grid world with a given size.\n\n        Raises:\n            TypeError: If the width or height are not integers\n            ValueError: if the width or height are not positive integer\n\n        Args:\n            width (int): The width of the grid world.\n            height (int): The height of the gird world.\n        \"\"\"\n        if not isinstance(width, int) or not isinstance(height, int):\n            raise TypeError(\"width and height must be valid integers\")\n        elif width &lt; 1 or height &lt; 1:\n            raise ValueError(\"width and height must be positive integers\")\n\n        self.width = width\n        self.height = height\n\n    def is_in_bounds(self, position: tuple[int, int]) -&gt; bool:\n        \"\"\"Detect either a position is within the bounds of the grid.\n\n        Args:\n            position (tuple[int, int]): the position to test\n\n        Returns:\n            bool: true where the position is within the bounds of the grid\n            world.\n        \"\"\"\n        x_pos, y_pos = position\n        return 0 &lt;= x_pos &lt; self.width and 0 &lt;= y_pos &lt; self.height\n\n    def random_in_bounds_cell(\n        self, random_generator: Optional[RandomGenerator] = None\n    ) -&gt; tuple[int, int]:\n        \"\"\"Generate a random cell position that is within bounds.\n\n        Args:\n            random_generator (Optional[RandomGenerator]): an optional random\n                generator to pick the positions from.\n\n        Returns:\n            tuple[int, int]: the cell position within the grid.\n        \"\"\"\n        if random_generator is None:\n            random_generator = np.random.default_rng()\n        dimensions = np.array([self.width, self.height])\n        position_float = random_generator.random(2) * dimensions\n        position_integer = np.floor(position_float).astype(int)\n        return (position_integer[0], position_integer[1])\n\n    action_direction: Dict[Action, integer_position] = {\n        Action.up: (0, -1),\n        Action.down: (0, 1),\n        Action.right: (1, 0),\n        Action.left: (-1, 0),\n    }\n\n    def movement_action(\n        self,\n        current_position: integer_position,\n        action: Action,\n        distance: int = 1,\n    ) -&gt; integer_position:\n        \"\"\"Calculate the adjacent cell in a given direction.\n\n        The direction is provided from the up,down,left and right actions. This\n        method calculates the next position assuming the origin is at the top\n        left of the grid.\n\n        note this may compute a cell that is out of bounds, to check and handel\n        this please use `is_in_bounds` method.\n\n        Args:\n            current_position (integer_position): the position to start from.\n            action (Action): provides the direction to move in.\n            distance (int): the amount of cells to move. Defaults to 1.\n\n        Raises:\n            ValueError: If the action provided is not a known movement action.\n\n        Returns:\n            integer_position: The position after moving.\n        \"\"\"\n        x_pos, y_pos = current_position\n        dir_x, dir_y = self.action_direction[action]\n        return (x_pos + dir_x * distance, y_pos + dir_y * distance)\n\n    def list_cells(self) -&gt; Generator[integer_position, None, None]:\n        \"\"\"Generate all cells in the grid world.\n\n        Yields:\n            Generator[integer_position, None, None]: each cell location\n        \"\"\"\n        for y_pos in range(self.height):\n            yield from ((x_pos, y_pos) for x_pos in range(self.width))\n\n    def get_cell_sizing(\n        self, width: int, height: int, relative_margins: float\n    ) -&gt; Tuple[int, int]:\n        \"\"\"Get the sizing of a cell in the given rectangle and margins.\n\n        Args:\n            width (int): the width of the containing rectangle\n            height (int): the hight of the containing rectangle\n            relative_margins (float): how large should the gap between cells be.\n                relative to the size of a cell with no margins\n\n        Returns:\n            Tuple[int, int]: the cell size and the margin size\n        \"\"\"\n        rows = self.height\n        columns = self.width\n\n        content_ratio = rows / columns\n        container_ratio = height / width\n\n        cell_spacing = int(\n            width / columns\n            if container_ratio &gt; content_ratio\n            else height / rows\n        )\n        margins = int(max(cell_spacing * relative_margins, 1))\n        return cell_spacing, margins\n\n    def list_cell_positions(\n        self, width: int, height: int, relative_margins: float\n    ) -&gt; location_generator:\n        \"\"\"Generate the cell locations in a given rectangle.\n\n        the cells will be centred if there is the aspect ratio's are not aligned\n\n        returns the cell position in gird world coordinates, the location of\n        corner that is closest to the origin then the corner that is the\n        furthest.\n\n        assumes cells should be square.\n\n        Args:\n            width (int): the width of the containing rectangle\n            height (int): the hight of the containing rectangle\n            relative_margins (float): how large should the gap between cells be.\n                relative to the size of a cell with no margins\n\n        Yields:\n            Iterator[location_generator]: the coordinates\n        \"\"\"\n        rows = self.height\n        columns = self.width\n\n        cell_spacing, margins = self.get_cell_sizing(\n            width, height, relative_margins\n        )\n\n        offset_min_x = int((width - columns * cell_spacing) / 2)\n        offset_min_y = int((height - rows * cell_spacing) / 2)\n\n        offset_min_x += margins // 2\n        offset_min_y += margins // 2\n\n        offset_max_x = offset_min_x + cell_spacing - margins\n        offset_max_y = offset_min_y + cell_spacing - margins\n\n        for pos in self.list_cells():\n            bounding_box = (\n                offset_min_x + cell_spacing * pos[0],\n                offset_min_y + cell_spacing * pos[1],\n                offset_max_x + cell_spacing * pos[0],\n                offset_max_y + cell_spacing * pos[1],\n            )\n            yield pos, bounding_box\n</code></pre>"},{"location":"reference/model/dynamics/grid_world/#src.model.dynamics.grid_world.GridWorld.__init__","title":"<code>__init__(width, height)</code>","text":"<p>Initialise a grid world with a given size.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If the width or height are not integers</p> <code>ValueError</code> <p>if the width or height are not positive integer</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>The width of the grid world.</p> required <code>height</code> <code>int</code> <p>The height of the gird world.</p> required Source code in <code>src/model/dynamics/grid_world.py</code> <pre><code>def __init__(self, width: int, height: int) -&gt; None:\n    \"\"\"Initialise a grid world with a given size.\n\n    Raises:\n        TypeError: If the width or height are not integers\n        ValueError: if the width or height are not positive integer\n\n    Args:\n        width (int): The width of the grid world.\n        height (int): The height of the gird world.\n    \"\"\"\n    if not isinstance(width, int) or not isinstance(height, int):\n        raise TypeError(\"width and height must be valid integers\")\n    elif width &lt; 1 or height &lt; 1:\n        raise ValueError(\"width and height must be positive integers\")\n\n    self.width = width\n    self.height = height\n</code></pre>"},{"location":"reference/model/dynamics/grid_world/#src.model.dynamics.grid_world.GridWorld.get_cell_sizing","title":"<code>get_cell_sizing(width, height, relative_margins)</code>","text":"<p>Get the sizing of a cell in the given rectangle and margins.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>the width of the containing rectangle</p> required <code>height</code> <code>int</code> <p>the hight of the containing rectangle</p> required <code>relative_margins</code> <code>float</code> <p>how large should the gap between cells be. relative to the size of a cell with no margins</p> required <p>Returns:</p> Type Description <code>Tuple[int, int]</code> <p>Tuple[int, int]: the cell size and the margin size</p> Source code in <code>src/model/dynamics/grid_world.py</code> <pre><code>def get_cell_sizing(\n    self, width: int, height: int, relative_margins: float\n) -&gt; Tuple[int, int]:\n    \"\"\"Get the sizing of a cell in the given rectangle and margins.\n\n    Args:\n        width (int): the width of the containing rectangle\n        height (int): the hight of the containing rectangle\n        relative_margins (float): how large should the gap between cells be.\n            relative to the size of a cell with no margins\n\n    Returns:\n        Tuple[int, int]: the cell size and the margin size\n    \"\"\"\n    rows = self.height\n    columns = self.width\n\n    content_ratio = rows / columns\n    container_ratio = height / width\n\n    cell_spacing = int(\n        width / columns\n        if container_ratio &gt; content_ratio\n        else height / rows\n    )\n    margins = int(max(cell_spacing * relative_margins, 1))\n    return cell_spacing, margins\n</code></pre>"},{"location":"reference/model/dynamics/grid_world/#src.model.dynamics.grid_world.GridWorld.is_in_bounds","title":"<code>is_in_bounds(position)</code>","text":"<p>Detect either a position is within the bounds of the grid.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>tuple[int, int]</code> <p>the position to test</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>true where the position is within the bounds of the grid</p> <code>bool</code> <p>world.</p> Source code in <code>src/model/dynamics/grid_world.py</code> <pre><code>def is_in_bounds(self, position: tuple[int, int]) -&gt; bool:\n    \"\"\"Detect either a position is within the bounds of the grid.\n\n    Args:\n        position (tuple[int, int]): the position to test\n\n    Returns:\n        bool: true where the position is within the bounds of the grid\n        world.\n    \"\"\"\n    x_pos, y_pos = position\n    return 0 &lt;= x_pos &lt; self.width and 0 &lt;= y_pos &lt; self.height\n</code></pre>"},{"location":"reference/model/dynamics/grid_world/#src.model.dynamics.grid_world.GridWorld.list_cell_positions","title":"<code>list_cell_positions(width, height, relative_margins)</code>","text":"<p>Generate the cell locations in a given rectangle.</p> <p>the cells will be centred if there is the aspect ratio's are not aligned</p> <p>returns the cell position in gird world coordinates, the location of corner that is closest to the origin then the corner that is the furthest.</p> <p>assumes cells should be square.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>the width of the containing rectangle</p> required <code>height</code> <code>int</code> <p>the hight of the containing rectangle</p> required <code>relative_margins</code> <code>float</code> <p>how large should the gap between cells be. relative to the size of a cell with no margins</p> required <p>Yields:</p> Type Description <code>location_generator</code> <p>Iterator[location_generator]: the coordinates</p> Source code in <code>src/model/dynamics/grid_world.py</code> <pre><code>def list_cell_positions(\n    self, width: int, height: int, relative_margins: float\n) -&gt; location_generator:\n    \"\"\"Generate the cell locations in a given rectangle.\n\n    the cells will be centred if there is the aspect ratio's are not aligned\n\n    returns the cell position in gird world coordinates, the location of\n    corner that is closest to the origin then the corner that is the\n    furthest.\n\n    assumes cells should be square.\n\n    Args:\n        width (int): the width of the containing rectangle\n        height (int): the hight of the containing rectangle\n        relative_margins (float): how large should the gap between cells be.\n            relative to the size of a cell with no margins\n\n    Yields:\n        Iterator[location_generator]: the coordinates\n    \"\"\"\n    rows = self.height\n    columns = self.width\n\n    cell_spacing, margins = self.get_cell_sizing(\n        width, height, relative_margins\n    )\n\n    offset_min_x = int((width - columns * cell_spacing) / 2)\n    offset_min_y = int((height - rows * cell_spacing) / 2)\n\n    offset_min_x += margins // 2\n    offset_min_y += margins // 2\n\n    offset_max_x = offset_min_x + cell_spacing - margins\n    offset_max_y = offset_min_y + cell_spacing - margins\n\n    for pos in self.list_cells():\n        bounding_box = (\n            offset_min_x + cell_spacing * pos[0],\n            offset_min_y + cell_spacing * pos[1],\n            offset_max_x + cell_spacing * pos[0],\n            offset_max_y + cell_spacing * pos[1],\n        )\n        yield pos, bounding_box\n</code></pre>"},{"location":"reference/model/dynamics/grid_world/#src.model.dynamics.grid_world.GridWorld.list_cells","title":"<code>list_cells()</code>","text":"<p>Generate all cells in the grid world.</p> <p>Yields:</p> Type Description <code>integer_position</code> <p>Generator[integer_position, None, None]: each cell location</p> Source code in <code>src/model/dynamics/grid_world.py</code> <pre><code>def list_cells(self) -&gt; Generator[integer_position, None, None]:\n    \"\"\"Generate all cells in the grid world.\n\n    Yields:\n        Generator[integer_position, None, None]: each cell location\n    \"\"\"\n    for y_pos in range(self.height):\n        yield from ((x_pos, y_pos) for x_pos in range(self.width))\n</code></pre>"},{"location":"reference/model/dynamics/grid_world/#src.model.dynamics.grid_world.GridWorld.movement_action","title":"<code>movement_action(current_position, action, distance=1)</code>","text":"<p>Calculate the adjacent cell in a given direction.</p> <p>The direction is provided from the up,down,left and right actions. This method calculates the next position assuming the origin is at the top left of the grid.</p> <p>note this may compute a cell that is out of bounds, to check and handel this please use <code>is_in_bounds</code> method.</p> <p>Parameters:</p> Name Type Description Default <code>current_position</code> <code>integer_position</code> <p>the position to start from.</p> required <code>action</code> <code>Action</code> <p>provides the direction to move in.</p> required <code>distance</code> <code>int</code> <p>the amount of cells to move. Defaults to 1.</p> <code>1</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the action provided is not a known movement action.</p> <p>Returns:</p> Name Type Description <code>integer_position</code> <code>integer_position</code> <p>The position after moving.</p> Source code in <code>src/model/dynamics/grid_world.py</code> <pre><code>def movement_action(\n    self,\n    current_position: integer_position,\n    action: Action,\n    distance: int = 1,\n) -&gt; integer_position:\n    \"\"\"Calculate the adjacent cell in a given direction.\n\n    The direction is provided from the up,down,left and right actions. This\n    method calculates the next position assuming the origin is at the top\n    left of the grid.\n\n    note this may compute a cell that is out of bounds, to check and handel\n    this please use `is_in_bounds` method.\n\n    Args:\n        current_position (integer_position): the position to start from.\n        action (Action): provides the direction to move in.\n        distance (int): the amount of cells to move. Defaults to 1.\n\n    Raises:\n        ValueError: If the action provided is not a known movement action.\n\n    Returns:\n        integer_position: The position after moving.\n    \"\"\"\n    x_pos, y_pos = current_position\n    dir_x, dir_y = self.action_direction[action]\n    return (x_pos + dir_x * distance, y_pos + dir_y * distance)\n</code></pre>"},{"location":"reference/model/dynamics/grid_world/#src.model.dynamics.grid_world.GridWorld.random_in_bounds_cell","title":"<code>random_in_bounds_cell(random_generator=None)</code>","text":"<p>Generate a random cell position that is within bounds.</p> <p>Parameters:</p> Name Type Description Default <code>random_generator</code> <code>Optional[Generator]</code> <p>an optional random generator to pick the positions from.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[int, int]</code> <p>tuple[int, int]: the cell position within the grid.</p> Source code in <code>src/model/dynamics/grid_world.py</code> <pre><code>def random_in_bounds_cell(\n    self, random_generator: Optional[RandomGenerator] = None\n) -&gt; tuple[int, int]:\n    \"\"\"Generate a random cell position that is within bounds.\n\n    Args:\n        random_generator (Optional[RandomGenerator]): an optional random\n            generator to pick the positions from.\n\n    Returns:\n        tuple[int, int]: the cell position within the grid.\n    \"\"\"\n    if random_generator is None:\n        random_generator = np.random.default_rng()\n    dimensions = np.array([self.width, self.height])\n    position_float = random_generator.random(2) * dimensions\n    position_integer = np.floor(position_float).astype(int)\n    return (position_integer[0], position_integer[1])\n</code></pre>"},{"location":"reference/model/hyperparameters/","title":"Hyperparameters","text":"<p>This package contains code for fine tuning different hyperparameters.</p>"},{"location":"reference/model/hyperparameters/base_parameter_strategy/","title":"Base Parameter Strategy","text":""},{"location":"reference/model/hyperparameters/base_parameter_strategy/#src.model.hyperparameters.base_parameter_strategy.BaseHyperParameterStrategy","title":"<code>BaseHyperParameterStrategy</code>","text":"<p>             Bases: <code>object</code></p> <p>The base class for hyper parameter managers.</p> Source code in <code>src/model/hyperparameters/base_parameter_strategy.py</code> <pre><code>class BaseHyperParameterStrategy(object):\n    \"\"\"The base class for hyper parameter managers.\"\"\"\n\n    def get_value(self, parameter: HyperParameter) -&gt; float:\n        \"\"\"Get the given hyper-parameter's value.\n\n        Args:\n            parameter (HyperParameter): Specifies which parameter to use.\n\n        Raises:\n            NotImplementedError: If not overridden by a concrete class\n\n        Returns:\n            float: The value of this hyper parameter.\n        \"\"\"\n        self.__raise_not_implemented()\n        return 0\n\n    def get_integer_value(self, parameter: HyperParameter) -&gt; int:\n        \"\"\"Get the value of a hyper parameter that is an integer.\n\n        Args:\n            parameter (HyperParameter): Specifies which parameter to use.\n\n        Raises:\n            TypeError: If the parameter's value is not an integer.\n\n        Returns:\n            int: The value of this hyper parameter.\n        \"\"\"\n        parameter_value = self.get_value(parameter)\n        # unfortunately this is one of the best ways to do this in python.\n        int_parameter_value = int(parameter_value)\n        if int_parameter_value == parameter_value:\n            return int_parameter_value\n\n        raise TypeError(\n            f\"parameter {parameter.name} did not have an integer type \\n\"\n        )\n\n    def __raise_not_implemented(self):\n        raise NotImplementedError(\n            \"Concrete classes should override this method.\"\n        )\n</code></pre>"},{"location":"reference/model/hyperparameters/base_parameter_strategy/#src.model.hyperparameters.base_parameter_strategy.BaseHyperParameterStrategy.get_integer_value","title":"<code>get_integer_value(parameter)</code>","text":"<p>Get the value of a hyper parameter that is an integer.</p> <p>Parameters:</p> Name Type Description Default <code>parameter</code> <code>HyperParameter</code> <p>Specifies which parameter to use.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>If the parameter's value is not an integer.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The value of this hyper parameter.</p> Source code in <code>src/model/hyperparameters/base_parameter_strategy.py</code> <pre><code>def get_integer_value(self, parameter: HyperParameter) -&gt; int:\n    \"\"\"Get the value of a hyper parameter that is an integer.\n\n    Args:\n        parameter (HyperParameter): Specifies which parameter to use.\n\n    Raises:\n        TypeError: If the parameter's value is not an integer.\n\n    Returns:\n        int: The value of this hyper parameter.\n    \"\"\"\n    parameter_value = self.get_value(parameter)\n    # unfortunately this is one of the best ways to do this in python.\n    int_parameter_value = int(parameter_value)\n    if int_parameter_value == parameter_value:\n        return int_parameter_value\n\n    raise TypeError(\n        f\"parameter {parameter.name} did not have an integer type \\n\"\n    )\n</code></pre>"},{"location":"reference/model/hyperparameters/base_parameter_strategy/#src.model.hyperparameters.base_parameter_strategy.BaseHyperParameterStrategy.get_value","title":"<code>get_value(parameter)</code>","text":"<p>Get the given hyper-parameter's value.</p> <p>Parameters:</p> Name Type Description Default <code>parameter</code> <code>HyperParameter</code> <p>Specifies which parameter to use.</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not overridden by a concrete class</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The value of this hyper parameter.</p> Source code in <code>src/model/hyperparameters/base_parameter_strategy.py</code> <pre><code>def get_value(self, parameter: HyperParameter) -&gt; float:\n    \"\"\"Get the given hyper-parameter's value.\n\n    Args:\n        parameter (HyperParameter): Specifies which parameter to use.\n\n    Raises:\n        NotImplementedError: If not overridden by a concrete class\n\n    Returns:\n        float: The value of this hyper parameter.\n    \"\"\"\n    self.__raise_not_implemented()\n    return 0\n</code></pre>"},{"location":"reference/model/hyperparameters/base_parameter_strategy/#src.model.hyperparameters.base_parameter_strategy.HyperParameter","title":"<code>HyperParameter</code>","text":"<p>             Bases: <code>Enum</code></p> <p>Enumerates all the different hyperparameters.</p> Source code in <code>src/model/hyperparameters/base_parameter_strategy.py</code> <pre><code>class HyperParameter(Enum):\n    \"\"\"Enumerates all the different hyperparameters.\"\"\"\n\n    initial_optimism = 0\n    replay_queue_length = 1\n    learning_rate = 2\n    discount_rate = 3\n    eg_initial_exploration_ratio = 4\n    eg_decay_rate = 5\n    ucb_exploration_bias = 6\n    stopping_epsilon = 7\n    sample_count = 8\n    mf_error_sensitivity = 9\n    mf_bpi_ensemble_size = 10\n    mf_exploration_parameter = 11\n</code></pre>"},{"location":"reference/model/hyperparameters/config_parameter_strategy/","title":"Config Parameter Strategy","text":""},{"location":"reference/model/hyperparameters/config_parameter_strategy/#src.model.hyperparameters.config_parameter_strategy.ParameterConfigStrategy","title":"<code>ParameterConfigStrategy</code>","text":"<p>             Bases: <code>BaseHyperParameterStrategy</code></p> <p>This class provides hyperparameter values from the configuration.</p> Source code in <code>src/model/hyperparameters/config_parameter_strategy.py</code> <pre><code>class ParameterConfigStrategy(BaseHyperParameterStrategy):\n    \"\"\"This class provides hyperparameter values from the configuration.\"\"\"\n\n    def __init__(self, agent_config: Optional[AgentConfig] = None) -&gt; None:\n        \"\"\"Initialise the parameter manager.\n\n        Args:\n            agent_config (Optional[AgentConfig]): the configuration reader the\n                hyper-parameters should use, if not provided the default one\n                will be used.\n        \"\"\"\n        super().__init__()\n        if agent_config is None:\n            agent_config = ConfigReader().agent\n        q_learning_config = agent_config.q_learning\n        value_iteration_config = agent_config.value_iteration\n\n        self.parameter_values = {\n            HyperParameter.initial_optimism: q_learning_config.initial_optimism,\n            HyperParameter.replay_queue_length: (\n                q_learning_config.replay_queue_length\n            ),\n            HyperParameter.learning_rate: q_learning_config.learning_rate,\n            HyperParameter.discount_rate: agent_config.discount_rate,\n            HyperParameter.eg_initial_exploration_ratio: (\n                q_learning_config.epsilon_greedy.initial_exploration_ratio\n            ),\n            HyperParameter.eg_decay_rate: (\n                q_learning_config.epsilon_greedy.decay_rate\n            ),\n            HyperParameter.ucb_exploration_bias: (\n                q_learning_config.upper_confidence_bound.exploration_bias\n            ),\n            HyperParameter.stopping_epsilon: (\n                value_iteration_config.stopping_epsilon\n            ),\n            HyperParameter.sample_count: value_iteration_config.sample_count,\n            HyperParameter.mf_error_sensitivity: (\n                q_learning_config.mf_bpi.error_sensitivity\n            ),\n            HyperParameter.mf_bpi_ensemble_size: (\n                q_learning_config.mf_bpi.ensemble_size\n            ),\n            HyperParameter.mf_exploration_parameter: (\n                q_learning_config.mf_bpi.exploration_parameter\n            ),\n        }\n\n    @override\n    def get_value(self, parameter: HyperParameter) -&gt; float:\n        \"\"\"Get the value of a given hyper parameter.\n\n        Args:\n            parameter (HyperParameter): the parameter to access.\n\n        Raises:\n            ValueError: if the parameter provided is not known.\n\n        Returns:\n            float: the value of this parameter.\n        \"\"\"\n        parameter_value = self.parameter_values.get(parameter, None)\n        if parameter_value is None:\n            raise ValueError(f'parameter \"{parameter.name}\" is not known')\n        return parameter_value\n</code></pre>"},{"location":"reference/model/hyperparameters/config_parameter_strategy/#src.model.hyperparameters.config_parameter_strategy.ParameterConfigStrategy.__init__","title":"<code>__init__(agent_config=None)</code>","text":"<p>Initialise the parameter manager.</p> <p>Parameters:</p> Name Type Description Default <code>agent_config</code> <code>Optional[AgentConfig]</code> <p>the configuration reader the hyper-parameters should use, if not provided the default one will be used.</p> <code>None</code> Source code in <code>src/model/hyperparameters/config_parameter_strategy.py</code> <pre><code>def __init__(self, agent_config: Optional[AgentConfig] = None) -&gt; None:\n    \"\"\"Initialise the parameter manager.\n\n    Args:\n        agent_config (Optional[AgentConfig]): the configuration reader the\n            hyper-parameters should use, if not provided the default one\n            will be used.\n    \"\"\"\n    super().__init__()\n    if agent_config is None:\n        agent_config = ConfigReader().agent\n    q_learning_config = agent_config.q_learning\n    value_iteration_config = agent_config.value_iteration\n\n    self.parameter_values = {\n        HyperParameter.initial_optimism: q_learning_config.initial_optimism,\n        HyperParameter.replay_queue_length: (\n            q_learning_config.replay_queue_length\n        ),\n        HyperParameter.learning_rate: q_learning_config.learning_rate,\n        HyperParameter.discount_rate: agent_config.discount_rate,\n        HyperParameter.eg_initial_exploration_ratio: (\n            q_learning_config.epsilon_greedy.initial_exploration_ratio\n        ),\n        HyperParameter.eg_decay_rate: (\n            q_learning_config.epsilon_greedy.decay_rate\n        ),\n        HyperParameter.ucb_exploration_bias: (\n            q_learning_config.upper_confidence_bound.exploration_bias\n        ),\n        HyperParameter.stopping_epsilon: (\n            value_iteration_config.stopping_epsilon\n        ),\n        HyperParameter.sample_count: value_iteration_config.sample_count,\n        HyperParameter.mf_error_sensitivity: (\n            q_learning_config.mf_bpi.error_sensitivity\n        ),\n        HyperParameter.mf_bpi_ensemble_size: (\n            q_learning_config.mf_bpi.ensemble_size\n        ),\n        HyperParameter.mf_exploration_parameter: (\n            q_learning_config.mf_bpi.exploration_parameter\n        ),\n    }\n</code></pre>"},{"location":"reference/model/hyperparameters/config_parameter_strategy/#src.model.hyperparameters.config_parameter_strategy.ParameterConfigStrategy.get_value","title":"<code>get_value(parameter)</code>","text":"<p>Get the value of a given hyper parameter.</p> <p>Parameters:</p> Name Type Description Default <code>parameter</code> <code>HyperParameter</code> <p>the parameter to access.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>if the parameter provided is not known.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the value of this parameter.</p> Source code in <code>src/model/hyperparameters/config_parameter_strategy.py</code> <pre><code>@override\ndef get_value(self, parameter: HyperParameter) -&gt; float:\n    \"\"\"Get the value of a given hyper parameter.\n\n    Args:\n        parameter (HyperParameter): the parameter to access.\n\n    Raises:\n        ValueError: if the parameter provided is not known.\n\n    Returns:\n        float: the value of this parameter.\n    \"\"\"\n    parameter_value = self.parameter_values.get(parameter, None)\n    if parameter_value is None:\n        raise ValueError(f'parameter \"{parameter.name}\" is not known')\n    return parameter_value\n</code></pre>"},{"location":"reference/model/hyperparameters/hyper_parameter_system/","title":"Hyper Parameter System","text":""},{"location":"reference/model/hyperparameters/hyper_parameter_system/#src.model.hyperparameters.hyper_parameter_system.HyperParameterState","title":"<code>HyperParameterState</code>  <code>dataclass</code>","text":"<p>             Bases: <code>object</code></p> <p>State object for combining all hyper parameter state.</p> Source code in <code>src/model/hyperparameters/hyper_parameter_system.py</code> <pre><code>@dataclass(frozen=True, slots=True)\nclass HyperParameterState(object):\n    \"\"\"State object for combining all hyper parameter state.\"\"\"\n\n    report: ReportState\n    search: RandomSearchState\n</code></pre>"},{"location":"reference/model/hyperparameters/hyper_parameter_system/#src.model.hyperparameters.hyper_parameter_system.HyperParameterSystem","title":"<code>HyperParameterSystem</code>","text":"<p>             Bases: <code>object</code></p> <p>class for combining hyper parameter functionality.</p> Source code in <code>src/model/hyperparameters/hyper_parameter_system.py</code> <pre><code>class HyperParameterSystem(object):\n    \"\"\"class for combining hyper parameter functionality.\"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialise the hyper parameter system.\"\"\"\n        self.report_generator = HyperParameterReportGenerator()\n        self.random_search = RandomSearch()\n\n    def get_state(self) -&gt; HyperParameterState:\n        \"\"\"Get the combined hyper parameter state.\n\n        Returns:\n            HyperParameterState: the state of the hyper parameter systems\n        \"\"\"\n        report = self.report_generator.get_state()\n        search = self.random_search.get_progress()\n        return HyperParameterState(report, search)\n\n    def shutdown(self):\n        \"\"\"Stop any ongoing work.\"\"\"\n        self.report_generator.shutdown()\n        self.random_search.stop_search()\n</code></pre>"},{"location":"reference/model/hyperparameters/hyper_parameter_system/#src.model.hyperparameters.hyper_parameter_system.HyperParameterSystem.__init__","title":"<code>__init__()</code>","text":"<p>Initialise the hyper parameter system.</p> Source code in <code>src/model/hyperparameters/hyper_parameter_system.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialise the hyper parameter system.\"\"\"\n    self.report_generator = HyperParameterReportGenerator()\n    self.random_search = RandomSearch()\n</code></pre>"},{"location":"reference/model/hyperparameters/hyper_parameter_system/#src.model.hyperparameters.hyper_parameter_system.HyperParameterSystem.get_state","title":"<code>get_state()</code>","text":"<p>Get the combined hyper parameter state.</p> <p>Returns:</p> Name Type Description <code>HyperParameterState</code> <code>HyperParameterState</code> <p>the state of the hyper parameter systems</p> Source code in <code>src/model/hyperparameters/hyper_parameter_system.py</code> <pre><code>def get_state(self) -&gt; HyperParameterState:\n    \"\"\"Get the combined hyper parameter state.\n\n    Returns:\n        HyperParameterState: the state of the hyper parameter systems\n    \"\"\"\n    report = self.report_generator.get_state()\n    search = self.random_search.get_progress()\n    return HyperParameterState(report, search)\n</code></pre>"},{"location":"reference/model/hyperparameters/hyper_parameter_system/#src.model.hyperparameters.hyper_parameter_system.HyperParameterSystem.shutdown","title":"<code>shutdown()</code>","text":"<p>Stop any ongoing work.</p> Source code in <code>src/model/hyperparameters/hyper_parameter_system.py</code> <pre><code>def shutdown(self):\n    \"\"\"Stop any ongoing work.\"\"\"\n    self.report_generator.shutdown()\n    self.random_search.stop_search()\n</code></pre>"},{"location":"reference/model/hyperparameters/parameter_evaluator/","title":"Parameter Evaluator","text":""},{"location":"reference/model/hyperparameters/parameter_evaluator/#src.model.hyperparameters.parameter_evaluator.ParameterEvaluator","title":"<code>ParameterEvaluator</code>","text":"<p>             Bases: <code>object</code></p> <p>This class simulations and evaluates different configurations.</p> Source code in <code>src/model/hyperparameters/parameter_evaluator.py</code> <pre><code>class ParameterEvaluator(object):\n    \"\"\"This class simulations and evaluates different configurations.\"\"\"\n\n    runs = 25\n    iterations_per_run = 5000\n\n    @classmethod\n    def evaluate_reward(\n        cls,\n        options: TopEntitiesOptions,\n        hyper_parameters: BaseHyperParameterStrategy,\n        running: ValueProxy[bool],\n    ) -&gt; float:\n        \"\"\"Evaluate the reward of a given configuration.\n\n        this method will evaluate the reward multiple times and average out the\n        value to reduce noise in the recording.\n\n        Args:\n            options (TopEntitiesOptions): The major non-tunable configuration.\n            hyper_parameters (BaseHyperParameterStrategy): the hyper parameters\n                to use.\n            running (ValueProxy[bool]): a value to determine early stopping.\n\n        Returns:\n            float: The average total reward for a given configuration.\n        \"\"\"\n        total_reward = float(0)\n\n        for _ in range(cls.runs):\n            if not running.get():\n                return -float(\"inf\")\n            total_reward += cls.single_run(\n                options, hyper_parameters\n            ).total_reward\n\n        return total_reward / cls.runs\n\n    @classmethod\n    def single_run(\n        cls,\n        options: TopEntitiesOptions,\n        hyper_parameters: BaseHyperParameterStrategy,\n    ) -&gt; StatisticsRecord:\n        \"\"\"Perform a single simulated run.\n\n        Args:\n            options (TopEntitiesOptions): the top options for this run\n            hyper_parameters (BaseHyperParameterStrategy): the parameters to\n                use.\n\n        Returns:\n            StatisticsRecord: the statistics from this run.\n        \"\"\"\n        entities = EntityFactory.create_entities(options, hyper_parameters)\n\n        learning_instance = LearningInstance(entities)\n\n        for _ in range(cls.iterations_per_run):\n            learning_instance.perform_action()\n        return entities.statistics.get_statistics()\n</code></pre>"},{"location":"reference/model/hyperparameters/parameter_evaluator/#src.model.hyperparameters.parameter_evaluator.ParameterEvaluator.evaluate_reward","title":"<code>evaluate_reward(options, hyper_parameters, running)</code>  <code>classmethod</code>","text":"<p>Evaluate the reward of a given configuration.</p> <p>this method will evaluate the reward multiple times and average out the value to reduce noise in the recording.</p> <p>Parameters:</p> Name Type Description Default <code>options</code> <code>TopEntitiesOptions</code> <p>The major non-tunable configuration.</p> required <code>hyper_parameters</code> <code>BaseHyperParameterStrategy</code> <p>the hyper parameters to use.</p> required <code>running</code> <code>ValueProxy[bool]</code> <p>a value to determine early stopping.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The average total reward for a given configuration.</p> Source code in <code>src/model/hyperparameters/parameter_evaluator.py</code> <pre><code>@classmethod\ndef evaluate_reward(\n    cls,\n    options: TopEntitiesOptions,\n    hyper_parameters: BaseHyperParameterStrategy,\n    running: ValueProxy[bool],\n) -&gt; float:\n    \"\"\"Evaluate the reward of a given configuration.\n\n    this method will evaluate the reward multiple times and average out the\n    value to reduce noise in the recording.\n\n    Args:\n        options (TopEntitiesOptions): The major non-tunable configuration.\n        hyper_parameters (BaseHyperParameterStrategy): the hyper parameters\n            to use.\n        running (ValueProxy[bool]): a value to determine early stopping.\n\n    Returns:\n        float: The average total reward for a given configuration.\n    \"\"\"\n    total_reward = float(0)\n\n    for _ in range(cls.runs):\n        if not running.get():\n            return -float(\"inf\")\n        total_reward += cls.single_run(\n            options, hyper_parameters\n        ).total_reward\n\n    return total_reward / cls.runs\n</code></pre>"},{"location":"reference/model/hyperparameters/parameter_evaluator/#src.model.hyperparameters.parameter_evaluator.ParameterEvaluator.single_run","title":"<code>single_run(options, hyper_parameters)</code>  <code>classmethod</code>","text":"<p>Perform a single simulated run.</p> <p>Parameters:</p> Name Type Description Default <code>options</code> <code>TopEntitiesOptions</code> <p>the top options for this run</p> required <code>hyper_parameters</code> <code>BaseHyperParameterStrategy</code> <p>the parameters to use.</p> required <p>Returns:</p> Name Type Description <code>StatisticsRecord</code> <code>StatisticsRecord</code> <p>the statistics from this run.</p> Source code in <code>src/model/hyperparameters/parameter_evaluator.py</code> <pre><code>@classmethod\ndef single_run(\n    cls,\n    options: TopEntitiesOptions,\n    hyper_parameters: BaseHyperParameterStrategy,\n) -&gt; StatisticsRecord:\n    \"\"\"Perform a single simulated run.\n\n    Args:\n        options (TopEntitiesOptions): the top options for this run\n        hyper_parameters (BaseHyperParameterStrategy): the parameters to\n            use.\n\n    Returns:\n        StatisticsRecord: the statistics from this run.\n    \"\"\"\n    entities = EntityFactory.create_entities(options, hyper_parameters)\n\n    learning_instance = LearningInstance(entities)\n\n    for _ in range(cls.iterations_per_run):\n        learning_instance.perform_action()\n    return entities.statistics.get_statistics()\n</code></pre>"},{"location":"reference/model/hyperparameters/tuning_information/","title":"Tuning Information","text":""},{"location":"reference/model/hyperparameters/tuning_information/#src.model.hyperparameters.tuning_information.HyperParameterDescription","title":"<code>HyperParameterDescription</code>  <code>dataclass</code>","text":"<p>             Bases: <code>object</code></p> <p>Defines the meta information about a hyper parameter.</p> <p>such as range of sensible values for a hyper parameter.</p> Source code in <code>src/model/hyperparameters/tuning_information.py</code> <pre><code>@dataclass(frozen=True, slots=True)\nclass HyperParameterDescription(object):\n    \"\"\"Defines the meta information about a hyper parameter.\n\n    such as range of sensible values for a hyper parameter.\n    \"\"\"\n\n    name: str\n    min_value: float\n    max_value: float\n    tuning_options: TopEntitiesOptions\n    integer_valued: bool = False\n    display_name: Optional[str] = None\n\n    def get_random_value(self) -&gt; float:\n        \"\"\"Get a random value in this parameters range.\n\n        Returns:\n            float: Random value for this parameter in its range.\n        \"\"\"\n        return self.interpolate_value(random())\n\n    def get_display_name(self) -&gt; str:\n        \"\"\"Get the name of the parameter for display purposes.\n\n        Returns:\n            str: the name to use on plots.\n        \"\"\"\n        if self.display_name is not None:\n            return self.display_name\n\n        return self.name\n\n    def cap_samples(self, samples: int) -&gt; int:\n        \"\"\"Cap the number of samples for integer ranges to avoid oversampling.\n\n        Args:\n            samples (int): the intended number of samples before the cap\n\n        Returns:\n            int: the number of samples in the range after adjustment.\n        \"\"\"\n        if not self.integer_valued:\n            return samples\n\n        interval = int(self.max_value - self.min_value)\n        return min(interval, samples)\n\n    def interpolate_value(self, factor: float) -&gt; float:\n        \"\"\"Interpolate in the range with the given factor.\n\n        Args:\n            factor (float): the factor of the way through the range. typically\n                between zero and one.\n\n        Returns:\n            float: the value in the range based on this factor.\n        \"\"\"\n        interval = self.max_value - self.min_value\n        interpolated_value = interval * factor + self.min_value\n\n        if not self.integer_valued:\n            return interpolated_value\n        return round(interpolated_value)\n</code></pre>"},{"location":"reference/model/hyperparameters/tuning_information/#src.model.hyperparameters.tuning_information.HyperParameterDescription.cap_samples","title":"<code>cap_samples(samples)</code>","text":"<p>Cap the number of samples for integer ranges to avoid oversampling.</p> <p>Parameters:</p> Name Type Description Default <code>samples</code> <code>int</code> <p>the intended number of samples before the cap</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>the number of samples in the range after adjustment.</p> Source code in <code>src/model/hyperparameters/tuning_information.py</code> <pre><code>def cap_samples(self, samples: int) -&gt; int:\n    \"\"\"Cap the number of samples for integer ranges to avoid oversampling.\n\n    Args:\n        samples (int): the intended number of samples before the cap\n\n    Returns:\n        int: the number of samples in the range after adjustment.\n    \"\"\"\n    if not self.integer_valued:\n        return samples\n\n    interval = int(self.max_value - self.min_value)\n    return min(interval, samples)\n</code></pre>"},{"location":"reference/model/hyperparameters/tuning_information/#src.model.hyperparameters.tuning_information.HyperParameterDescription.get_display_name","title":"<code>get_display_name()</code>","text":"<p>Get the name of the parameter for display purposes.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>the name to use on plots.</p> Source code in <code>src/model/hyperparameters/tuning_information.py</code> <pre><code>def get_display_name(self) -&gt; str:\n    \"\"\"Get the name of the parameter for display purposes.\n\n    Returns:\n        str: the name to use on plots.\n    \"\"\"\n    if self.display_name is not None:\n        return self.display_name\n\n    return self.name\n</code></pre>"},{"location":"reference/model/hyperparameters/tuning_information/#src.model.hyperparameters.tuning_information.HyperParameterDescription.get_random_value","title":"<code>get_random_value()</code>","text":"<p>Get a random value in this parameters range.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Random value for this parameter in its range.</p> Source code in <code>src/model/hyperparameters/tuning_information.py</code> <pre><code>def get_random_value(self) -&gt; float:\n    \"\"\"Get a random value in this parameters range.\n\n    Returns:\n        float: Random value for this parameter in its range.\n    \"\"\"\n    return self.interpolate_value(random())\n</code></pre>"},{"location":"reference/model/hyperparameters/tuning_information/#src.model.hyperparameters.tuning_information.HyperParameterDescription.interpolate_value","title":"<code>interpolate_value(factor)</code>","text":"<p>Interpolate in the range with the given factor.</p> <p>Parameters:</p> Name Type Description Default <code>factor</code> <code>float</code> <p>the factor of the way through the range. typically between zero and one.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the value in the range based on this factor.</p> Source code in <code>src/model/hyperparameters/tuning_information.py</code> <pre><code>def interpolate_value(self, factor: float) -&gt; float:\n    \"\"\"Interpolate in the range with the given factor.\n\n    Args:\n        factor (float): the factor of the way through the range. typically\n            between zero and one.\n\n    Returns:\n        float: the value in the range based on this factor.\n    \"\"\"\n    interval = self.max_value - self.min_value\n    interpolated_value = interval * factor + self.min_value\n\n    if not self.integer_valued:\n        return interpolated_value\n    return round(interpolated_value)\n</code></pre>"},{"location":"reference/model/hyperparameters/tuning_information/#src.model.hyperparameters.tuning_information.TuningInformation","title":"<code>TuningInformation</code>","text":"<p>             Bases: <code>object</code></p> <p>Class for containing the meta information about tuning parameters.</p> Source code in <code>src/model/hyperparameters/tuning_information.py</code> <pre><code>class TuningInformation(object):\n    \"\"\"Class for containing the meta information about tuning parameters.\"\"\"\n\n    eg_options = TopEntitiesOptions(\n        AgentOptions.q_learning,\n        DynamicsOptions.cliff,\n        ExplorationStrategyOptions.epsilon_greedy,\n    )\n\n    ucb_options = TopEntitiesOptions(\n        AgentOptions.q_learning,\n        DynamicsOptions.cliff,\n        ExplorationStrategyOptions.upper_confidence_bound,\n    )\n\n    parameter_details = {\n        HyperParameter.initial_optimism: HyperParameterDescription(\n            \"Initial Optimism\",\n            -10 * 5,\n            100,\n            eg_options,\n        ),\n        HyperParameter.replay_queue_length: HyperParameterDescription(\n            \"Replay Queue Length\", 1, 10, eg_options, integer_valued=True\n        ),\n        HyperParameter.learning_rate: HyperParameterDescription(\n            \"Learning Rate\",\n            0.1**3,\n            1,\n            eg_options,\n        ),\n        HyperParameter.discount_rate: HyperParameterDescription(\n            \"Discount Rate\", 0, 1, eg_options\n        ),\n        HyperParameter.eg_initial_exploration_ratio: HyperParameterDescription(\n            \"EG Initial Exploration Ratio\",\n            0,\n            1,\n            eg_options,\n            display_name=r\"$\\epsilon$-greedy Initial Exploration Ratio\",\n        ),\n        HyperParameter.eg_decay_rate: HyperParameterDescription(\n            \"EG Decay Rate\",\n            0.5,\n            1,\n            eg_options,\n            display_name=r\"$\\epsilon$-greedy Decay Rate\",\n        ),\n        HyperParameter.ucb_exploration_bias: HyperParameterDescription(\n            \"UCB Exploration Bias\", 1, 10, ucb_options\n        ),\n    }\n\n    @classmethod\n    def tunable_parameters(cls) -&gt; Iterable[HyperParameter]:\n        \"\"\"Get all parameters that are tunable.\n\n        Returns:\n            Iterable[HyperParameter]: the parameters that can be tuned.\n        \"\"\"\n        return cls.parameter_details.keys()\n\n    @classmethod\n    def get_parameter_details(\n        cls, parameter: HyperParameter\n    ) -&gt; HyperParameterDescription:\n        \"\"\"Get the tuning information of a given parameter.\n\n        Args:\n            parameter (HyperParameter): the parameter to be tuned\n\n        Raises:\n            ValueError: if the parameter should not be tuned.\n\n        Returns:\n            HyperParameterDescription: the meta information about this parameter\n        \"\"\"\n        details = cls.parameter_details.get(parameter, None)\n\n        if details is None:\n            raise ValueError(\n                f\"parameter {parameter.name} is not valid for tuning.\"\n            )\n\n        return details\n</code></pre>"},{"location":"reference/model/hyperparameters/tuning_information/#src.model.hyperparameters.tuning_information.TuningInformation.get_parameter_details","title":"<code>get_parameter_details(parameter)</code>  <code>classmethod</code>","text":"<p>Get the tuning information of a given parameter.</p> <p>Parameters:</p> Name Type Description Default <code>parameter</code> <code>HyperParameter</code> <p>the parameter to be tuned</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>if the parameter should not be tuned.</p> <p>Returns:</p> Name Type Description <code>HyperParameterDescription</code> <code>HyperParameterDescription</code> <p>the meta information about this parameter</p> Source code in <code>src/model/hyperparameters/tuning_information.py</code> <pre><code>@classmethod\ndef get_parameter_details(\n    cls, parameter: HyperParameter\n) -&gt; HyperParameterDescription:\n    \"\"\"Get the tuning information of a given parameter.\n\n    Args:\n        parameter (HyperParameter): the parameter to be tuned\n\n    Raises:\n        ValueError: if the parameter should not be tuned.\n\n    Returns:\n        HyperParameterDescription: the meta information about this parameter\n    \"\"\"\n    details = cls.parameter_details.get(parameter, None)\n\n    if details is None:\n        raise ValueError(\n            f\"parameter {parameter.name} is not valid for tuning.\"\n        )\n\n    return details\n</code></pre>"},{"location":"reference/model/hyperparameters/tuning_information/#src.model.hyperparameters.tuning_information.TuningInformation.tunable_parameters","title":"<code>tunable_parameters()</code>  <code>classmethod</code>","text":"<p>Get all parameters that are tunable.</p> <p>Returns:</p> Type Description <code>Iterable[HyperParameter]</code> <p>Iterable[HyperParameter]: the parameters that can be tuned.</p> Source code in <code>src/model/hyperparameters/tuning_information.py</code> <pre><code>@classmethod\ndef tunable_parameters(cls) -&gt; Iterable[HyperParameter]:\n    \"\"\"Get all parameters that are tunable.\n\n    Returns:\n        Iterable[HyperParameter]: the parameters that can be tuned.\n    \"\"\"\n    return cls.parameter_details.keys()\n</code></pre>"},{"location":"reference/model/hyperparameters/random_search/","title":"Random Search","text":"<p>This package searches for the best parameter combination.</p>"},{"location":"reference/model/hyperparameters/random_search/random_parameter_strategy/","title":"Random Parameter Strategy","text":""},{"location":"reference/model/hyperparameters/random_search/random_parameter_strategy/#src.model.hyperparameters.random_search.random_parameter_strategy.RandomParameterStrategy","title":"<code>RandomParameterStrategy</code>","text":"<p>             Bases: <code>BaseHyperParameterStrategy</code></p> <p>This class provides hyperparameter values from the configuration.</p> Source code in <code>src/model/hyperparameters/random_search/random_parameter_strategy.py</code> <pre><code>class RandomParameterStrategy(BaseHyperParameterStrategy):\n    \"\"\"This class provides hyperparameter values from the configuration.\"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialise the parameter manager.\n\n        This is where the parameter manager picks the random values\n        \"\"\"\n        # make the parameters are demand driven to avoid redundant values.\n        self.parameter_values: Dict[HyperParameter, Optional[float]] = {\n            parameter: None\n            for parameter in TuningInformation.tunable_parameters()\n        }\n\n    def get_parameters(self) -&gt; Dict[HyperParameter, Optional[float]]:\n        \"\"\"Get the parameters used by this strategy.\n\n        Returns:\n            Dict[HyperParameter, float]: the parameter values\n        \"\"\"\n        return self.parameter_values\n\n    @override\n    def get_value(self, parameter: HyperParameter) -&gt; float:\n        \"\"\"Get the value of a given hyper parameter.\n\n        Args:\n            parameter (HyperParameter): the parameter to access.\n\n        Raises:\n            ValueError: if the parameter provided is not known.\n\n        Returns:\n            float: the value of this parameter.\n        \"\"\"\n        if parameter not in TuningInformation.tunable_parameters():\n            raise ValueError(f'parameter \"{parameter.name}\" is not known')\n\n        parameter_value = self.parameter_values.get(parameter, None)\n        if parameter_value is not None:\n            return parameter_value\n\n        new_value = TuningInformation.get_parameter_details(\n            parameter\n        ).get_random_value()\n        self.parameter_values[parameter] = new_value\n        return new_value\n</code></pre>"},{"location":"reference/model/hyperparameters/random_search/random_parameter_strategy/#src.model.hyperparameters.random_search.random_parameter_strategy.RandomParameterStrategy.__init__","title":"<code>__init__()</code>","text":"<p>Initialise the parameter manager.</p> <p>This is where the parameter manager picks the random values</p> Source code in <code>src/model/hyperparameters/random_search/random_parameter_strategy.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialise the parameter manager.\n\n    This is where the parameter manager picks the random values\n    \"\"\"\n    # make the parameters are demand driven to avoid redundant values.\n    self.parameter_values: Dict[HyperParameter, Optional[float]] = {\n        parameter: None\n        for parameter in TuningInformation.tunable_parameters()\n    }\n</code></pre>"},{"location":"reference/model/hyperparameters/random_search/random_parameter_strategy/#src.model.hyperparameters.random_search.random_parameter_strategy.RandomParameterStrategy.get_parameters","title":"<code>get_parameters()</code>","text":"<p>Get the parameters used by this strategy.</p> <p>Returns:</p> Type Description <code>Dict[HyperParameter, Optional[float]]</code> <p>Dict[HyperParameter, float]: the parameter values</p> Source code in <code>src/model/hyperparameters/random_search/random_parameter_strategy.py</code> <pre><code>def get_parameters(self) -&gt; Dict[HyperParameter, Optional[float]]:\n    \"\"\"Get the parameters used by this strategy.\n\n    Returns:\n        Dict[HyperParameter, float]: the parameter values\n    \"\"\"\n    return self.parameter_values\n</code></pre>"},{"location":"reference/model/hyperparameters/random_search/random_parameter_strategy/#src.model.hyperparameters.random_search.random_parameter_strategy.RandomParameterStrategy.get_value","title":"<code>get_value(parameter)</code>","text":"<p>Get the value of a given hyper parameter.</p> <p>Parameters:</p> Name Type Description Default <code>parameter</code> <code>HyperParameter</code> <p>the parameter to access.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>if the parameter provided is not known.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the value of this parameter.</p> Source code in <code>src/model/hyperparameters/random_search/random_parameter_strategy.py</code> <pre><code>@override\ndef get_value(self, parameter: HyperParameter) -&gt; float:\n    \"\"\"Get the value of a given hyper parameter.\n\n    Args:\n        parameter (HyperParameter): the parameter to access.\n\n    Raises:\n        ValueError: if the parameter provided is not known.\n\n    Returns:\n        float: the value of this parameter.\n    \"\"\"\n    if parameter not in TuningInformation.tunable_parameters():\n        raise ValueError(f'parameter \"{parameter.name}\" is not known')\n\n    parameter_value = self.parameter_values.get(parameter, None)\n    if parameter_value is not None:\n        return parameter_value\n\n    new_value = TuningInformation.get_parameter_details(\n        parameter\n    ).get_random_value()\n    self.parameter_values[parameter] = new_value\n    return new_value\n</code></pre>"},{"location":"reference/model/hyperparameters/random_search/random_search/","title":"Random Search","text":""},{"location":"reference/model/hyperparameters/random_search/random_search/#src.model.hyperparameters.random_search.random_search.RandomSearch","title":"<code>RandomSearch</code>","text":"<p>             Bases: <code>object</code></p> <p>Class for performing a random search.</p> Source code in <code>src/model/hyperparameters/random_search/random_search.py</code> <pre><code>class RandomSearch(object):\n    \"\"\"Class for performing a random search.\"\"\"\n\n    worker_count = 4\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialise random search runner.\"\"\"\n        manager = Manager()\n\n        self.search_options = [\n            TopEntitiesOptions(\n                AgentOptions.q_learning,\n                DynamicsOptions.cliff,\n                ExplorationStrategyOptions.epsilon_greedy,\n            ),\n            TopEntitiesOptions(\n                AgentOptions.q_learning,\n                DynamicsOptions.collection,\n                ExplorationStrategyOptions.epsilon_greedy,\n            ),\n            TopEntitiesOptions(\n                AgentOptions.q_learning,\n                DynamicsOptions.cliff,\n                ExplorationStrategyOptions.upper_confidence_bound,\n            ),\n            TopEntitiesOptions(\n                AgentOptions.q_learning,\n                DynamicsOptions.collection,\n                ExplorationStrategyOptions.upper_confidence_bound,\n            ),\n        ]\n\n        initial_params: Dict[HyperParameter, Optional[float]] = {\n            tunable_parameter: None\n            for tunable_parameter in TuningInformation.tunable_parameters()\n        }\n\n        initial_data = RandomSearchState(\n            None,\n            {\n                options: SearchArea(options, initial_params, None, 0)\n                for options in self.search_options\n            },\n            searching=False,\n        )\n        self.state = manager.Value(RandomSearchState, initial_data)\n\n        self.state_lock = manager.Lock()\n\n        self.running = manager.Value(bool, value=False)\n\n    def get_progress(self) -&gt; RandomSearchState:\n        \"\"\"Get the current state of the search if there is one.\n\n        Returns:\n            RandomSearchState: the current result of the search.\n        \"\"\"\n        with self.state_lock:\n            return self.state.value\n\n    def start_search(self):\n        \"\"\"Start the searching process.\"\"\"\n        with self.state_lock:\n            if self.running.get():\n                return\n            self.running.set(True)\n            self.state.set(self.state.get().set_searching(True))\n\n        optimal_runner = Process(\n            target=self.run_optimal_search, name=\"optimal rewards search\"\n        )\n        optimal_runner.start()\n\n        for runner_id in range(self.worker_count):\n            search_runner = Process(\n                target=self.run_search_inner,\n                name=f\"random search runner {runner_id}\",\n            )\n            search_runner.start()\n\n    def stop_search(self):\n        \"\"\"Stop the searching process.\"\"\"\n        self.running.set(False)\n        with self.state_lock:\n            self.state.set(self.state.get().set_searching(False))\n\n    def run_optimal_search(self):\n        \"\"\"Run a search for the optimal reward under the given conditions.\n\n        This is done with value iteration.\n        \"\"\"\n        optimal_rewards: Dict[DynamicsOptions, float] = {}\n        for dynamics in DynamicsOptions:\n            if not self.running.get():\n                return\n            options = TopEntitiesOptions(\n                AgentOptions.value_iteration_optimised,\n                dynamics,\n                ExplorationStrategyOptions.not_applicable,\n            )\n            normal_parameters = ParameterConfigStrategy()\n            optimal_rewards[dynamics] = ParameterEvaluator.evaluate_reward(\n                options, normal_parameters, self.running\n            )\n        if not self.running.get():\n            return\n\n        with self.state_lock:\n            state = self.state.get()\n            self.state.set(state.set_optimal_rewards(optimal_rewards))\n\n    def run_search_inner(self):\n        \"\"\"Run the actual search.\n\n        this method is used internally please use `start_search` to actually\n        start the search from another class.\n        \"\"\"\n        while self.running.get():\n            for options in self.search_options:\n                if not self.running.get():\n                    return\n                hyper_parameters = RandomParameterStrategy()\n\n                total_reward = ParameterEvaluator.evaluate_reward(\n                    options, hyper_parameters, self.running\n                )\n\n                if not self.running.get():\n                    return\n\n                with self.state_lock:\n                    state = self.state.get()\n                    self.state.set(\n                        state.record_result(\n                            options, hyper_parameters, total_reward\n                        )\n                    )\n</code></pre>"},{"location":"reference/model/hyperparameters/random_search/random_search/#src.model.hyperparameters.random_search.random_search.RandomSearch.__init__","title":"<code>__init__()</code>","text":"<p>Initialise random search runner.</p> Source code in <code>src/model/hyperparameters/random_search/random_search.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialise random search runner.\"\"\"\n    manager = Manager()\n\n    self.search_options = [\n        TopEntitiesOptions(\n            AgentOptions.q_learning,\n            DynamicsOptions.cliff,\n            ExplorationStrategyOptions.epsilon_greedy,\n        ),\n        TopEntitiesOptions(\n            AgentOptions.q_learning,\n            DynamicsOptions.collection,\n            ExplorationStrategyOptions.epsilon_greedy,\n        ),\n        TopEntitiesOptions(\n            AgentOptions.q_learning,\n            DynamicsOptions.cliff,\n            ExplorationStrategyOptions.upper_confidence_bound,\n        ),\n        TopEntitiesOptions(\n            AgentOptions.q_learning,\n            DynamicsOptions.collection,\n            ExplorationStrategyOptions.upper_confidence_bound,\n        ),\n    ]\n\n    initial_params: Dict[HyperParameter, Optional[float]] = {\n        tunable_parameter: None\n        for tunable_parameter in TuningInformation.tunable_parameters()\n    }\n\n    initial_data = RandomSearchState(\n        None,\n        {\n            options: SearchArea(options, initial_params, None, 0)\n            for options in self.search_options\n        },\n        searching=False,\n    )\n    self.state = manager.Value(RandomSearchState, initial_data)\n\n    self.state_lock = manager.Lock()\n\n    self.running = manager.Value(bool, value=False)\n</code></pre>"},{"location":"reference/model/hyperparameters/random_search/random_search/#src.model.hyperparameters.random_search.random_search.RandomSearch.get_progress","title":"<code>get_progress()</code>","text":"<p>Get the current state of the search if there is one.</p> <p>Returns:</p> Name Type Description <code>RandomSearchState</code> <code>RandomSearchState</code> <p>the current result of the search.</p> Source code in <code>src/model/hyperparameters/random_search/random_search.py</code> <pre><code>def get_progress(self) -&gt; RandomSearchState:\n    \"\"\"Get the current state of the search if there is one.\n\n    Returns:\n        RandomSearchState: the current result of the search.\n    \"\"\"\n    with self.state_lock:\n        return self.state.value\n</code></pre>"},{"location":"reference/model/hyperparameters/random_search/random_search/#src.model.hyperparameters.random_search.random_search.RandomSearch.run_optimal_search","title":"<code>run_optimal_search()</code>","text":"<p>Run a search for the optimal reward under the given conditions.</p> <p>This is done with value iteration.</p> Source code in <code>src/model/hyperparameters/random_search/random_search.py</code> <pre><code>def run_optimal_search(self):\n    \"\"\"Run a search for the optimal reward under the given conditions.\n\n    This is done with value iteration.\n    \"\"\"\n    optimal_rewards: Dict[DynamicsOptions, float] = {}\n    for dynamics in DynamicsOptions:\n        if not self.running.get():\n            return\n        options = TopEntitiesOptions(\n            AgentOptions.value_iteration_optimised,\n            dynamics,\n            ExplorationStrategyOptions.not_applicable,\n        )\n        normal_parameters = ParameterConfigStrategy()\n        optimal_rewards[dynamics] = ParameterEvaluator.evaluate_reward(\n            options, normal_parameters, self.running\n        )\n    if not self.running.get():\n        return\n\n    with self.state_lock:\n        state = self.state.get()\n        self.state.set(state.set_optimal_rewards(optimal_rewards))\n</code></pre>"},{"location":"reference/model/hyperparameters/random_search/random_search/#src.model.hyperparameters.random_search.random_search.RandomSearch.run_search_inner","title":"<code>run_search_inner()</code>","text":"<p>Run the actual search.</p> <p>this method is used internally please use <code>start_search</code> to actually start the search from another class.</p> Source code in <code>src/model/hyperparameters/random_search/random_search.py</code> <pre><code>def run_search_inner(self):\n    \"\"\"Run the actual search.\n\n    this method is used internally please use `start_search` to actually\n    start the search from another class.\n    \"\"\"\n    while self.running.get():\n        for options in self.search_options:\n            if not self.running.get():\n                return\n            hyper_parameters = RandomParameterStrategy()\n\n            total_reward = ParameterEvaluator.evaluate_reward(\n                options, hyper_parameters, self.running\n            )\n\n            if not self.running.get():\n                return\n\n            with self.state_lock:\n                state = self.state.get()\n                self.state.set(\n                    state.record_result(\n                        options, hyper_parameters, total_reward\n                    )\n                )\n</code></pre>"},{"location":"reference/model/hyperparameters/random_search/random_search/#src.model.hyperparameters.random_search.random_search.RandomSearch.start_search","title":"<code>start_search()</code>","text":"<p>Start the searching process.</p> Source code in <code>src/model/hyperparameters/random_search/random_search.py</code> <pre><code>def start_search(self):\n    \"\"\"Start the searching process.\"\"\"\n    with self.state_lock:\n        if self.running.get():\n            return\n        self.running.set(True)\n        self.state.set(self.state.get().set_searching(True))\n\n    optimal_runner = Process(\n        target=self.run_optimal_search, name=\"optimal rewards search\"\n    )\n    optimal_runner.start()\n\n    for runner_id in range(self.worker_count):\n        search_runner = Process(\n            target=self.run_search_inner,\n            name=f\"random search runner {runner_id}\",\n        )\n        search_runner.start()\n</code></pre>"},{"location":"reference/model/hyperparameters/random_search/random_search/#src.model.hyperparameters.random_search.random_search.RandomSearch.stop_search","title":"<code>stop_search()</code>","text":"<p>Stop the searching process.</p> Source code in <code>src/model/hyperparameters/random_search/random_search.py</code> <pre><code>def stop_search(self):\n    \"\"\"Stop the searching process.\"\"\"\n    self.running.set(False)\n    with self.state_lock:\n        self.state.set(self.state.get().set_searching(False))\n</code></pre>"},{"location":"reference/model/hyperparameters/random_search/random_search_data/","title":"Random Search Data","text":""},{"location":"reference/model/hyperparameters/random_search/random_search_data/#src.model.hyperparameters.random_search.random_search_data.RandomSearchState","title":"<code>RandomSearchState</code>  <code>dataclass</code>","text":"<p>             Bases: <code>object</code></p> <p>Class to contain the state of a random search.</p> Source code in <code>src/model/hyperparameters/random_search/random_search_data.py</code> <pre><code>@dataclass(frozen=True, slots=True)\nclass RandomSearchState(object):\n    \"\"\"Class to contain the state of a random search.\"\"\"\n\n    optimal_rewards: Optional[Dict[DynamicsOptions, float]]\n    search_areas: Dict[TopEntitiesOptions, SearchArea]\n    searching: bool\n\n    def record_result(\n        self,\n        options: TopEntitiesOptions,\n        hyper_parameters: RandomParameterStrategy,\n        recorded_value: float,\n    ) -&gt; \"RandomSearchState\":\n        \"\"\"Get the new search area state after recording a new value.\n\n        Args:\n            options (TopEntitiesOptions): the options used for this record.\n            hyper_parameters (RandomParameterStrategy): the parameters that\n                were tested.\n            recorded_value (float): the value recorded by these parameters.\n\n        Returns:\n            RandomSearchData: the new state after this result.\n        \"\"\"\n        search_areas = self.search_areas.copy()\n        new_search_area = search_areas[options].record_result(\n            hyper_parameters, recorded_value\n        )\n        search_areas[options] = new_search_area\n        return replace(self, search_areas=search_areas)\n\n    def set_searching(self, searching: bool) -&gt; \"RandomSearchState\":\n        \"\"\"Set the searching property.\n\n        Args:\n            searching (bool): Weather the search process is ongoing.\n\n        Returns:\n            RandomSearchState: The new state with the updated value.\n        \"\"\"\n        return replace(self, searching=searching)\n\n    def set_optimal_rewards(\n        self, optimal_rewards: Dict[DynamicsOptions, float]\n    ) -&gt; \"RandomSearchState\":\n        \"\"\"Set the optimal reward for a given dynamics.\n\n        sets a listing of the best reward possible for each dynamics.\n\n        Args:\n            optimal_rewards (Dict[DynamicsOptions, float]): the best reward\n                possible.\n\n        Returns:\n            RandomSearchState: the state that includes this information.\n        \"\"\"\n        return replace(self, optimal_rewards=optimal_rewards)\n</code></pre>"},{"location":"reference/model/hyperparameters/random_search/random_search_data/#src.model.hyperparameters.random_search.random_search_data.RandomSearchState.record_result","title":"<code>record_result(options, hyper_parameters, recorded_value)</code>","text":"<p>Get the new search area state after recording a new value.</p> <p>Parameters:</p> Name Type Description Default <code>options</code> <code>TopEntitiesOptions</code> <p>the options used for this record.</p> required <code>hyper_parameters</code> <code>RandomParameterStrategy</code> <p>the parameters that were tested.</p> required <code>recorded_value</code> <code>float</code> <p>the value recorded by these parameters.</p> required <p>Returns:</p> Name Type Description <code>RandomSearchData</code> <code>RandomSearchState</code> <p>the new state after this result.</p> Source code in <code>src/model/hyperparameters/random_search/random_search_data.py</code> <pre><code>def record_result(\n    self,\n    options: TopEntitiesOptions,\n    hyper_parameters: RandomParameterStrategy,\n    recorded_value: float,\n) -&gt; \"RandomSearchState\":\n    \"\"\"Get the new search area state after recording a new value.\n\n    Args:\n        options (TopEntitiesOptions): the options used for this record.\n        hyper_parameters (RandomParameterStrategy): the parameters that\n            were tested.\n        recorded_value (float): the value recorded by these parameters.\n\n    Returns:\n        RandomSearchData: the new state after this result.\n    \"\"\"\n    search_areas = self.search_areas.copy()\n    new_search_area = search_areas[options].record_result(\n        hyper_parameters, recorded_value\n    )\n    search_areas[options] = new_search_area\n    return replace(self, search_areas=search_areas)\n</code></pre>"},{"location":"reference/model/hyperparameters/random_search/random_search_data/#src.model.hyperparameters.random_search.random_search_data.RandomSearchState.set_optimal_rewards","title":"<code>set_optimal_rewards(optimal_rewards)</code>","text":"<p>Set the optimal reward for a given dynamics.</p> <p>sets a listing of the best reward possible for each dynamics.</p> <p>Parameters:</p> Name Type Description Default <code>optimal_rewards</code> <code>Dict[DynamicsOptions, float]</code> <p>the best reward possible.</p> required <p>Returns:</p> Name Type Description <code>RandomSearchState</code> <code>RandomSearchState</code> <p>the state that includes this information.</p> Source code in <code>src/model/hyperparameters/random_search/random_search_data.py</code> <pre><code>def set_optimal_rewards(\n    self, optimal_rewards: Dict[DynamicsOptions, float]\n) -&gt; \"RandomSearchState\":\n    \"\"\"Set the optimal reward for a given dynamics.\n\n    sets a listing of the best reward possible for each dynamics.\n\n    Args:\n        optimal_rewards (Dict[DynamicsOptions, float]): the best reward\n            possible.\n\n    Returns:\n        RandomSearchState: the state that includes this information.\n    \"\"\"\n    return replace(self, optimal_rewards=optimal_rewards)\n</code></pre>"},{"location":"reference/model/hyperparameters/random_search/random_search_data/#src.model.hyperparameters.random_search.random_search_data.RandomSearchState.set_searching","title":"<code>set_searching(searching)</code>","text":"<p>Set the searching property.</p> <p>Parameters:</p> Name Type Description Default <code>searching</code> <code>bool</code> <p>Weather the search process is ongoing.</p> required <p>Returns:</p> Name Type Description <code>RandomSearchState</code> <code>RandomSearchState</code> <p>The new state with the updated value.</p> Source code in <code>src/model/hyperparameters/random_search/random_search_data.py</code> <pre><code>def set_searching(self, searching: bool) -&gt; \"RandomSearchState\":\n    \"\"\"Set the searching property.\n\n    Args:\n        searching (bool): Weather the search process is ongoing.\n\n    Returns:\n        RandomSearchState: The new state with the updated value.\n    \"\"\"\n    return replace(self, searching=searching)\n</code></pre>"},{"location":"reference/model/hyperparameters/random_search/random_search_data/#src.model.hyperparameters.random_search.random_search_data.SearchArea","title":"<code>SearchArea</code>  <code>dataclass</code>","text":"<p>             Bases: <code>object</code></p> <p>Represents the results of a search in a particular area.</p> Source code in <code>src/model/hyperparameters/random_search/random_search_data.py</code> <pre><code>@dataclass(frozen=True, slots=True)\nclass SearchArea(object):\n    \"\"\"Represents the results of a search in a particular area.\"\"\"\n\n    options: TopEntitiesOptions\n    best_parameters: Dict[HyperParameter, Optional[float]]\n    best_value: Optional[float]\n    combinations_tried: int\n\n    def record_result(\n        self, hyper_parameters: RandomParameterStrategy, recorded_value: float\n    ) -&gt; \"SearchArea\":\n        \"\"\"Get the new search area state after recording a new value.\n\n        Args:\n            hyper_parameters (RandomParameterStrategy): the parameters that\n                were tested.\n            recorded_value (float): the value recorded by these parameters.\n\n        Returns:\n            SearchArea: the new search area with these changes.\n        \"\"\"\n        combinations_tried = self.combinations_tried + 1\n\n        if self.best_value is None or recorded_value &gt; self.best_value:\n            return SearchArea(\n                self.options,\n                hyper_parameters.get_parameters(),\n                recorded_value,\n                combinations_tried,\n            )\n\n        return SearchArea(\n            self.options,\n            self.best_parameters,\n            self.best_value,\n            combinations_tried,\n        )\n</code></pre>"},{"location":"reference/model/hyperparameters/random_search/random_search_data/#src.model.hyperparameters.random_search.random_search_data.SearchArea.record_result","title":"<code>record_result(hyper_parameters, recorded_value)</code>","text":"<p>Get the new search area state after recording a new value.</p> <p>Parameters:</p> Name Type Description Default <code>hyper_parameters</code> <code>RandomParameterStrategy</code> <p>the parameters that were tested.</p> required <code>recorded_value</code> <code>float</code> <p>the value recorded by these parameters.</p> required <p>Returns:</p> Name Type Description <code>SearchArea</code> <code>SearchArea</code> <p>the new search area with these changes.</p> Source code in <code>src/model/hyperparameters/random_search/random_search_data.py</code> <pre><code>def record_result(\n    self, hyper_parameters: RandomParameterStrategy, recorded_value: float\n) -&gt; \"SearchArea\":\n    \"\"\"Get the new search area state after recording a new value.\n\n    Args:\n        hyper_parameters (RandomParameterStrategy): the parameters that\n            were tested.\n        recorded_value (float): the value recorded by these parameters.\n\n    Returns:\n        SearchArea: the new search area with these changes.\n    \"\"\"\n    combinations_tried = self.combinations_tried + 1\n\n    if self.best_value is None or recorded_value &gt; self.best_value:\n        return SearchArea(\n            self.options,\n            hyper_parameters.get_parameters(),\n            recorded_value,\n            combinations_tried,\n        )\n\n    return SearchArea(\n        self.options,\n        self.best_parameters,\n        self.best_value,\n        combinations_tried,\n    )\n</code></pre>"},{"location":"reference/model/hyperparameters/report_generation/","title":"Report Generation","text":"<p>This package contains code relating to the creation of parameter reports.</p>"},{"location":"reference/model/hyperparameters/report_generation/compute_confidence_interval/","title":"Compute Confidence Interval","text":""},{"location":"reference/model/hyperparameters/report_generation/compute_confidence_interval/#src.model.hyperparameters.report_generation.compute_confidence_interval.compute_confidence_interval","title":"<code>compute_confidence_interval(rewards, confidence_level, confidence_iterations)</code>","text":"<p>Compute the confidence interval from a series of samples.</p> <p>This method uses bootstrapping to reduce sensitivity to outliers.</p> <p>Parameters:</p> Name Type Description Default <code>rewards</code> <code>ndarray</code> <p>Array of samples.</p> required <code>confidence_level</code> <code>float</code> <p>Desired confidence level (e.g., 0.95 for 95% confidence interval).</p> required <code>confidence_iterations</code> <code>int</code> <p>Number of bootstrap iterations.</p> required <p>Returns:</p> Name Type Description <code>Tuple</code> <code>Tuple[float, float, float]</code> <p>the confidence interval, the lower bound mean and upper bound.</p> Source code in <code>src/model/hyperparameters/report_generation/compute_confidence_interval.py</code> <pre><code>@jit(nopython=True, cache=True, fastmath=True)\ndef compute_confidence_interval(\n    rewards: np.ndarray, confidence_level: float, confidence_iterations: int\n) -&gt; Tuple[float, float, float]:\n    \"\"\"Compute the confidence interval from a series of samples.\n\n    This method uses bootstrapping to reduce sensitivity to outliers.\n\n    Args:\n        rewards (np.ndarray): Array of samples.\n        confidence_level (float): Desired confidence level (e.g., 0.95 for 95%\n            confidence interval).\n        confidence_iterations (int): Number of bootstrap iterations.\n\n    Returns:\n        Tuple: the confidence interval, the lower bound\n            mean and upper bound.\n    \"\"\"\n    sample_count = len(rewards)\n    means = np.empty(confidence_iterations)\n\n    for index in range(confidence_iterations):\n        # Bootstrap sampling\n        resample_indices = np.random.randint(0, sample_count, sample_count)\n        resample = rewards[resample_indices]\n\n        means[index] = np.mean(resample)\n\n    # Calculate confidence interval using percentiles\n    lower_percentile = (1 - confidence_level) / 2 * 100\n    upper_percentile = 100 - lower_percentile\n\n    lower_bound = np.percentile(means, lower_percentile)\n    upper_bound = np.percentile(means, upper_percentile)\n\n    return float(lower_bound), float(np.mean(rewards)), float(upper_bound)\n</code></pre>"},{"location":"reference/model/hyperparameters/report_generation/report_data/","title":"Report Data","text":""},{"location":"reference/model/hyperparameters/report_generation/report_data/#src.model.hyperparameters.report_generation.report_data.HyperParameterReport","title":"<code>HyperParameterReport</code>  <code>dataclass</code>","text":"<p>             Bases: <code>object</code></p> <p>Describes the effect of a hyper parameter.</p> Source code in <code>src/model/hyperparameters/report_generation/report_data.py</code> <pre><code>@dataclass(frozen=True, slots=True)\nclass HyperParameterReport(object):\n    \"\"\"Describes the effect of a hyper parameter.\"\"\"\n\n    parameter: HyperParameter\n    x_axis: List\n    lower_confidence_bound: List\n    y_axis: List\n    upper_confidence_bound: List\n</code></pre>"},{"location":"reference/model/hyperparameters/report_generation/report_data/#src.model.hyperparameters.report_generation.report_data.ReportState","title":"<code>ReportState</code>  <code>dataclass</code>","text":"<p>             Bases: <code>object</code></p> <p>Contains the state of all the reports.</p> Source code in <code>src/model/hyperparameters/report_generation/report_data.py</code> <pre><code>@dataclass(frozen=True, slots=True)\nclass ReportState(object):\n    \"\"\"Contains the state of all the reports.\"\"\"\n\n    current_report: Optional[HyperParameter]\n    pending_requests: Dict[HyperParameter, float]\n\n    available_reports: Dict[HyperParameter, HyperParameterReport]\n\n    def report_requested(self, request: HyperParameter) -&gt; \"ReportState\":\n        \"\"\"Get the new state after a new request is made.\n\n        Args:\n            request (HyperParameter): the report the user wants generated.\n\n        Returns:\n            ReportState: the current state of all reports\n        \"\"\"\n        pending = request in self.pending_requests\n        available = request in self.available_reports\n        if pending or available:\n            if request is self.current_report:\n                return self\n            return replace(self, current_report=request)\n\n        pending_requests = self.pending_requests.copy()\n        pending_requests[request] = 0\n        return ReportState(request, pending_requests, self.available_reports)\n\n    def update_report_progress(\n        self, parameter: HyperParameter, progress: float\n    ) -&gt; \"ReportState\":\n        \"\"\"Update the progress marker for a pending report.\n\n        Args:\n            parameter (HyperParameter): the pending report\n            progress (float): the new progress of this report\n\n        Returns:\n            ReportState: the new state with the updated progress.\n        \"\"\"\n        if parameter not in self.pending_requests:\n            return self\n\n        pending_requests = self.pending_requests.copy()\n        # if progress of an incomplete report is &gt;= 1 it can break\n        # a progress assumption made by the controller\n        pending_requests[parameter] = min(progress, incomplete_progress_cap)\n        return ReportState(\n            self.current_report, pending_requests, self.available_reports\n        )\n\n    def complete_request(self, report: HyperParameterReport) -&gt; \"ReportState\":\n        \"\"\"Create the new state after a report is completed.\n\n        Args:\n            report (HyperParameterReport): The new completed report.\n\n        Returns:\n            ReportState: the new report state including the new report\n        \"\"\"\n        parameter = report.parameter\n        pending_requests = self.pending_requests.copy()\n        pending_requests.pop(parameter)\n        available_reports = self.available_reports.copy()\n        available_reports[parameter] = report\n        return ReportState(\n            self.current_report, pending_requests, available_reports\n        )\n</code></pre>"},{"location":"reference/model/hyperparameters/report_generation/report_data/#src.model.hyperparameters.report_generation.report_data.ReportState.complete_request","title":"<code>complete_request(report)</code>","text":"<p>Create the new state after a report is completed.</p> <p>Parameters:</p> Name Type Description Default <code>report</code> <code>HyperParameterReport</code> <p>The new completed report.</p> required <p>Returns:</p> Name Type Description <code>ReportState</code> <code>ReportState</code> <p>the new report state including the new report</p> Source code in <code>src/model/hyperparameters/report_generation/report_data.py</code> <pre><code>def complete_request(self, report: HyperParameterReport) -&gt; \"ReportState\":\n    \"\"\"Create the new state after a report is completed.\n\n    Args:\n        report (HyperParameterReport): The new completed report.\n\n    Returns:\n        ReportState: the new report state including the new report\n    \"\"\"\n    parameter = report.parameter\n    pending_requests = self.pending_requests.copy()\n    pending_requests.pop(parameter)\n    available_reports = self.available_reports.copy()\n    available_reports[parameter] = report\n    return ReportState(\n        self.current_report, pending_requests, available_reports\n    )\n</code></pre>"},{"location":"reference/model/hyperparameters/report_generation/report_data/#src.model.hyperparameters.report_generation.report_data.ReportState.report_requested","title":"<code>report_requested(request)</code>","text":"<p>Get the new state after a new request is made.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>HyperParameter</code> <p>the report the user wants generated.</p> required <p>Returns:</p> Name Type Description <code>ReportState</code> <code>ReportState</code> <p>the current state of all reports</p> Source code in <code>src/model/hyperparameters/report_generation/report_data.py</code> <pre><code>def report_requested(self, request: HyperParameter) -&gt; \"ReportState\":\n    \"\"\"Get the new state after a new request is made.\n\n    Args:\n        request (HyperParameter): the report the user wants generated.\n\n    Returns:\n        ReportState: the current state of all reports\n    \"\"\"\n    pending = request in self.pending_requests\n    available = request in self.available_reports\n    if pending or available:\n        if request is self.current_report:\n            return self\n        return replace(self, current_report=request)\n\n    pending_requests = self.pending_requests.copy()\n    pending_requests[request] = 0\n    return ReportState(request, pending_requests, self.available_reports)\n</code></pre>"},{"location":"reference/model/hyperparameters/report_generation/report_data/#src.model.hyperparameters.report_generation.report_data.ReportState.update_report_progress","title":"<code>update_report_progress(parameter, progress)</code>","text":"<p>Update the progress marker for a pending report.</p> <p>Parameters:</p> Name Type Description Default <code>parameter</code> <code>HyperParameter</code> <p>the pending report</p> required <code>progress</code> <code>float</code> <p>the new progress of this report</p> required <p>Returns:</p> Name Type Description <code>ReportState</code> <code>ReportState</code> <p>the new state with the updated progress.</p> Source code in <code>src/model/hyperparameters/report_generation/report_data.py</code> <pre><code>def update_report_progress(\n    self, parameter: HyperParameter, progress: float\n) -&gt; \"ReportState\":\n    \"\"\"Update the progress marker for a pending report.\n\n    Args:\n        parameter (HyperParameter): the pending report\n        progress (float): the new progress of this report\n\n    Returns:\n        ReportState: the new state with the updated progress.\n    \"\"\"\n    if parameter not in self.pending_requests:\n        return self\n\n    pending_requests = self.pending_requests.copy()\n    # if progress of an incomplete report is &gt;= 1 it can break\n    # a progress assumption made by the controller\n    pending_requests[parameter] = min(progress, incomplete_progress_cap)\n    return ReportState(\n        self.current_report, pending_requests, self.available_reports\n    )\n</code></pre>"},{"location":"reference/model/hyperparameters/report_generation/report_generator/","title":"Report Generator","text":""},{"location":"reference/model/hyperparameters/report_generation/report_generator/#src.model.hyperparameters.report_generation.report_generator.HyperParameterReportGenerator","title":"<code>HyperParameterReportGenerator</code>","text":"<p>             Bases: <code>object</code></p> <p>Class for creating hyper parameter tuning reports.</p> Source code in <code>src/model/hyperparameters/report_generation/report_generator.py</code> <pre><code>class HyperParameterReportGenerator(object):\n    \"\"\"Class for creating hyper parameter tuning reports.\"\"\"\n\n    worker_count = 8\n    iterations_per_worker = 1000\n    samples = 100\n    runs = 25\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialise the report generator.\"\"\"\n        manager = Manager()\n\n        self.state = manager.Value(ReportState, ReportState(None, {}, {}))\n        self.state_lock = manager.Lock()\n\n        self.running = manager.Value(bool, value=True)\n\n    def shutdown(self):\n        \"\"\"Abort any existing work, Stop child processes.\"\"\"\n        self.running.set(False)\n\n    def get_state(self) -&gt; ReportState:\n        \"\"\"Get the current state of the reports.\n\n        Returns:\n            ReportState: the current state of the reports.\n        \"\"\"\n        with self.state_lock:\n            return self.state.value\n\n    def generate_report(self, parameter: HyperParameter):\n        \"\"\"Generate a report about a given hyper parameter.\n\n        Args:\n            parameter (HyperParameter): the parameter to create the report for.\n\n        Raises:\n            ValueError: if the parameter is not valid for report generation.\n        \"\"\"\n        if parameter not in TuningInformation.tunable_parameters():\n            raise ValueError(\n                f\"parameter {parameter.name} is not valid for tuning.\"\n            )\n        with self.state_lock:\n            state = self.state.get()\n            self.state.set(state.report_requested(parameter))\n\n            pending = parameter in state.pending_requests\n            available = parameter in state.available_reports\n\n            if pending or available:\n                # skip redundant information\n                return\n\n        generator = Process(\n            target=self.generate_report_worker,\n            name=f\"report-generator {parameter.name}\",\n            args=(parameter,),\n        )\n        generator.start()\n\n    def generate_report_worker(self, parameter: HyperParameter):\n        \"\"\"Generate a report for a given parameter.\n\n        this is the internal method that does the heavy lifting in a separate\n        thread. the public method should do all of the validation.\n\n        Args:\n            parameter (HyperParameter): the parameter to evaluate\n        \"\"\"\n        details = TuningInformation.get_parameter_details(parameter)\n        samples = details.cap_samples(self.samples)\n        progress_steps = np.linspace(0, 1, samples)\n        interpolate = np.vectorize(details.interpolate_value)\n        x_axis = interpolate(progress_steps)\n        run_progress = 1 / (samples * self.runs)\n\n        with Pool(processes=self.worker_count) as pool:\n            simulation_results = pool.starmap(\n                self.evaluate_value,\n                zip(repeat(parameter), x_axis, repeat(run_progress)),\n            )\n            if not self.running:\n                return\n\n            lower_bounds, y_axis, upper_bounds = map(\n                list, zip(*simulation_results)\n            )\n\n            report = HyperParameterReport(\n                parameter, x_axis, lower_bounds, y_axis, upper_bounds\n            )\n\n            with self.state_lock:\n                state = self.state.get()\n                self.state.set(state.complete_request(report))\n\n    confidence_level = 0.95\n    confidence_iterations = 1000\n\n    def evaluate_value(\n        self,\n        parameter: HyperParameter,\n        parameter_value: float,\n        run_progress_amount: float,\n    ) -&gt; Tuple[float, float, float]:\n        \"\"\"Evaluate a parameter and value combination.\n\n        Args:\n            parameter (HyperParameter): the parameter to test\n            parameter_value (float): the value for this parameter to assume\n            run_progress_amount (float): the amount of progress made in a single\n                run.\n\n        Returns:\n            float: the total reward under these conditions.\n        \"\"\"\n        # skip computation if shutting down.\n        details = TuningInformation.get_parameter_details(parameter)\n        hyper_parameters = ParameterTuningStrategy(parameter, parameter_value)\n\n        rewards = []\n\n        for _ in range(self.runs):\n            if not self.running.get():\n                return 0, 0, 0\n            stats = ParameterEvaluator.single_run(\n                details.tuning_options, hyper_parameters\n            )\n            rewards.append(stats.total_reward)\n\n            with self.state_lock:\n                state = self.state.get()\n                new_progress = (\n                    state.pending_requests.get(parameter, 1)\n                    + run_progress_amount\n                )\n                self.state.set(\n                    state.update_report_progress(parameter, new_progress)\n                )\n\n        return compute_confidence_interval(\n            np.array(rewards, dtype=np.float64),\n            self.confidence_level,\n            self.confidence_iterations,\n        )\n</code></pre>"},{"location":"reference/model/hyperparameters/report_generation/report_generator/#src.model.hyperparameters.report_generation.report_generator.HyperParameterReportGenerator.__init__","title":"<code>__init__()</code>","text":"<p>Initialise the report generator.</p> Source code in <code>src/model/hyperparameters/report_generation/report_generator.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialise the report generator.\"\"\"\n    manager = Manager()\n\n    self.state = manager.Value(ReportState, ReportState(None, {}, {}))\n    self.state_lock = manager.Lock()\n\n    self.running = manager.Value(bool, value=True)\n</code></pre>"},{"location":"reference/model/hyperparameters/report_generation/report_generator/#src.model.hyperparameters.report_generation.report_generator.HyperParameterReportGenerator.evaluate_value","title":"<code>evaluate_value(parameter, parameter_value, run_progress_amount)</code>","text":"<p>Evaluate a parameter and value combination.</p> <p>Parameters:</p> Name Type Description Default <code>parameter</code> <code>HyperParameter</code> <p>the parameter to test</p> required <code>parameter_value</code> <code>float</code> <p>the value for this parameter to assume</p> required <code>run_progress_amount</code> <code>float</code> <p>the amount of progress made in a single run.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>Tuple[float, float, float]</code> <p>the total reward under these conditions.</p> Source code in <code>src/model/hyperparameters/report_generation/report_generator.py</code> <pre><code>def evaluate_value(\n    self,\n    parameter: HyperParameter,\n    parameter_value: float,\n    run_progress_amount: float,\n) -&gt; Tuple[float, float, float]:\n    \"\"\"Evaluate a parameter and value combination.\n\n    Args:\n        parameter (HyperParameter): the parameter to test\n        parameter_value (float): the value for this parameter to assume\n        run_progress_amount (float): the amount of progress made in a single\n            run.\n\n    Returns:\n        float: the total reward under these conditions.\n    \"\"\"\n    # skip computation if shutting down.\n    details = TuningInformation.get_parameter_details(parameter)\n    hyper_parameters = ParameterTuningStrategy(parameter, parameter_value)\n\n    rewards = []\n\n    for _ in range(self.runs):\n        if not self.running.get():\n            return 0, 0, 0\n        stats = ParameterEvaluator.single_run(\n            details.tuning_options, hyper_parameters\n        )\n        rewards.append(stats.total_reward)\n\n        with self.state_lock:\n            state = self.state.get()\n            new_progress = (\n                state.pending_requests.get(parameter, 1)\n                + run_progress_amount\n            )\n            self.state.set(\n                state.update_report_progress(parameter, new_progress)\n            )\n\n    return compute_confidence_interval(\n        np.array(rewards, dtype=np.float64),\n        self.confidence_level,\n        self.confidence_iterations,\n    )\n</code></pre>"},{"location":"reference/model/hyperparameters/report_generation/report_generator/#src.model.hyperparameters.report_generation.report_generator.HyperParameterReportGenerator.generate_report","title":"<code>generate_report(parameter)</code>","text":"<p>Generate a report about a given hyper parameter.</p> <p>Parameters:</p> Name Type Description Default <code>parameter</code> <code>HyperParameter</code> <p>the parameter to create the report for.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>if the parameter is not valid for report generation.</p> Source code in <code>src/model/hyperparameters/report_generation/report_generator.py</code> <pre><code>def generate_report(self, parameter: HyperParameter):\n    \"\"\"Generate a report about a given hyper parameter.\n\n    Args:\n        parameter (HyperParameter): the parameter to create the report for.\n\n    Raises:\n        ValueError: if the parameter is not valid for report generation.\n    \"\"\"\n    if parameter not in TuningInformation.tunable_parameters():\n        raise ValueError(\n            f\"parameter {parameter.name} is not valid for tuning.\"\n        )\n    with self.state_lock:\n        state = self.state.get()\n        self.state.set(state.report_requested(parameter))\n\n        pending = parameter in state.pending_requests\n        available = parameter in state.available_reports\n\n        if pending or available:\n            # skip redundant information\n            return\n\n    generator = Process(\n        target=self.generate_report_worker,\n        name=f\"report-generator {parameter.name}\",\n        args=(parameter,),\n    )\n    generator.start()\n</code></pre>"},{"location":"reference/model/hyperparameters/report_generation/report_generator/#src.model.hyperparameters.report_generation.report_generator.HyperParameterReportGenerator.generate_report_worker","title":"<code>generate_report_worker(parameter)</code>","text":"<p>Generate a report for a given parameter.</p> <p>this is the internal method that does the heavy lifting in a separate thread. the public method should do all of the validation.</p> <p>Parameters:</p> Name Type Description Default <code>parameter</code> <code>HyperParameter</code> <p>the parameter to evaluate</p> required Source code in <code>src/model/hyperparameters/report_generation/report_generator.py</code> <pre><code>def generate_report_worker(self, parameter: HyperParameter):\n    \"\"\"Generate a report for a given parameter.\n\n    this is the internal method that does the heavy lifting in a separate\n    thread. the public method should do all of the validation.\n\n    Args:\n        parameter (HyperParameter): the parameter to evaluate\n    \"\"\"\n    details = TuningInformation.get_parameter_details(parameter)\n    samples = details.cap_samples(self.samples)\n    progress_steps = np.linspace(0, 1, samples)\n    interpolate = np.vectorize(details.interpolate_value)\n    x_axis = interpolate(progress_steps)\n    run_progress = 1 / (samples * self.runs)\n\n    with Pool(processes=self.worker_count) as pool:\n        simulation_results = pool.starmap(\n            self.evaluate_value,\n            zip(repeat(parameter), x_axis, repeat(run_progress)),\n        )\n        if not self.running:\n            return\n\n        lower_bounds, y_axis, upper_bounds = map(\n            list, zip(*simulation_results)\n        )\n\n        report = HyperParameterReport(\n            parameter, x_axis, lower_bounds, y_axis, upper_bounds\n        )\n\n        with self.state_lock:\n            state = self.state.get()\n            self.state.set(state.complete_request(report))\n</code></pre>"},{"location":"reference/model/hyperparameters/report_generation/report_generator/#src.model.hyperparameters.report_generation.report_generator.HyperParameterReportGenerator.get_state","title":"<code>get_state()</code>","text":"<p>Get the current state of the reports.</p> <p>Returns:</p> Name Type Description <code>ReportState</code> <code>ReportState</code> <p>the current state of the reports.</p> Source code in <code>src/model/hyperparameters/report_generation/report_generator.py</code> <pre><code>def get_state(self) -&gt; ReportState:\n    \"\"\"Get the current state of the reports.\n\n    Returns:\n        ReportState: the current state of the reports.\n    \"\"\"\n    with self.state_lock:\n        return self.state.value\n</code></pre>"},{"location":"reference/model/hyperparameters/report_generation/report_generator/#src.model.hyperparameters.report_generation.report_generator.HyperParameterReportGenerator.shutdown","title":"<code>shutdown()</code>","text":"<p>Abort any existing work, Stop child processes.</p> Source code in <code>src/model/hyperparameters/report_generation/report_generator.py</code> <pre><code>def shutdown(self):\n    \"\"\"Abort any existing work, Stop child processes.\"\"\"\n    self.running.set(False)\n</code></pre>"},{"location":"reference/model/hyperparameters/report_generation/tuning_parameter_strategy/","title":"Tuning Parameter Strategy","text":""},{"location":"reference/model/hyperparameters/report_generation/tuning_parameter_strategy/#src.model.hyperparameters.report_generation.tuning_parameter_strategy.ParameterTuningStrategy","title":"<code>ParameterTuningStrategy</code>","text":"<p>             Bases: <code>ParameterConfigStrategy</code></p> <p>This class provides hyperparameter values with the tuning adjustment.</p> Source code in <code>src/model/hyperparameters/report_generation/tuning_parameter_strategy.py</code> <pre><code>class ParameterTuningStrategy(ParameterConfigStrategy):\n    \"\"\"This class provides hyperparameter values with the tuning adjustment.\"\"\"\n\n    def __init__(\n        self, tuning_parameter: HyperParameter, parameter_value: float\n    ) -&gt; None:\n        \"\"\"Initialise the parameter manager.\n\n        Args:\n            tuning_parameter (HyperParameter): the parameter that should be\n                varied.\n            parameter_value (float): the set value of this parameter.\n        \"\"\"\n        super().__init__()\n        self.tuning_parameter = tuning_parameter\n        self.parameter_value = parameter_value\n\n    @override\n    def get_value(self, parameter: HyperParameter) -&gt; float:\n        \"\"\"Get the value of a given hyper parameter.\n\n        Args:\n            parameter (HyperParameter): the parameter to access.\n\n        Raises:\n            ValueError: if the parameter provided is not known.\n\n        Returns:\n            float: the value of this parameter.\n        \"\"\"\n        if parameter is not self.tuning_parameter:\n            return super().get_value(parameter)\n\n        return self.parameter_value\n</code></pre>"},{"location":"reference/model/hyperparameters/report_generation/tuning_parameter_strategy/#src.model.hyperparameters.report_generation.tuning_parameter_strategy.ParameterTuningStrategy.__init__","title":"<code>__init__(tuning_parameter, parameter_value)</code>","text":"<p>Initialise the parameter manager.</p> <p>Parameters:</p> Name Type Description Default <code>tuning_parameter</code> <code>HyperParameter</code> <p>the parameter that should be varied.</p> required <code>parameter_value</code> <code>float</code> <p>the set value of this parameter.</p> required Source code in <code>src/model/hyperparameters/report_generation/tuning_parameter_strategy.py</code> <pre><code>def __init__(\n    self, tuning_parameter: HyperParameter, parameter_value: float\n) -&gt; None:\n    \"\"\"Initialise the parameter manager.\n\n    Args:\n        tuning_parameter (HyperParameter): the parameter that should be\n            varied.\n        parameter_value (float): the set value of this parameter.\n    \"\"\"\n    super().__init__()\n    self.tuning_parameter = tuning_parameter\n    self.parameter_value = parameter_value\n</code></pre>"},{"location":"reference/model/hyperparameters/report_generation/tuning_parameter_strategy/#src.model.hyperparameters.report_generation.tuning_parameter_strategy.ParameterTuningStrategy.get_value","title":"<code>get_value(parameter)</code>","text":"<p>Get the value of a given hyper parameter.</p> <p>Parameters:</p> Name Type Description Default <code>parameter</code> <code>HyperParameter</code> <p>the parameter to access.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>if the parameter provided is not known.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the value of this parameter.</p> Source code in <code>src/model/hyperparameters/report_generation/tuning_parameter_strategy.py</code> <pre><code>@override\ndef get_value(self, parameter: HyperParameter) -&gt; float:\n    \"\"\"Get the value of a given hyper parameter.\n\n    Args:\n        parameter (HyperParameter): the parameter to access.\n\n    Raises:\n        ValueError: if the parameter provided is not known.\n\n    Returns:\n        float: the value of this parameter.\n    \"\"\"\n    if parameter is not self.tuning_parameter:\n        return super().get_value(parameter)\n\n    return self.parameter_value\n</code></pre>"},{"location":"reference/model/learning_system/","title":"Learning System","text":"<p>This package connects agents and dynamics.</p> <p>It provides methods for progressing the current state and visualising it.</p>"},{"location":"reference/model/learning_system/base_entity_decorator/","title":"Base Entity Decorator","text":""},{"location":"reference/model/learning_system/base_entity_decorator/#src.model.learning_system.base_entity_decorator.BaseEntityDecorator","title":"<code>BaseEntityDecorator</code>","text":"<p>             Bases: <code>object</code></p> <p>Base class for Wrapper classes of the top level entities.</p> Source code in <code>src/model/learning_system/base_entity_decorator.py</code> <pre><code>class BaseEntityDecorator(object):\n    \"\"\"Base class for Wrapper classes of the top level entities.\"\"\"\n\n    def __init__(self, entities: EntityContainer) -&gt; None:\n        \"\"\"Initialise the decorator.\n\n        Args:\n            entities (EntityContainer): The entities the cell configuration is\n                based upon.\n        \"\"\"\n        self.entities = entities\n\n    def update_entities(self, entities: EntityContainer) -&gt; None:\n        \"\"\"Update the entities this wrapper uses internally.\n\n        Args:\n            entities (EntityContainer): The new entities used internally\n        \"\"\"\n        self.entities = entities\n\n    @property\n    def grid_world(self) -&gt; GridWorld:\n        \"\"\"Access the grid world.\n\n        Returns:\n            GridWorld: the grid world for these entities.\n        \"\"\"\n        return self.entities.dynamics.grid_world\n\n    @property\n    def state_pool(self) -&gt; StatePool:\n        \"\"\"Access the state pool.\n\n        Returns:\n            StatePool: the state pool uses by these entities.\n        \"\"\"\n        return self.entities.dynamics.state_pool\n\n    @property\n    def agent(self) -&gt; BaseAgent:\n        \"\"\"Access the agent of these entities.\n\n        Returns:\n            BaseAgent: the agent used by these entities\n        \"\"\"\n        return self.entities.agent\n\n    @property\n    def dynamics(self) -&gt; BaseDynamics:\n        \"\"\"Access the dynamics of these entities.\n\n        Returns:\n            BaseDynamics: the dynamics part of these entities\n        \"\"\"\n        return self.entities.dynamics\n\n    @property\n    def statistics(self) -&gt; StatisticsRecorder:\n        \"\"\"Access the statistics of these entities.\n\n        Returns:\n            StatisticsRecorder: the statistics part of these entities\n        \"\"\"\n        return self.entities.statistics\n</code></pre>"},{"location":"reference/model/learning_system/base_entity_decorator/#src.model.learning_system.base_entity_decorator.BaseEntityDecorator.agent","title":"<code>agent: BaseAgent</code>  <code>property</code>","text":"<p>Access the agent of these entities.</p> <p>Returns:</p> Name Type Description <code>BaseAgent</code> <code>BaseAgent</code> <p>the agent used by these entities</p>"},{"location":"reference/model/learning_system/base_entity_decorator/#src.model.learning_system.base_entity_decorator.BaseEntityDecorator.dynamics","title":"<code>dynamics: BaseDynamics</code>  <code>property</code>","text":"<p>Access the dynamics of these entities.</p> <p>Returns:</p> Name Type Description <code>BaseDynamics</code> <code>BaseDynamics</code> <p>the dynamics part of these entities</p>"},{"location":"reference/model/learning_system/base_entity_decorator/#src.model.learning_system.base_entity_decorator.BaseEntityDecorator.grid_world","title":"<code>grid_world: GridWorld</code>  <code>property</code>","text":"<p>Access the grid world.</p> <p>Returns:</p> Name Type Description <code>GridWorld</code> <code>GridWorld</code> <p>the grid world for these entities.</p>"},{"location":"reference/model/learning_system/base_entity_decorator/#src.model.learning_system.base_entity_decorator.BaseEntityDecorator.state_pool","title":"<code>state_pool: StatePool</code>  <code>property</code>","text":"<p>Access the state pool.</p> <p>Returns:</p> Name Type Description <code>StatePool</code> <code>StatePool</code> <p>the state pool uses by these entities.</p>"},{"location":"reference/model/learning_system/base_entity_decorator/#src.model.learning_system.base_entity_decorator.BaseEntityDecorator.statistics","title":"<code>statistics: StatisticsRecorder</code>  <code>property</code>","text":"<p>Access the statistics of these entities.</p> <p>Returns:</p> Name Type Description <code>StatisticsRecorder</code> <code>StatisticsRecorder</code> <p>the statistics part of these entities</p>"},{"location":"reference/model/learning_system/base_entity_decorator/#src.model.learning_system.base_entity_decorator.BaseEntityDecorator.__init__","title":"<code>__init__(entities)</code>","text":"<p>Initialise the decorator.</p> <p>Parameters:</p> Name Type Description Default <code>entities</code> <code>EntityContainer</code> <p>The entities the cell configuration is based upon.</p> required Source code in <code>src/model/learning_system/base_entity_decorator.py</code> <pre><code>def __init__(self, entities: EntityContainer) -&gt; None:\n    \"\"\"Initialise the decorator.\n\n    Args:\n        entities (EntityContainer): The entities the cell configuration is\n            based upon.\n    \"\"\"\n    self.entities = entities\n</code></pre>"},{"location":"reference/model/learning_system/base_entity_decorator/#src.model.learning_system.base_entity_decorator.BaseEntityDecorator.update_entities","title":"<code>update_entities(entities)</code>","text":"<p>Update the entities this wrapper uses internally.</p> <p>Parameters:</p> Name Type Description Default <code>entities</code> <code>EntityContainer</code> <p>The new entities used internally</p> required Source code in <code>src/model/learning_system/base_entity_decorator.py</code> <pre><code>def update_entities(self, entities: EntityContainer) -&gt; None:\n    \"\"\"Update the entities this wrapper uses internally.\n\n    Args:\n        entities (EntityContainer): The new entities used internally\n    \"\"\"\n    self.entities = entities\n</code></pre>"},{"location":"reference/model/learning_system/global_options/","title":"Global Options","text":""},{"location":"reference/model/learning_system/global_options/#src.model.learning_system.global_options.AutomaticOptions","title":"<code>AutomaticOptions</code>","text":"<p>             Bases: <code>Enum</code></p> <p>Enumerates the possible automatic states.</p> Source code in <code>src/model/learning_system/global_options.py</code> <pre><code>class AutomaticOptions(Enum):\n    \"\"\"Enumerates the possible automatic states.\"\"\"\n\n    manual = 0\n    automatic_paused = 1\n    automatic_playing = 2\n</code></pre>"},{"location":"reference/model/learning_system/global_options/#src.model.learning_system.global_options.GlobalOptions","title":"<code>GlobalOptions</code>  <code>dataclass</code>","text":"<p>             Bases: <code>object</code></p> <p>Class represents the current options.</p> Source code in <code>src/model/learning_system/global_options.py</code> <pre><code>@dataclass(frozen=True, slots=True)\nclass GlobalOptions(object):\n    \"\"\"Class represents the current options.\"\"\"\n\n    top_level_options: TopEntitiesOptions\n    display_mode: DisplayMode\n    automatic: AutomaticOptions\n</code></pre>"},{"location":"reference/model/learning_system/learning_system/","title":"Learning System","text":""},{"location":"reference/model/learning_system/learning_system/#src.model.learning_system.learning_system.LearningSystem","title":"<code>LearningSystem</code>","text":"<p>             Bases: <code>object</code></p> <p>Controller for managing one pair of agent and dynamics.</p> Source code in <code>src/model/learning_system/learning_system.py</code> <pre><code>class LearningSystem(object):\n    \"\"\"Controller for managing one pair of agent and dynamics.\"\"\"\n\n    initial_top_options = TopEntitiesOptions(\n        AgentOptions.value_iteration_optimised,\n        DynamicsOptions.collection,\n        ExplorationStrategyOptions.not_applicable,\n    )\n    initial_global_options = GlobalOptions(\n        initial_top_options,\n        DisplayMode.default,\n        AutomaticOptions.manual,\n    )\n\n    def __init__(self) -&gt; None:\n        \"\"\"Class for managing a complete learning system.\"\"\"\n        self.options = self.initial_global_options\n        self.entity_cache = TopEntitiesCache()\n        self.entities = self.entity_cache.get_entities(self.initial_top_options)\n        self.learning_instance = LearningInstance(self.entities)\n        self.state_description_factory = StateDescriptionFactory(\n            self.entities, self.options\n        )\n\n    def get_current_state(self) -&gt; StateDescription:\n        \"\"\"Get the current state of the learning instance.\n\n        Returns:\n            StateDescription: the current configuration for this state.\n        \"\"\"\n        state_id = self.learning_instance.get_current_state()\n        return self.state_description_factory.create_state_description(state_id)\n\n    def update_options(self, options: GlobalOptions):\n        \"\"\"Set the global options used by this system.\n\n        Args:\n            options (GlobalOptions): how to display the learning instance\n        \"\"\"\n        entity_options = options.top_level_options\n        entities_updated = entity_options != self.options.top_level_options\n        self.options = options\n        self.state_description_factory.update_options(options)\n        if entities_updated:\n            self.entities = self.entity_cache.get_entities(entity_options)\n            self.learning_instance.update_entities(self.entities)\n            self.state_description_factory.update_entities(self.entities)\n\n    def reset_top_level(self):\n        \"\"\"Reset the toplevel entities. wipes all learning information.\"\"\"\n        self.entities = self.entity_cache.create_new_entities(\n            self.options.top_level_options\n        )\n        self.learning_instance.update_entities(self.entities)\n        self.state_description_factory.update_entities(self.entities)\n</code></pre>"},{"location":"reference/model/learning_system/learning_system/#src.model.learning_system.learning_system.LearningSystem.__init__","title":"<code>__init__()</code>","text":"<p>Class for managing a complete learning system.</p> Source code in <code>src/model/learning_system/learning_system.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Class for managing a complete learning system.\"\"\"\n    self.options = self.initial_global_options\n    self.entity_cache = TopEntitiesCache()\n    self.entities = self.entity_cache.get_entities(self.initial_top_options)\n    self.learning_instance = LearningInstance(self.entities)\n    self.state_description_factory = StateDescriptionFactory(\n        self.entities, self.options\n    )\n</code></pre>"},{"location":"reference/model/learning_system/learning_system/#src.model.learning_system.learning_system.LearningSystem.get_current_state","title":"<code>get_current_state()</code>","text":"<p>Get the current state of the learning instance.</p> <p>Returns:</p> Name Type Description <code>StateDescription</code> <code>StateDescription</code> <p>the current configuration for this state.</p> Source code in <code>src/model/learning_system/learning_system.py</code> <pre><code>def get_current_state(self) -&gt; StateDescription:\n    \"\"\"Get the current state of the learning instance.\n\n    Returns:\n        StateDescription: the current configuration for this state.\n    \"\"\"\n    state_id = self.learning_instance.get_current_state()\n    return self.state_description_factory.create_state_description(state_id)\n</code></pre>"},{"location":"reference/model/learning_system/learning_system/#src.model.learning_system.learning_system.LearningSystem.reset_top_level","title":"<code>reset_top_level()</code>","text":"<p>Reset the toplevel entities. wipes all learning information.</p> Source code in <code>src/model/learning_system/learning_system.py</code> <pre><code>def reset_top_level(self):\n    \"\"\"Reset the toplevel entities. wipes all learning information.\"\"\"\n    self.entities = self.entity_cache.create_new_entities(\n        self.options.top_level_options\n    )\n    self.learning_instance.update_entities(self.entities)\n    self.state_description_factory.update_entities(self.entities)\n</code></pre>"},{"location":"reference/model/learning_system/learning_system/#src.model.learning_system.learning_system.LearningSystem.update_options","title":"<code>update_options(options)</code>","text":"<p>Set the global options used by this system.</p> <p>Parameters:</p> Name Type Description Default <code>options</code> <code>GlobalOptions</code> <p>how to display the learning instance</p> required Source code in <code>src/model/learning_system/learning_system.py</code> <pre><code>def update_options(self, options: GlobalOptions):\n    \"\"\"Set the global options used by this system.\n\n    Args:\n        options (GlobalOptions): how to display the learning instance\n    \"\"\"\n    entity_options = options.top_level_options\n    entities_updated = entity_options != self.options.top_level_options\n    self.options = options\n    self.state_description_factory.update_options(options)\n    if entities_updated:\n        self.entities = self.entity_cache.get_entities(entity_options)\n        self.learning_instance.update_entities(self.entities)\n        self.state_description_factory.update_entities(self.entities)\n</code></pre>"},{"location":"reference/model/learning_system/cell_configuration/","title":"Cell Configuration","text":"<p>This package encapsulates all information about a state in one place.</p>"},{"location":"reference/model/learning_system/cell_configuration/cell_configuration/","title":"Cell Configuration","text":""},{"location":"reference/model/learning_system/cell_configuration/cell_configuration/#src.model.learning_system.cell_configuration.cell_configuration.CellConfiguration","title":"<code>CellConfiguration</code>  <code>dataclass</code>","text":"<p>             Bases: <code>object</code></p> <p>Class to represent the configuration of a cell in a given state.</p> Source code in <code>src/model/learning_system/cell_configuration/cell_configuration.py</code> <pre><code>@dataclass(frozen=True)\nclass CellConfiguration(object):\n    \"\"\"Class to represent the configuration of a cell in a given state.\"\"\"\n\n    action_values_normalised: action_value_description\n    action_values_raw: action_value_description\n    location: Tuple[int, int]\n    cell_entity: CellEntity\n    cell_value_normalised: Optional[float] = None\n    cell_value_raw: Optional[float] = None\n\n    @property\n    def tooltip_text(self) -&gt; str:\n        \"\"\"Gets the text for a tooltip on hovering over the cell.\n\n        Returns:\n            str: the text to display to the user for extra information\n        \"\"\"\n        text = f\"cell={self.location}\"\n        if self.cell_value_raw is not None:\n            text += f\"\\ncell value={self.cell_value_raw:.4f}\"\n\n        for action in Action:\n            action_value = self.action_values_raw[action]\n            if action_value is not None:\n                text += f\"\\n{action.name} value = {action_value:.4f}\"\n        return text\n</code></pre>"},{"location":"reference/model/learning_system/cell_configuration/cell_configuration/#src.model.learning_system.cell_configuration.cell_configuration.CellConfiguration.tooltip_text","title":"<code>tooltip_text: str</code>  <code>property</code>","text":"<p>Gets the text for a tooltip on hovering over the cell.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>the text to display to the user for extra information</p>"},{"location":"reference/model/learning_system/cell_configuration/cell_configuration/#src.model.learning_system.cell_configuration.cell_configuration.DisplayMode","title":"<code>DisplayMode</code>","text":"<p>             Bases: <code>Enum</code></p> <p>Enumerates the different possible display styles.</p> Source code in <code>src/model/learning_system/cell_configuration/cell_configuration.py</code> <pre><code>class DisplayMode(Enum):\n    \"\"\"Enumerates the different possible display styles.\"\"\"\n\n    default = 0\n    state_value = 1\n    action_value_global = 2\n    action_value_local = 3\n    best_action = 4\n</code></pre>"},{"location":"reference/model/learning_system/cell_configuration/cell_configuration_factory/","title":"Cell Configuration Factory","text":""},{"location":"reference/model/learning_system/cell_configuration/cell_configuration_factory/#src.model.learning_system.cell_configuration.cell_configuration_factory.CellConfigurationFactory","title":"<code>CellConfigurationFactory</code>","text":"<p>             Bases: <code>BaseEntityDecorator</code></p> <p>Factory for creating cell configurations.</p> Source code in <code>src/model/learning_system/cell_configuration/cell_configuration_factory.py</code> <pre><code>class CellConfigurationFactory(BaseEntityDecorator):\n    \"\"\"Factory for creating cell configurations.\"\"\"\n\n    def __init__(self, entities: EntityContainer) -&gt; None:\n        \"\"\"Initialise the state Description factory.\n\n        Args:\n            entities (EntityContainer): The entities the cell configuration is\n                based upon.\n        \"\"\"\n        super().__init__(entities)\n        self.update_entities(entities)\n\n    @override\n    def update_entities(self, entities: EntityContainer) -&gt; None:\n        \"\"\"Update the entities used by this decorator.\n\n        Args:\n            entities (EntityContainer): the new entities to use.\n        \"\"\"\n        super().update_entities(entities)\n        self.cell_state_lookup = CellStateLookup(entities.dynamics)\n        self.value_normalisation_factory = NormaliserFactory(\n            entities.agent,\n            entities.dynamics,\n            enable_cache=False,\n        )\n\n    def get_cell_configuration(\n        self, state_id: int\n    ) -&gt; Dict[integer_position, CellConfiguration]:\n        \"\"\"Get a state description for this state ID.\n\n        Args:\n            state_id (int): the state to represent in the view\n\n        Returns:\n            StateDescription: the state description\n        \"\"\"\n        normaliser = self.value_normalisation_factory.create_normaliser(\n            state_id\n        )\n        state = self.state_pool.get_state_from_id(state_id)\n        return {\n            cell: self.__cell_configuration(state, normaliser, cell)\n            for cell in self.entities.dynamics.grid_world.list_cells()\n        }\n\n    def __cell_configuration(\n        self,\n        reference_state: StateInstance,\n        normaliser: StateValueNormaliser,\n        cell: Tuple[int, int],\n    ) -&gt; CellConfiguration:\n        \"\"\"Get the configuration of a cell in a given state.\n\n        Args:\n            reference_state (StateInstance): the state that this cell is\n                compared against.\n            normaliser (StateValueNormaliser): normaliser to get value\n            cell (tuple[int, int]): the cell to check.\n\n        Returns:\n            CellConfiguration: the cell's configuration\n        \"\"\"\n        action_values_normalised: action_value_description = {}\n        action_values_raw: action_value_description = {}\n\n        cell_state = self.cell_state_lookup.get_state(reference_state, cell)\n\n        if cell_state is None:\n            for action in Action:\n                action_values_normalised[action] = None\n                action_values_raw[action] = None\n\n            return CellConfiguration(\n                action_values_normalised,\n                action_values_raw,\n                cell,\n                self.__cell_entity(reference_state, cell),\n            )\n\n        cell_state_id = self.state_pool.get_state_id(cell_state)\n        for action in Action:\n            action_values_normalised[\n                action\n            ] = normaliser.get_state_action_value_normalised(cell_state, action)\n            action_values_raw[action] = self.agent.get_state_action_value(\n                cell_state_id, action\n            )\n\n        return CellConfiguration(\n            action_values_normalised,\n            action_values_raw,\n            cell,\n            self.__cell_entity(reference_state, cell),\n            normaliser.get_state_value_normalised(cell_state),\n            self.agent.get_state_value(cell_state_id),\n        )\n\n    def __cell_entity(\n        self, state: StateInstance, cell: tuple[int, int]\n    ) -&gt; CellEntity:\n        \"\"\"Get the cell entity at a given location.\n\n        Args:\n            state (StateInstance): the state the cell is in.\n            cell (tuple[int, int]): the location of the cell to check.\n\n        Raises:\n            ValueError: if the cell is not a valid location\n\n        Returns:\n            CellEntity: the cell entity at this location\n        \"\"\"\n        if not self.grid_world.is_in_bounds(cell):\n            raise ValueError(f\"location {cell} is not in bounds\")\n\n        if cell == state.agent_location:\n            return CellEntity.agent\n\n        return state.entities.get(cell, CellEntity.empty)\n</code></pre>"},{"location":"reference/model/learning_system/cell_configuration/cell_configuration_factory/#src.model.learning_system.cell_configuration.cell_configuration_factory.CellConfigurationFactory.__cell_configuration","title":"<code>__cell_configuration(reference_state, normaliser, cell)</code>","text":"<p>Get the configuration of a cell in a given state.</p> <p>Parameters:</p> Name Type Description Default <code>reference_state</code> <code>StateInstance</code> <p>the state that this cell is compared against.</p> required <code>normaliser</code> <code>StateValueNormaliser</code> <p>normaliser to get value</p> required <code>cell</code> <code>tuple[int, int]</code> <p>the cell to check.</p> required <p>Returns:</p> Name Type Description <code>CellConfiguration</code> <code>CellConfiguration</code> <p>the cell's configuration</p> Source code in <code>src/model/learning_system/cell_configuration/cell_configuration_factory.py</code> <pre><code>def __cell_configuration(\n    self,\n    reference_state: StateInstance,\n    normaliser: StateValueNormaliser,\n    cell: Tuple[int, int],\n) -&gt; CellConfiguration:\n    \"\"\"Get the configuration of a cell in a given state.\n\n    Args:\n        reference_state (StateInstance): the state that this cell is\n            compared against.\n        normaliser (StateValueNormaliser): normaliser to get value\n        cell (tuple[int, int]): the cell to check.\n\n    Returns:\n        CellConfiguration: the cell's configuration\n    \"\"\"\n    action_values_normalised: action_value_description = {}\n    action_values_raw: action_value_description = {}\n\n    cell_state = self.cell_state_lookup.get_state(reference_state, cell)\n\n    if cell_state is None:\n        for action in Action:\n            action_values_normalised[action] = None\n            action_values_raw[action] = None\n\n        return CellConfiguration(\n            action_values_normalised,\n            action_values_raw,\n            cell,\n            self.__cell_entity(reference_state, cell),\n        )\n\n    cell_state_id = self.state_pool.get_state_id(cell_state)\n    for action in Action:\n        action_values_normalised[\n            action\n        ] = normaliser.get_state_action_value_normalised(cell_state, action)\n        action_values_raw[action] = self.agent.get_state_action_value(\n            cell_state_id, action\n        )\n\n    return CellConfiguration(\n        action_values_normalised,\n        action_values_raw,\n        cell,\n        self.__cell_entity(reference_state, cell),\n        normaliser.get_state_value_normalised(cell_state),\n        self.agent.get_state_value(cell_state_id),\n    )\n</code></pre>"},{"location":"reference/model/learning_system/cell_configuration/cell_configuration_factory/#src.model.learning_system.cell_configuration.cell_configuration_factory.CellConfigurationFactory.__cell_entity","title":"<code>__cell_entity(state, cell)</code>","text":"<p>Get the cell entity at a given location.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>StateInstance</code> <p>the state the cell is in.</p> required <code>cell</code> <code>tuple[int, int]</code> <p>the location of the cell to check.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>if the cell is not a valid location</p> <p>Returns:</p> Name Type Description <code>CellEntity</code> <code>CellEntity</code> <p>the cell entity at this location</p> Source code in <code>src/model/learning_system/cell_configuration/cell_configuration_factory.py</code> <pre><code>def __cell_entity(\n    self, state: StateInstance, cell: tuple[int, int]\n) -&gt; CellEntity:\n    \"\"\"Get the cell entity at a given location.\n\n    Args:\n        state (StateInstance): the state the cell is in.\n        cell (tuple[int, int]): the location of the cell to check.\n\n    Raises:\n        ValueError: if the cell is not a valid location\n\n    Returns:\n        CellEntity: the cell entity at this location\n    \"\"\"\n    if not self.grid_world.is_in_bounds(cell):\n        raise ValueError(f\"location {cell} is not in bounds\")\n\n    if cell == state.agent_location:\n        return CellEntity.agent\n\n    return state.entities.get(cell, CellEntity.empty)\n</code></pre>"},{"location":"reference/model/learning_system/cell_configuration/cell_configuration_factory/#src.model.learning_system.cell_configuration.cell_configuration_factory.CellConfigurationFactory.__init__","title":"<code>__init__(entities)</code>","text":"<p>Initialise the state Description factory.</p> <p>Parameters:</p> Name Type Description Default <code>entities</code> <code>EntityContainer</code> <p>The entities the cell configuration is based upon.</p> required Source code in <code>src/model/learning_system/cell_configuration/cell_configuration_factory.py</code> <pre><code>def __init__(self, entities: EntityContainer) -&gt; None:\n    \"\"\"Initialise the state Description factory.\n\n    Args:\n        entities (EntityContainer): The entities the cell configuration is\n            based upon.\n    \"\"\"\n    super().__init__(entities)\n    self.update_entities(entities)\n</code></pre>"},{"location":"reference/model/learning_system/cell_configuration/cell_configuration_factory/#src.model.learning_system.cell_configuration.cell_configuration_factory.CellConfigurationFactory.get_cell_configuration","title":"<code>get_cell_configuration(state_id)</code>","text":"<p>Get a state description for this state ID.</p> <p>Parameters:</p> Name Type Description Default <code>state_id</code> <code>int</code> <p>the state to represent in the view</p> required <p>Returns:</p> Name Type Description <code>StateDescription</code> <code>Dict[integer_position, CellConfiguration]</code> <p>the state description</p> Source code in <code>src/model/learning_system/cell_configuration/cell_configuration_factory.py</code> <pre><code>def get_cell_configuration(\n    self, state_id: int\n) -&gt; Dict[integer_position, CellConfiguration]:\n    \"\"\"Get a state description for this state ID.\n\n    Args:\n        state_id (int): the state to represent in the view\n\n    Returns:\n        StateDescription: the state description\n    \"\"\"\n    normaliser = self.value_normalisation_factory.create_normaliser(\n        state_id\n    )\n    state = self.state_pool.get_state_from_id(state_id)\n    return {\n        cell: self.__cell_configuration(state, normaliser, cell)\n        for cell in self.entities.dynamics.grid_world.list_cells()\n    }\n</code></pre>"},{"location":"reference/model/learning_system/cell_configuration/cell_configuration_factory/#src.model.learning_system.cell_configuration.cell_configuration_factory.CellConfigurationFactory.update_entities","title":"<code>update_entities(entities)</code>","text":"<p>Update the entities used by this decorator.</p> <p>Parameters:</p> Name Type Description Default <code>entities</code> <code>EntityContainer</code> <p>the new entities to use.</p> required Source code in <code>src/model/learning_system/cell_configuration/cell_configuration_factory.py</code> <pre><code>@override\ndef update_entities(self, entities: EntityContainer) -&gt; None:\n    \"\"\"Update the entities used by this decorator.\n\n    Args:\n        entities (EntityContainer): the new entities to use.\n    \"\"\"\n    super().update_entities(entities)\n    self.cell_state_lookup = CellStateLookup(entities.dynamics)\n    self.value_normalisation_factory = NormaliserFactory(\n        entities.agent,\n        entities.dynamics,\n        enable_cache=False,\n    )\n</code></pre>"},{"location":"reference/model/learning_system/cell_configuration/cell_state_lookup/","title":"Cell State Lookup","text":""},{"location":"reference/model/learning_system/cell_configuration/cell_state_lookup/#src.model.learning_system.cell_configuration.cell_state_lookup.CellStateLookup","title":"<code>CellStateLookup</code>","text":"<p>             Bases: <code>object</code></p> <p>This class represents lookup tables for mapping cells to states.</p> Source code in <code>src/model/learning_system/cell_configuration/cell_state_lookup.py</code> <pre><code>class CellStateLookup(object):\n    \"\"\"This class represents lookup tables for mapping cells to states.\"\"\"\n\n    def __init__(self, dynamics: BaseDynamics) -&gt; None:\n        \"\"\"Initialise the class.\n\n        Args:\n            dynamics (BaseDynamics): the dynamics this lookup is based upon.\n        \"\"\"\n        self.dynamics = dynamics\n        self.cell_lookup_table: Optional[lookup_table_type] = None\n\n    def get_state(\n        self, reference_state: StateInstance, cell: Tuple[int, int]\n    ) -&gt; Optional[StateInstance]:\n        \"\"\"Get a state with an agent in a given cell based on the reference.\n\n        Args:\n            reference_state (StateInstance): the base state to compare with\n            cell (Tuple[int, int]): the cell the agent should be in.\n\n        Returns:\n            Optional[StateInstance]: returns the relevant state if one exists.\n        \"\"\"\n        if self.cell_lookup_table is None:\n            self.cell_lookup_table = self.build_lookup_table()\n\n        cell_x, cell_y = cell\n        key = (cell_x, cell_y, reference_state.entities)\n        return self.cell_lookup_table.get(key, None)\n\n    def build_lookup_table(self) -&gt; lookup_table_type:\n        \"\"\"Populate the lookup table.\n\n        Returns:\n            lookup_table_type: the populated lookup table.\n        \"\"\"\n        self.cell_lookup_table = {}\n        for state in self.dynamics.state_pool.id_to_state.values():\n            location_x, location_y = state.agent_location\n            key = (location_x, location_y, state.entities)\n            existing = self.cell_lookup_table.get(key, None)\n            if existing is None:\n                self.cell_lookup_table[key] = state\n\n        return self.cell_lookup_table\n</code></pre>"},{"location":"reference/model/learning_system/cell_configuration/cell_state_lookup/#src.model.learning_system.cell_configuration.cell_state_lookup.CellStateLookup.__init__","title":"<code>__init__(dynamics)</code>","text":"<p>Initialise the class.</p> <p>Parameters:</p> Name Type Description Default <code>dynamics</code> <code>BaseDynamics</code> <p>the dynamics this lookup is based upon.</p> required Source code in <code>src/model/learning_system/cell_configuration/cell_state_lookup.py</code> <pre><code>def __init__(self, dynamics: BaseDynamics) -&gt; None:\n    \"\"\"Initialise the class.\n\n    Args:\n        dynamics (BaseDynamics): the dynamics this lookup is based upon.\n    \"\"\"\n    self.dynamics = dynamics\n    self.cell_lookup_table: Optional[lookup_table_type] = None\n</code></pre>"},{"location":"reference/model/learning_system/cell_configuration/cell_state_lookup/#src.model.learning_system.cell_configuration.cell_state_lookup.CellStateLookup.build_lookup_table","title":"<code>build_lookup_table()</code>","text":"<p>Populate the lookup table.</p> <p>Returns:</p> Name Type Description <code>lookup_table_type</code> <code>lookup_table_type</code> <p>the populated lookup table.</p> Source code in <code>src/model/learning_system/cell_configuration/cell_state_lookup.py</code> <pre><code>def build_lookup_table(self) -&gt; lookup_table_type:\n    \"\"\"Populate the lookup table.\n\n    Returns:\n        lookup_table_type: the populated lookup table.\n    \"\"\"\n    self.cell_lookup_table = {}\n    for state in self.dynamics.state_pool.id_to_state.values():\n        location_x, location_y = state.agent_location\n        key = (location_x, location_y, state.entities)\n        existing = self.cell_lookup_table.get(key, None)\n        if existing is None:\n            self.cell_lookup_table[key] = state\n\n    return self.cell_lookup_table\n</code></pre>"},{"location":"reference/model/learning_system/cell_configuration/cell_state_lookup/#src.model.learning_system.cell_configuration.cell_state_lookup.CellStateLookup.get_state","title":"<code>get_state(reference_state, cell)</code>","text":"<p>Get a state with an agent in a given cell based on the reference.</p> <p>Parameters:</p> Name Type Description Default <code>reference_state</code> <code>StateInstance</code> <p>the base state to compare with</p> required <code>cell</code> <code>Tuple[int, int]</code> <p>the cell the agent should be in.</p> required <p>Returns:</p> Type Description <code>Optional[StateInstance]</code> <p>Optional[StateInstance]: returns the relevant state if one exists.</p> Source code in <code>src/model/learning_system/cell_configuration/cell_state_lookup.py</code> <pre><code>def get_state(\n    self, reference_state: StateInstance, cell: Tuple[int, int]\n) -&gt; Optional[StateInstance]:\n    \"\"\"Get a state with an agent in a given cell based on the reference.\n\n    Args:\n        reference_state (StateInstance): the base state to compare with\n        cell (Tuple[int, int]): the cell the agent should be in.\n\n    Returns:\n        Optional[StateInstance]: returns the relevant state if one exists.\n    \"\"\"\n    if self.cell_lookup_table is None:\n        self.cell_lookup_table = self.build_lookup_table()\n\n    cell_x, cell_y = cell\n    key = (cell_x, cell_y, reference_state.entities)\n    return self.cell_lookup_table.get(key, None)\n</code></pre>"},{"location":"reference/model/learning_system/learning_instance/","title":"Learning Instance","text":"<p>This package contains all the operations performed in learning.</p>"},{"location":"reference/model/learning_system/learning_instance/learning_instance/","title":"Learning Instance","text":""},{"location":"reference/model/learning_system/learning_instance/learning_instance/#src.model.learning_system.learning_instance.learning_instance.LearningInstance","title":"<code>LearningInstance</code>","text":"<p>             Bases: <code>BaseEntityDecorator</code></p> <p>An instance of an agent interacting with the environment.</p> Source code in <code>src/model/learning_system/learning_instance/learning_instance.py</code> <pre><code>class LearningInstance(BaseEntityDecorator):\n    \"\"\"An instance of an agent interacting with the environment.\"\"\"\n\n    def get_current_state(self) -&gt; int:\n        \"\"\"Get the current state ID.\n\n        Returns:\n            int: the current state ID\n        \"\"\"\n        current_state = self.statistics.get_statistics().current_state\n        if current_state is not None:\n            return current_state\n        return self.dynamics.initial_state_id()\n\n    def reset_state(self) -&gt; int:\n        \"\"\"Reset the current state to the initial state.\n\n        Returns:\n            int: the initial state id\n        \"\"\"\n        initial_state_id = self.dynamics.initial_state_id()\n        self.statistics.set_current_state(initial_state_id)\n        return initial_state_id\n\n    def perform_action(\n        self,\n    ) -&gt; TransitionInformation:\n        \"\"\"Perform one action chosen by the agent.\n\n        Returns:\n            TransitionInformation: the transition information, the last\n            state, the action chosen, the next state, the reward received for\n            this action.\n        \"\"\"\n        last_state = self.get_current_state()\n        agent = self.agent\n        action = agent.evaluate_policy(last_state)\n        next_state, reward = self.dynamics.next_state_id(last_state, action)\n\n        transition = TransitionInformation(\n            last_state, action, next_state, reward\n        )\n        agent.record_transition(transition)\n        self.statistics.record_transition(transition)\n        return transition\n</code></pre>"},{"location":"reference/model/learning_system/learning_instance/learning_instance/#src.model.learning_system.learning_instance.learning_instance.LearningInstance.get_current_state","title":"<code>get_current_state()</code>","text":"<p>Get the current state ID.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>the current state ID</p> Source code in <code>src/model/learning_system/learning_instance/learning_instance.py</code> <pre><code>def get_current_state(self) -&gt; int:\n    \"\"\"Get the current state ID.\n\n    Returns:\n        int: the current state ID\n    \"\"\"\n    current_state = self.statistics.get_statistics().current_state\n    if current_state is not None:\n        return current_state\n    return self.dynamics.initial_state_id()\n</code></pre>"},{"location":"reference/model/learning_system/learning_instance/learning_instance/#src.model.learning_system.learning_instance.learning_instance.LearningInstance.perform_action","title":"<code>perform_action()</code>","text":"<p>Perform one action chosen by the agent.</p> <p>Returns:</p> Name Type Description <code>TransitionInformation</code> <code>TransitionInformation</code> <p>the transition information, the last</p> <code>TransitionInformation</code> <p>state, the action chosen, the next state, the reward received for</p> <code>TransitionInformation</code> <p>this action.</p> Source code in <code>src/model/learning_system/learning_instance/learning_instance.py</code> <pre><code>def perform_action(\n    self,\n) -&gt; TransitionInformation:\n    \"\"\"Perform one action chosen by the agent.\n\n    Returns:\n        TransitionInformation: the transition information, the last\n        state, the action chosen, the next state, the reward received for\n        this action.\n    \"\"\"\n    last_state = self.get_current_state()\n    agent = self.agent\n    action = agent.evaluate_policy(last_state)\n    next_state, reward = self.dynamics.next_state_id(last_state, action)\n\n    transition = TransitionInformation(\n        last_state, action, next_state, reward\n    )\n    agent.record_transition(transition)\n    self.statistics.record_transition(transition)\n    return transition\n</code></pre>"},{"location":"reference/model/learning_system/learning_instance/learning_instance/#src.model.learning_system.learning_instance.learning_instance.LearningInstance.reset_state","title":"<code>reset_state()</code>","text":"<p>Reset the current state to the initial state.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>the initial state id</p> Source code in <code>src/model/learning_system/learning_instance/learning_instance.py</code> <pre><code>def reset_state(self) -&gt; int:\n    \"\"\"Reset the current state to the initial state.\n\n    Returns:\n        int: the initial state id\n    \"\"\"\n    initial_state_id = self.dynamics.initial_state_id()\n    self.statistics.set_current_state(initial_state_id)\n    return initial_state_id\n</code></pre>"},{"location":"reference/model/learning_system/learning_instance/statistics_record/","title":"Statistics Record","text":""},{"location":"reference/model/learning_system/learning_instance/statistics_record/#src.model.learning_system.learning_instance.statistics_record.StatisticsRecord","title":"<code>StatisticsRecord</code>  <code>dataclass</code>","text":"<p>             Bases: <code>object</code></p> <p>Class to contain a record of the statistics.</p> Source code in <code>src/model/learning_system/learning_instance/statistics_record.py</code> <pre><code>@dataclass(frozen=True, slots=True)\nclass StatisticsRecord(object):\n    \"\"\"Class to contain a record of the statistics.\"\"\"\n\n    time_step: int\n    reward_history: List[float]\n    total_reward: float\n    current_state: Optional[int] = None\n</code></pre>"},{"location":"reference/model/learning_system/learning_instance/statistics_recorder/","title":"Statistics Recorder","text":""},{"location":"reference/model/learning_system/learning_instance/statistics_recorder/#src.model.learning_system.learning_instance.statistics_recorder.StatisticsRecorder","title":"<code>StatisticsRecorder</code>","text":"<p>             Bases: <code>object</code></p> <p>Class for containing and recording statistics.</p> Source code in <code>src/model/learning_system/learning_instance/statistics_recorder.py</code> <pre><code>class StatisticsRecorder(object):\n    \"\"\"Class for containing and recording statistics.\"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialise the statistics recorder.\"\"\"\n        self.statistics = StatisticsRecord(0, [], 0, None)\n\n    def set_current_state(self, state_id: int) -&gt; None:\n        \"\"\"Set the current state to a specific value.\n\n        Used for resting the state without a traditional transition.\n\n        Args:\n            state_id (int): the new state of the simulation.\n        \"\"\"\n        self.statistics = replace(self.statistics, current_state=state_id)\n\n    def get_statistics(self) -&gt; StatisticsRecord:\n        \"\"\"Get the current statics information.\n\n        Returns:\n            StatisticsRecord: object that represents the statistic information.\n        \"\"\"\n        return self.statistics\n\n    def record_transition(self, transition: TransitionInformation) -&gt; None:\n        \"\"\"Record the information from a transition.\n\n        Args:\n            transition (TransitionInformation) : the transition information.\n        \"\"\"\n        reward = transition.reward\n        stats = self.statistics\n        self.statistics = StatisticsRecord(\n            stats.time_step + 1,\n            [*stats.reward_history, reward],\n            stats.total_reward + reward,\n            transition.new_state,\n        )\n</code></pre>"},{"location":"reference/model/learning_system/learning_instance/statistics_recorder/#src.model.learning_system.learning_instance.statistics_recorder.StatisticsRecorder.__init__","title":"<code>__init__()</code>","text":"<p>Initialise the statistics recorder.</p> Source code in <code>src/model/learning_system/learning_instance/statistics_recorder.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialise the statistics recorder.\"\"\"\n    self.statistics = StatisticsRecord(0, [], 0, None)\n</code></pre>"},{"location":"reference/model/learning_system/learning_instance/statistics_recorder/#src.model.learning_system.learning_instance.statistics_recorder.StatisticsRecorder.get_statistics","title":"<code>get_statistics()</code>","text":"<p>Get the current statics information.</p> <p>Returns:</p> Name Type Description <code>StatisticsRecord</code> <code>StatisticsRecord</code> <p>object that represents the statistic information.</p> Source code in <code>src/model/learning_system/learning_instance/statistics_recorder.py</code> <pre><code>def get_statistics(self) -&gt; StatisticsRecord:\n    \"\"\"Get the current statics information.\n\n    Returns:\n        StatisticsRecord: object that represents the statistic information.\n    \"\"\"\n    return self.statistics\n</code></pre>"},{"location":"reference/model/learning_system/learning_instance/statistics_recorder/#src.model.learning_system.learning_instance.statistics_recorder.StatisticsRecorder.record_transition","title":"<code>record_transition(transition)</code>","text":"<p>Record the information from a transition.</p> <p>Parameters:</p> Name Type Description Default <code>transition</code> <code>TransitionInformation) </code> <p>the transition information.</p> required Source code in <code>src/model/learning_system/learning_instance/statistics_recorder.py</code> <pre><code>def record_transition(self, transition: TransitionInformation) -&gt; None:\n    \"\"\"Record the information from a transition.\n\n    Args:\n        transition (TransitionInformation) : the transition information.\n    \"\"\"\n    reward = transition.reward\n    stats = self.statistics\n    self.statistics = StatisticsRecord(\n        stats.time_step + 1,\n        [*stats.reward_history, reward],\n        stats.total_reward + reward,\n        transition.new_state,\n    )\n</code></pre>"},{"location":"reference/model/learning_system/learning_instance/statistics_recorder/#src.model.learning_system.learning_instance.statistics_recorder.StatisticsRecorder.set_current_state","title":"<code>set_current_state(state_id)</code>","text":"<p>Set the current state to a specific value.</p> <p>Used for resting the state without a traditional transition.</p> <p>Parameters:</p> Name Type Description Default <code>state_id</code> <code>int</code> <p>the new state of the simulation.</p> required Source code in <code>src/model/learning_system/learning_instance/statistics_recorder.py</code> <pre><code>def set_current_state(self, state_id: int) -&gt; None:\n    \"\"\"Set the current state to a specific value.\n\n    Used for resting the state without a traditional transition.\n\n    Args:\n        state_id (int): the new state of the simulation.\n    \"\"\"\n    self.statistics = replace(self.statistics, current_state=state_id)\n</code></pre>"},{"location":"reference/model/learning_system/state_description/","title":"State Description","text":"<p>This package contains functionality around representing a state.</p> <p>This representation is necessary for the view so the format must be serialisable</p>"},{"location":"reference/model/learning_system/state_description/state_description/","title":"State Description","text":""},{"location":"reference/model/learning_system/state_description/state_description/#src.model.learning_system.state_description.state_description.StateDescription","title":"<code>StateDescription</code>  <code>dataclass</code>","text":"<p>             Bases: <code>object</code></p> <p>Compile together the dynamic and static state information.</p> <p>Provides all of the state information in a picklable object for the view.</p> Source code in <code>src/model/learning_system/state_description/state_description.py</code> <pre><code>@dataclass\nclass StateDescription(object):\n    \"\"\"Compile together the dynamic and static state information.\n\n    Provides all of the state information in a picklable object for the view.\n    \"\"\"\n\n    grid_world: GridWorld\n    state: StateInstance\n    cell_config: cell_config_listing\n    global_options: GlobalOptions\n    statistics: StatisticsRecord\n</code></pre>"},{"location":"reference/model/learning_system/state_description/state_description_factory/","title":"State Description Factory","text":""},{"location":"reference/model/learning_system/state_description/state_description_factory/#src.model.learning_system.state_description.state_description_factory.StateDescriptionFactory","title":"<code>StateDescriptionFactory</code>","text":"<p>             Bases: <code>BaseEntityDecorator</code></p> <p>Factory class for creating state descriptions from states.</p> Source code in <code>src/model/learning_system/state_description/state_description_factory.py</code> <pre><code>class StateDescriptionFactory(BaseEntityDecorator):\n    \"\"\"Factory class for creating state descriptions from states.\"\"\"\n\n    def __init__(\n        self,\n        entities: EntityContainer,\n        global_options: GlobalOptions,\n    ) -&gt; None:\n        \"\"\"Create a state description factory for these entities.\n\n        Args:\n            entities (EntityContainer): The entities this class uses\n                internally.\n            global_options (GlobalOptions): The initial global options for the\n                description.\n        \"\"\"\n        super().__init__(entities)\n        self.cell_configuration_factory = CellConfigurationFactory(entities)\n        self.global_options = global_options\n\n    @override\n    def update_entities(self, entities: EntityContainer) -&gt; None:\n        \"\"\"Update the entities used by this decorator.\n\n        Args:\n            entities (EntityContainer): the new entities to use.\n        \"\"\"\n        super().update_entities(entities)\n        self.cell_configuration_factory.update_entities(entities)\n\n    def update_options(self, options: GlobalOptions):\n        \"\"\"Update the options used in the state descriptions.\n\n        Args:\n            options (GlobalOptions): the new options.\n        \"\"\"\n        self.global_options = options\n\n    def create_state_description(self, state_id: int) -&gt; StateDescription:\n        \"\"\"Create a new state description from a given state ID.\n\n        Args:\n            state_id (int): the state to describe for the UI.\n\n        Returns:\n            StateDescription: All of the details of the state for the UI.\n        \"\"\"\n        return StateDescription(\n            self.grid_world,\n            self.state_pool.get_state_from_id(state_id),\n            self.cell_configuration_factory.get_cell_configuration(state_id),\n            self.global_options,\n            self.statistics.get_statistics(),\n        )\n</code></pre>"},{"location":"reference/model/learning_system/state_description/state_description_factory/#src.model.learning_system.state_description.state_description_factory.StateDescriptionFactory.__init__","title":"<code>__init__(entities, global_options)</code>","text":"<p>Create a state description factory for these entities.</p> <p>Parameters:</p> Name Type Description Default <code>entities</code> <code>EntityContainer</code> <p>The entities this class uses internally.</p> required <code>global_options</code> <code>GlobalOptions</code> <p>The initial global options for the description.</p> required Source code in <code>src/model/learning_system/state_description/state_description_factory.py</code> <pre><code>def __init__(\n    self,\n    entities: EntityContainer,\n    global_options: GlobalOptions,\n) -&gt; None:\n    \"\"\"Create a state description factory for these entities.\n\n    Args:\n        entities (EntityContainer): The entities this class uses\n            internally.\n        global_options (GlobalOptions): The initial global options for the\n            description.\n    \"\"\"\n    super().__init__(entities)\n    self.cell_configuration_factory = CellConfigurationFactory(entities)\n    self.global_options = global_options\n</code></pre>"},{"location":"reference/model/learning_system/state_description/state_description_factory/#src.model.learning_system.state_description.state_description_factory.StateDescriptionFactory.create_state_description","title":"<code>create_state_description(state_id)</code>","text":"<p>Create a new state description from a given state ID.</p> <p>Parameters:</p> Name Type Description Default <code>state_id</code> <code>int</code> <p>the state to describe for the UI.</p> required <p>Returns:</p> Name Type Description <code>StateDescription</code> <code>StateDescription</code> <p>All of the details of the state for the UI.</p> Source code in <code>src/model/learning_system/state_description/state_description_factory.py</code> <pre><code>def create_state_description(self, state_id: int) -&gt; StateDescription:\n    \"\"\"Create a new state description from a given state ID.\n\n    Args:\n        state_id (int): the state to describe for the UI.\n\n    Returns:\n        StateDescription: All of the details of the state for the UI.\n    \"\"\"\n    return StateDescription(\n        self.grid_world,\n        self.state_pool.get_state_from_id(state_id),\n        self.cell_configuration_factory.get_cell_configuration(state_id),\n        self.global_options,\n        self.statistics.get_statistics(),\n    )\n</code></pre>"},{"location":"reference/model/learning_system/state_description/state_description_factory/#src.model.learning_system.state_description.state_description_factory.StateDescriptionFactory.update_entities","title":"<code>update_entities(entities)</code>","text":"<p>Update the entities used by this decorator.</p> <p>Parameters:</p> Name Type Description Default <code>entities</code> <code>EntityContainer</code> <p>the new entities to use.</p> required Source code in <code>src/model/learning_system/state_description/state_description_factory.py</code> <pre><code>@override\ndef update_entities(self, entities: EntityContainer) -&gt; None:\n    \"\"\"Update the entities used by this decorator.\n\n    Args:\n        entities (EntityContainer): the new entities to use.\n    \"\"\"\n    super().update_entities(entities)\n    self.cell_configuration_factory.update_entities(entities)\n</code></pre>"},{"location":"reference/model/learning_system/state_description/state_description_factory/#src.model.learning_system.state_description.state_description_factory.StateDescriptionFactory.update_options","title":"<code>update_options(options)</code>","text":"<p>Update the options used in the state descriptions.</p> <p>Parameters:</p> Name Type Description Default <code>options</code> <code>GlobalOptions</code> <p>the new options.</p> required Source code in <code>src/model/learning_system/state_description/state_description_factory.py</code> <pre><code>def update_options(self, options: GlobalOptions):\n    \"\"\"Update the options used in the state descriptions.\n\n    Args:\n        options (GlobalOptions): the new options.\n    \"\"\"\n    self.global_options = options\n</code></pre>"},{"location":"reference/model/learning_system/top_level_entities/","title":"Top Level Entities","text":"<p>Package for managing the top entities in reinforcement learning.</p>"},{"location":"reference/model/learning_system/top_level_entities/cache/","title":"Cache","text":""},{"location":"reference/model/learning_system/top_level_entities/cache/#src.model.learning_system.top_level_entities.cache.TopEntitiesCache","title":"<code>TopEntitiesCache</code>","text":"<p>             Bases: <code>object</code></p> <p>Cache for top level entities keeping consistency.</p> Source code in <code>src/model/learning_system/top_level_entities/cache.py</code> <pre><code>class TopEntitiesCache(object):\n    \"\"\"Cache for top level entities keeping consistency.\"\"\"\n\n    cache: Dict[TopEntitiesOptions, EntityContainer] = {}\n\n    def get_entities(self, options: TopEntitiesOptions) -&gt; EntityContainer:\n        \"\"\"Get top level entities from specified options.\n\n        If a cached option exists this will be returned.\n\n        Args:\n            options (TopEntitiesOptions): the options that specify how the top\n                level entities should be.\n\n        Returns:\n            EntityContainer: The entities based upon the options.\n        \"\"\"\n        entities = self.cache.get(options, None)\n\n        if entities is not None:\n            return entities\n        return self.create_new_entities(options)\n\n    def create_new_entities(\n        self, options: TopEntitiesOptions\n    ) -&gt; EntityContainer:\n        \"\"\"Get top level entities from specified options.\n\n        This circumvents the cache and updates its value.\n\n        Args:\n            options (TopEntitiesOptions): the options that specify how the top\n                level entities should be.\n\n        Returns:\n            EntityContainer: The entities based upon the options.\n        \"\"\"\n        hyper_parameters = ParameterConfigStrategy()\n        entities = EntityFactory.create_entities(options, hyper_parameters)\n        self.cache[options] = entities\n        return entities\n</code></pre>"},{"location":"reference/model/learning_system/top_level_entities/cache/#src.model.learning_system.top_level_entities.cache.TopEntitiesCache.create_new_entities","title":"<code>create_new_entities(options)</code>","text":"<p>Get top level entities from specified options.</p> <p>This circumvents the cache and updates its value.</p> <p>Parameters:</p> Name Type Description Default <code>options</code> <code>TopEntitiesOptions</code> <p>the options that specify how the top level entities should be.</p> required <p>Returns:</p> Name Type Description <code>EntityContainer</code> <code>EntityContainer</code> <p>The entities based upon the options.</p> Source code in <code>src/model/learning_system/top_level_entities/cache.py</code> <pre><code>def create_new_entities(\n    self, options: TopEntitiesOptions\n) -&gt; EntityContainer:\n    \"\"\"Get top level entities from specified options.\n\n    This circumvents the cache and updates its value.\n\n    Args:\n        options (TopEntitiesOptions): the options that specify how the top\n            level entities should be.\n\n    Returns:\n        EntityContainer: The entities based upon the options.\n    \"\"\"\n    hyper_parameters = ParameterConfigStrategy()\n    entities = EntityFactory.create_entities(options, hyper_parameters)\n    self.cache[options] = entities\n    return entities\n</code></pre>"},{"location":"reference/model/learning_system/top_level_entities/cache/#src.model.learning_system.top_level_entities.cache.TopEntitiesCache.get_entities","title":"<code>get_entities(options)</code>","text":"<p>Get top level entities from specified options.</p> <p>If a cached option exists this will be returned.</p> <p>Parameters:</p> Name Type Description Default <code>options</code> <code>TopEntitiesOptions</code> <p>the options that specify how the top level entities should be.</p> required <p>Returns:</p> Name Type Description <code>EntityContainer</code> <code>EntityContainer</code> <p>The entities based upon the options.</p> Source code in <code>src/model/learning_system/top_level_entities/cache.py</code> <pre><code>def get_entities(self, options: TopEntitiesOptions) -&gt; EntityContainer:\n    \"\"\"Get top level entities from specified options.\n\n    If a cached option exists this will be returned.\n\n    Args:\n        options (TopEntitiesOptions): the options that specify how the top\n            level entities should be.\n\n    Returns:\n        EntityContainer: The entities based upon the options.\n    \"\"\"\n    entities = self.cache.get(options, None)\n\n    if entities is not None:\n        return entities\n    return self.create_new_entities(options)\n</code></pre>"},{"location":"reference/model/learning_system/top_level_entities/container/","title":"Container","text":""},{"location":"reference/model/learning_system/top_level_entities/container/#src.model.learning_system.top_level_entities.container.EntityContainer","title":"<code>EntityContainer</code>  <code>dataclass</code>","text":"<p>             Bases: <code>object</code></p> <p>Class that encompasses the top level entities of the learning system.</p> Source code in <code>src/model/learning_system/top_level_entities/container.py</code> <pre><code>@dataclass(frozen=True, slots=True)\nclass EntityContainer(object):\n    \"\"\"Class that encompasses the top level entities of the learning system.\"\"\"\n\n    agent: BaseAgent\n    dynamics: BaseDynamics\n    statistics: StatisticsRecorder\n    options: TopEntitiesOptions\n</code></pre>"},{"location":"reference/model/learning_system/top_level_entities/factory/","title":"Factory","text":""},{"location":"reference/model/learning_system/top_level_entities/factory/#src.model.learning_system.top_level_entities.factory.EntityFactory","title":"<code>EntityFactory</code>","text":"<p>             Bases: <code>object</code></p> <p>Factory class for creating entities from the given options.</p> Source code in <code>src/model/learning_system/top_level_entities/factory.py</code> <pre><code>class EntityFactory(object):\n    \"\"\"Factory class for creating entities from the given options.\"\"\"\n\n    @classmethod\n    def create_entities(\n        cls,\n        options: TopEntitiesOptions,\n        hyper_parameters: BaseHyperParameterStrategy,\n    ) -&gt; EntityContainer:\n        \"\"\"Create new entities from the given options.\n\n        Args:\n            options (TopEntitiesOptions): the options that describe which\n                entities to create.\n            hyper_parameters (BaseHyperParameterStrategy): the parameters for\n                these entities.\n\n        Returns:\n            EntityContainer: The new entities.\n        \"\"\"\n        dynamics = cls.create_dynamics(options)\n        agent = cls.create_agent(options, hyper_parameters, dynamics)\n        stats = StatisticsRecorder()\n        return EntityContainer(agent, dynamics, stats, options)\n\n    @classmethod\n    def create_agent(\n        cls,\n        options: TopEntitiesOptions,\n        hyper_parameters: BaseHyperParameterStrategy,\n        dynamics: BaseDynamics,\n    ) -&gt; BaseAgent:\n        \"\"\"Create the agent based upon these options.\n\n        Args:\n            options (TopEntitiesOptions): the options that describe what agent\n                to create.\n            hyper_parameters (BaseHyperParameterStrategy): the hyper parameters\n                the agent should use.\n            dynamics (BaseDynamics): the dynamics that are used by the value\n                iteration agent.\n\n        Raises:\n            ValueError: if the agent specified is not known\n\n        Returns:\n            BaseAgent: the agent to instance. this agent is to be used with the\n            dynamics provided to avoid inconsistencies.\n        \"\"\"\n        match options.agent:\n            case AgentOptions.value_iteration:\n                return ValueIterationAgent(hyper_parameters, dynamics)\n            case AgentOptions.value_iteration_optimised:\n                return ValueIterationAgentOptimised(hyper_parameters, dynamics)\n            case AgentOptions.q_learning:\n                return QLearningAgent(\n                    hyper_parameters,\n                    options.exploration_strategy,\n                    dynamics.state_count_upper_bound(),\n                )\n            case _:\n                raise ValueError(f\"unknown agent {options.agent.name}\")\n\n    @classmethod\n    def create_dynamics(cls, options: TopEntitiesOptions) -&gt; BaseDynamics:\n        \"\"\"Create the dynamics appropriate for these options.\n\n        Args:\n            options (TopEntitiesOptions): the options that describe what\n                dynamics to create.\n\n        Raises:\n            ValueError: if the dynamics option specified is unknown.\n\n        Returns:\n            BaseDynamics: the dynamics instance, the returned class will be a\n            concrete instance that extends `BaseDynamics`\n        \"\"\"\n        dynamic_config = ConfigReader().grid_world\n        match options.dynamics:\n            case DynamicsOptions.collection:\n                return CollectionDynamics(dynamic_config)\n            case DynamicsOptions.cliff:\n                return CliffDynamics(dynamic_config)\n            case _:\n                raise ValueError(f\"unknown dynamics {options.dynamics.name}\")\n</code></pre>"},{"location":"reference/model/learning_system/top_level_entities/factory/#src.model.learning_system.top_level_entities.factory.EntityFactory.create_agent","title":"<code>create_agent(options, hyper_parameters, dynamics)</code>  <code>classmethod</code>","text":"<p>Create the agent based upon these options.</p> <p>Parameters:</p> Name Type Description Default <code>options</code> <code>TopEntitiesOptions</code> <p>the options that describe what agent to create.</p> required <code>hyper_parameters</code> <code>BaseHyperParameterStrategy</code> <p>the hyper parameters the agent should use.</p> required <code>dynamics</code> <code>BaseDynamics</code> <p>the dynamics that are used by the value iteration agent.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>if the agent specified is not known</p> <p>Returns:</p> Name Type Description <code>BaseAgent</code> <code>BaseAgent</code> <p>the agent to instance. this agent is to be used with the</p> <code>BaseAgent</code> <p>dynamics provided to avoid inconsistencies.</p> Source code in <code>src/model/learning_system/top_level_entities/factory.py</code> <pre><code>@classmethod\ndef create_agent(\n    cls,\n    options: TopEntitiesOptions,\n    hyper_parameters: BaseHyperParameterStrategy,\n    dynamics: BaseDynamics,\n) -&gt; BaseAgent:\n    \"\"\"Create the agent based upon these options.\n\n    Args:\n        options (TopEntitiesOptions): the options that describe what agent\n            to create.\n        hyper_parameters (BaseHyperParameterStrategy): the hyper parameters\n            the agent should use.\n        dynamics (BaseDynamics): the dynamics that are used by the value\n            iteration agent.\n\n    Raises:\n        ValueError: if the agent specified is not known\n\n    Returns:\n        BaseAgent: the agent to instance. this agent is to be used with the\n        dynamics provided to avoid inconsistencies.\n    \"\"\"\n    match options.agent:\n        case AgentOptions.value_iteration:\n            return ValueIterationAgent(hyper_parameters, dynamics)\n        case AgentOptions.value_iteration_optimised:\n            return ValueIterationAgentOptimised(hyper_parameters, dynamics)\n        case AgentOptions.q_learning:\n            return QLearningAgent(\n                hyper_parameters,\n                options.exploration_strategy,\n                dynamics.state_count_upper_bound(),\n            )\n        case _:\n            raise ValueError(f\"unknown agent {options.agent.name}\")\n</code></pre>"},{"location":"reference/model/learning_system/top_level_entities/factory/#src.model.learning_system.top_level_entities.factory.EntityFactory.create_dynamics","title":"<code>create_dynamics(options)</code>  <code>classmethod</code>","text":"<p>Create the dynamics appropriate for these options.</p> <p>Parameters:</p> Name Type Description Default <code>options</code> <code>TopEntitiesOptions</code> <p>the options that describe what dynamics to create.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>if the dynamics option specified is unknown.</p> <p>Returns:</p> Name Type Description <code>BaseDynamics</code> <code>BaseDynamics</code> <p>the dynamics instance, the returned class will be a</p> <code>BaseDynamics</code> <p>concrete instance that extends <code>BaseDynamics</code></p> Source code in <code>src/model/learning_system/top_level_entities/factory.py</code> <pre><code>@classmethod\ndef create_dynamics(cls, options: TopEntitiesOptions) -&gt; BaseDynamics:\n    \"\"\"Create the dynamics appropriate for these options.\n\n    Args:\n        options (TopEntitiesOptions): the options that describe what\n            dynamics to create.\n\n    Raises:\n        ValueError: if the dynamics option specified is unknown.\n\n    Returns:\n        BaseDynamics: the dynamics instance, the returned class will be a\n        concrete instance that extends `BaseDynamics`\n    \"\"\"\n    dynamic_config = ConfigReader().grid_world\n    match options.dynamics:\n        case DynamicsOptions.collection:\n            return CollectionDynamics(dynamic_config)\n        case DynamicsOptions.cliff:\n            return CliffDynamics(dynamic_config)\n        case _:\n            raise ValueError(f\"unknown dynamics {options.dynamics.name}\")\n</code></pre>"},{"location":"reference/model/learning_system/top_level_entities/factory/#src.model.learning_system.top_level_entities.factory.EntityFactory.create_entities","title":"<code>create_entities(options, hyper_parameters)</code>  <code>classmethod</code>","text":"<p>Create new entities from the given options.</p> <p>Parameters:</p> Name Type Description Default <code>options</code> <code>TopEntitiesOptions</code> <p>the options that describe which entities to create.</p> required <code>hyper_parameters</code> <code>BaseHyperParameterStrategy</code> <p>the parameters for these entities.</p> required <p>Returns:</p> Name Type Description <code>EntityContainer</code> <code>EntityContainer</code> <p>The new entities.</p> Source code in <code>src/model/learning_system/top_level_entities/factory.py</code> <pre><code>@classmethod\ndef create_entities(\n    cls,\n    options: TopEntitiesOptions,\n    hyper_parameters: BaseHyperParameterStrategy,\n) -&gt; EntityContainer:\n    \"\"\"Create new entities from the given options.\n\n    Args:\n        options (TopEntitiesOptions): the options that describe which\n            entities to create.\n        hyper_parameters (BaseHyperParameterStrategy): the parameters for\n            these entities.\n\n    Returns:\n        EntityContainer: The new entities.\n    \"\"\"\n    dynamics = cls.create_dynamics(options)\n    agent = cls.create_agent(options, hyper_parameters, dynamics)\n    stats = StatisticsRecorder()\n    return EntityContainer(agent, dynamics, stats, options)\n</code></pre>"},{"location":"reference/model/learning_system/top_level_entities/options/","title":"Options","text":""},{"location":"reference/model/learning_system/top_level_entities/options/#src.model.learning_system.top_level_entities.options.AgentOptions","title":"<code>AgentOptions</code>","text":"<p>             Bases: <code>Enum</code></p> <p>Enumerates the possible agents.</p> Source code in <code>src/model/learning_system/top_level_entities/options.py</code> <pre><code>class AgentOptions(Enum):\n    \"\"\"Enumerates the possible agents.\"\"\"\n\n    value_iteration_optimised = 1\n    value_iteration = 2\n    q_learning = 3\n</code></pre>"},{"location":"reference/model/learning_system/top_level_entities/options/#src.model.learning_system.top_level_entities.options.DynamicsOptions","title":"<code>DynamicsOptions</code>","text":"<p>             Bases: <code>Enum</code></p> <p>Enumerates the possible agents.</p> Source code in <code>src/model/learning_system/top_level_entities/options.py</code> <pre><code>class DynamicsOptions(Enum):\n    \"\"\"Enumerates the possible agents.\"\"\"\n\n    collection = 1\n    cliff = 2\n</code></pre>"},{"location":"reference/model/learning_system/top_level_entities/options/#src.model.learning_system.top_level_entities.options.TopEntitiesOptions","title":"<code>TopEntitiesOptions</code>  <code>dataclass</code>","text":"<p>             Bases: <code>object</code></p> <p>Class that represents the options for the top level entities.</p> Source code in <code>src/model/learning_system/top_level_entities/options.py</code> <pre><code>@dataclass(frozen=True, slots=True)\nclass TopEntitiesOptions(object):\n    \"\"\"Class that represents the options for the top level entities.\"\"\"\n\n    agent: AgentOptions\n    dynamics: DynamicsOptions\n    exploration_strategy: ExplorationStrategyOptions\n</code></pre>"},{"location":"reference/model/learning_system/value_standardisation/","title":"Value Standardisation","text":"<p>Package for managing the value at different states for visualisation.</p>"},{"location":"reference/model/learning_system/value_standardisation/normaliser/","title":"Normaliser","text":""},{"location":"reference/model/learning_system/value_standardisation/normaliser/#src.model.learning_system.value_standardisation.normaliser.StateValueNormaliser","title":"<code>StateValueNormaliser</code>","text":"<p>             Bases: <code>object</code></p> <p>Compute the normalised value of an agent being in a state.</p> Source code in <code>src/model/learning_system/value_standardisation/normaliser.py</code> <pre><code>class StateValueNormaliser(object):\n    \"\"\"Compute the normalised value of an agent being in a state.\"\"\"\n\n    def __init__(\n        self,\n        agent: BaseAgent,\n        state_pool: StatePool,\n        value_range: ValueRange,\n    ) -&gt; None:\n        \"\"\"Initialise the normaliser.\n\n        this class will normalise the values between 0 and 1.\n\n\n        Args:\n            agent (BaseAgent): the agent to decide the value.\n            state_pool (StatePool): a state pool with all possible states.\n            value_range (ValueRange): the range of possible values for this\n                agent and dynamics\n        \"\"\"\n        self.agent = agent\n        self.state_pool = state_pool\n        self.value_range = value_range\n        self.state_value_cache: Dict[StateInstance, float] = {}\n        self.action_value_cache: Dict[action_value_tuple, float] = {}\n\n    def get_state_action_value_normalised(\n        self,\n        state: StateInstance,\n        action: Action,\n    ) -&gt; float:\n        \"\"\"Get the normalised value of a state and action.\n\n        Args:\n            state (StateInstance): the state to check.\n            action (Action): the action to check.\n\n        Returns:\n            float: the value if one can be found.\n        \"\"\"\n        cache_key = (state, action)\n        cached_value = self.action_value_cache.get(cache_key, None)\n        if cached_value is not None:\n            return cached_value\n\n        action_value = self.value_range.rescale_value(\n            ValueType.state_action_value,\n            self.agent.get_state_action_value(\n                self.state_pool.get_state_id(state), action\n            ),\n        )\n        self.action_value_cache[cache_key] = action_value\n        return action_value\n\n    def get_state_value_normalised(self, state: StateInstance) -&gt; float:\n        \"\"\"Get the normalised value of this state.\n\n        Args:\n            state (StateInstance): the state to check.\n\n        Returns:\n            float: the value of the state normalised.\n        \"\"\"\n        cached_value = self.state_value_cache.get(state, None)\n        if cached_value is not None:\n            return cached_value\n\n        state_value = self.value_range.rescale_value(\n            ValueType.state_value,\n            self.agent.get_state_value(self.state_pool.get_state_id(state)),\n        )\n        self.state_value_cache[state] = state_value\n\n        return state_value\n</code></pre>"},{"location":"reference/model/learning_system/value_standardisation/normaliser/#src.model.learning_system.value_standardisation.normaliser.StateValueNormaliser.__init__","title":"<code>__init__(agent, state_pool, value_range)</code>","text":"<p>Initialise the normaliser.</p> <p>this class will normalise the values between 0 and 1.</p> <p>Parameters:</p> Name Type Description Default <code>agent</code> <code>BaseAgent</code> <p>the agent to decide the value.</p> required <code>state_pool</code> <code>StatePool</code> <p>a state pool with all possible states.</p> required <code>value_range</code> <code>ValueRange</code> <p>the range of possible values for this agent and dynamics</p> required Source code in <code>src/model/learning_system/value_standardisation/normaliser.py</code> <pre><code>def __init__(\n    self,\n    agent: BaseAgent,\n    state_pool: StatePool,\n    value_range: ValueRange,\n) -&gt; None:\n    \"\"\"Initialise the normaliser.\n\n    this class will normalise the values between 0 and 1.\n\n\n    Args:\n        agent (BaseAgent): the agent to decide the value.\n        state_pool (StatePool): a state pool with all possible states.\n        value_range (ValueRange): the range of possible values for this\n            agent and dynamics\n    \"\"\"\n    self.agent = agent\n    self.state_pool = state_pool\n    self.value_range = value_range\n    self.state_value_cache: Dict[StateInstance, float] = {}\n    self.action_value_cache: Dict[action_value_tuple, float] = {}\n</code></pre>"},{"location":"reference/model/learning_system/value_standardisation/normaliser/#src.model.learning_system.value_standardisation.normaliser.StateValueNormaliser.get_state_action_value_normalised","title":"<code>get_state_action_value_normalised(state, action)</code>","text":"<p>Get the normalised value of a state and action.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>StateInstance</code> <p>the state to check.</p> required <code>action</code> <code>Action</code> <p>the action to check.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the value if one can be found.</p> Source code in <code>src/model/learning_system/value_standardisation/normaliser.py</code> <pre><code>def get_state_action_value_normalised(\n    self,\n    state: StateInstance,\n    action: Action,\n) -&gt; float:\n    \"\"\"Get the normalised value of a state and action.\n\n    Args:\n        state (StateInstance): the state to check.\n        action (Action): the action to check.\n\n    Returns:\n        float: the value if one can be found.\n    \"\"\"\n    cache_key = (state, action)\n    cached_value = self.action_value_cache.get(cache_key, None)\n    if cached_value is not None:\n        return cached_value\n\n    action_value = self.value_range.rescale_value(\n        ValueType.state_action_value,\n        self.agent.get_state_action_value(\n            self.state_pool.get_state_id(state), action\n        ),\n    )\n    self.action_value_cache[cache_key] = action_value\n    return action_value\n</code></pre>"},{"location":"reference/model/learning_system/value_standardisation/normaliser/#src.model.learning_system.value_standardisation.normaliser.StateValueNormaliser.get_state_value_normalised","title":"<code>get_state_value_normalised(state)</code>","text":"<p>Get the normalised value of this state.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>StateInstance</code> <p>the state to check.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the value of the state normalised.</p> Source code in <code>src/model/learning_system/value_standardisation/normaliser.py</code> <pre><code>def get_state_value_normalised(self, state: StateInstance) -&gt; float:\n    \"\"\"Get the normalised value of this state.\n\n    Args:\n        state (StateInstance): the state to check.\n\n    Returns:\n        float: the value of the state normalised.\n    \"\"\"\n    cached_value = self.state_value_cache.get(state, None)\n    if cached_value is not None:\n        return cached_value\n\n    state_value = self.value_range.rescale_value(\n        ValueType.state_value,\n        self.agent.get_state_value(self.state_pool.get_state_id(state)),\n    )\n    self.state_value_cache[state] = state_value\n\n    return state_value\n</code></pre>"},{"location":"reference/model/learning_system/value_standardisation/normaliser_factory/","title":"Normaliser Factory","text":""},{"location":"reference/model/learning_system/value_standardisation/normaliser_factory/#src.model.learning_system.value_standardisation.normaliser_factory.NormaliserFactory","title":"<code>NormaliserFactory</code>","text":"<p>             Bases: <code>object</code></p> <p>Factory class for creating value normalisers.</p> Source code in <code>src/model/learning_system/value_standardisation/normaliser_factory.py</code> <pre><code>class NormaliserFactory(object):\n    \"\"\"Factory class for creating value normalisers.\"\"\"\n\n    def __init__(\n        self, agent: BaseAgent, dynamics: BaseDynamics, enable_cache: bool\n    ) -&gt; None:\n        \"\"\"Initialise the normaliser factory.\n\n        This factory creates normalisers and caches equivalent ones to avoid\n        re-computation\n\n        Args:\n            agent (BaseAgent): the agent to generate normalisers for\n            dynamics (BaseDynamics): the dynamics to generate normalisers for\n            enable_cache: weather the cache can be enabled (if the value table\n                changes like for q-learning then caching must be disabled)\n        \"\"\"\n        self.agent = agent\n        self.dynamics = dynamics\n        self.has_generated_all_states: bool = False\n        self.cache: Dict[entities_type, StateValueNormaliser] = {}\n        self.value_range: Optional[ValueRange] = None\n        self.enable_cache = enable_cache\n\n    def create_normaliser(self, base_state: int) -&gt; StateValueNormaliser:\n        \"\"\"Get the appropriate state normaliser for the given base state.\n\n        Args:\n            base_state (int): the state the defines the possible entities that\n                the normaliser should consider.\n\n        Returns:\n            StateValueNormaliser: _description_\n        \"\"\"\n        entities = self.dynamics.state_pool.get_state_from_id(\n            base_state\n        ).entities\n\n        if self.enable_cache:\n            cached_version = self.cache.get(entities, None)\n            if cached_version is not None:\n                return cached_version\n\n        normaliser = StateValueNormaliser(\n            self.agent,\n            self.__get_state_pool(),\n            self.__get_value_range(),\n        )\n        self.cache[entities] = normaliser\n        return normaliser\n\n    def __get_state_pool(self) -&gt; StatePool:\n        \"\"\"Get a fully populated state pool.\n\n        Returns:\n            StatePool: the pool of all possible reachable states\n        \"\"\"\n        if self.has_generated_all_states:\n            return self.dynamics.state_pool\n        # use the dynamics distribution code to ensure all states are visited\n        dd = DynamicsDistribution(100, self.dynamics)\n        dd.compile()\n        self.has_generated_all_states = True\n        return self.dynamics.state_pool\n\n    def __get_value_range(self) -&gt; ValueRange:\n        \"\"\"Get the value range for this given dynamics and agent.\n\n        Returns:\n            ValueRange: the range of values to provide a consistent scale\n        \"\"\"\n        if self.value_range is not None and self.enable_cache:\n            return self.value_range\n\n        self.value_range = ValueRange(self.__get_state_pool(), self.agent)\n        return self.value_range\n</code></pre>"},{"location":"reference/model/learning_system/value_standardisation/normaliser_factory/#src.model.learning_system.value_standardisation.normaliser_factory.NormaliserFactory.__get_state_pool","title":"<code>__get_state_pool()</code>","text":"<p>Get a fully populated state pool.</p> <p>Returns:</p> Name Type Description <code>StatePool</code> <code>StatePool</code> <p>the pool of all possible reachable states</p> Source code in <code>src/model/learning_system/value_standardisation/normaliser_factory.py</code> <pre><code>def __get_state_pool(self) -&gt; StatePool:\n    \"\"\"Get a fully populated state pool.\n\n    Returns:\n        StatePool: the pool of all possible reachable states\n    \"\"\"\n    if self.has_generated_all_states:\n        return self.dynamics.state_pool\n    # use the dynamics distribution code to ensure all states are visited\n    dd = DynamicsDistribution(100, self.dynamics)\n    dd.compile()\n    self.has_generated_all_states = True\n    return self.dynamics.state_pool\n</code></pre>"},{"location":"reference/model/learning_system/value_standardisation/normaliser_factory/#src.model.learning_system.value_standardisation.normaliser_factory.NormaliserFactory.__get_value_range","title":"<code>__get_value_range()</code>","text":"<p>Get the value range for this given dynamics and agent.</p> <p>Returns:</p> Name Type Description <code>ValueRange</code> <code>ValueRange</code> <p>the range of values to provide a consistent scale</p> Source code in <code>src/model/learning_system/value_standardisation/normaliser_factory.py</code> <pre><code>def __get_value_range(self) -&gt; ValueRange:\n    \"\"\"Get the value range for this given dynamics and agent.\n\n    Returns:\n        ValueRange: the range of values to provide a consistent scale\n    \"\"\"\n    if self.value_range is not None and self.enable_cache:\n        return self.value_range\n\n    self.value_range = ValueRange(self.__get_state_pool(), self.agent)\n    return self.value_range\n</code></pre>"},{"location":"reference/model/learning_system/value_standardisation/normaliser_factory/#src.model.learning_system.value_standardisation.normaliser_factory.NormaliserFactory.__init__","title":"<code>__init__(agent, dynamics, enable_cache)</code>","text":"<p>Initialise the normaliser factory.</p> <p>This factory creates normalisers and caches equivalent ones to avoid re-computation</p> <p>Parameters:</p> Name Type Description Default <code>agent</code> <code>BaseAgent</code> <p>the agent to generate normalisers for</p> required <code>dynamics</code> <code>BaseDynamics</code> <p>the dynamics to generate normalisers for</p> required <code>enable_cache</code> <code>bool</code> <p>weather the cache can be enabled (if the value table changes like for q-learning then caching must be disabled)</p> required Source code in <code>src/model/learning_system/value_standardisation/normaliser_factory.py</code> <pre><code>def __init__(\n    self, agent: BaseAgent, dynamics: BaseDynamics, enable_cache: bool\n) -&gt; None:\n    \"\"\"Initialise the normaliser factory.\n\n    This factory creates normalisers and caches equivalent ones to avoid\n    re-computation\n\n    Args:\n        agent (BaseAgent): the agent to generate normalisers for\n        dynamics (BaseDynamics): the dynamics to generate normalisers for\n        enable_cache: weather the cache can be enabled (if the value table\n            changes like for q-learning then caching must be disabled)\n    \"\"\"\n    self.agent = agent\n    self.dynamics = dynamics\n    self.has_generated_all_states: bool = False\n    self.cache: Dict[entities_type, StateValueNormaliser] = {}\n    self.value_range: Optional[ValueRange] = None\n    self.enable_cache = enable_cache\n</code></pre>"},{"location":"reference/model/learning_system/value_standardisation/normaliser_factory/#src.model.learning_system.value_standardisation.normaliser_factory.NormaliserFactory.create_normaliser","title":"<code>create_normaliser(base_state)</code>","text":"<p>Get the appropriate state normaliser for the given base state.</p> <p>Parameters:</p> Name Type Description Default <code>base_state</code> <code>int</code> <p>the state the defines the possible entities that the normaliser should consider.</p> required <p>Returns:</p> Name Type Description <code>StateValueNormaliser</code> <code>StateValueNormaliser</code> <p>description</p> Source code in <code>src/model/learning_system/value_standardisation/normaliser_factory.py</code> <pre><code>def create_normaliser(self, base_state: int) -&gt; StateValueNormaliser:\n    \"\"\"Get the appropriate state normaliser for the given base state.\n\n    Args:\n        base_state (int): the state the defines the possible entities that\n            the normaliser should consider.\n\n    Returns:\n        StateValueNormaliser: _description_\n    \"\"\"\n    entities = self.dynamics.state_pool.get_state_from_id(\n        base_state\n    ).entities\n\n    if self.enable_cache:\n        cached_version = self.cache.get(entities, None)\n        if cached_version is not None:\n            return cached_version\n\n    normaliser = StateValueNormaliser(\n        self.agent,\n        self.__get_state_pool(),\n        self.__get_value_range(),\n    )\n    self.cache[entities] = normaliser\n    return normaliser\n</code></pre>"},{"location":"reference/model/learning_system/value_standardisation/value_range/","title":"Value Range","text":""},{"location":"reference/model/learning_system/value_standardisation/value_range/#src.model.learning_system.value_standardisation.value_range.ValueRange","title":"<code>ValueRange</code>","text":"<p>             Bases: <code>object</code></p> <p>Maintains the range of all possible values for mapping from 0 to 1.</p> Source code in <code>src/model/learning_system/value_standardisation/value_range.py</code> <pre><code>class ValueRange(object):\n    \"\"\"Maintains the range of all possible values for mapping from 0 to 1.\"\"\"\n\n    def __init__(self, state_pool: StatePool, agent: BaseAgent) -&gt; None:\n        \"\"\"Initialise a value range.\n\n        Args:\n            state_pool (StatePool): the populated set of all possible states to\n                find the range of values.\n            agent (BaseAgent): the agent to decide on values\n\n        \"\"\"\n        self.state_pool = state_pool\n        self.agent = agent\n\n        self.action_range: Optional[Tuple[float, float]] = None\n\n        self.state_range: Optional[Tuple[float, float]] = None\n\n    def rescale_value(\n        self, value_type: ValueType, absolute_value: float\n    ) -&gt; float:\n        \"\"\"Rescale a value from a value type into the range 0-1.\n\n        the minimum value of this type would get a value of 0 and the maximum\n        value of this type would get a 1.\n\n        Args:\n            value_type (ValueType): the type of value received\n            absolute_value (float): the raw value before rescaling\n\n        Returns:\n            float: _description_\n        \"\"\"\n        min_value, max_value = self.__get_value_range(value_type)\n        if min_value == max_value:\n            # all values are identical place value in the middle\n            return 0.5\n        return (absolute_value - min_value) / (max_value - min_value)\n\n    def __get_value_range(self, value_type: ValueType) -&gt; Tuple[float, float]:\n        match value_type:\n            case ValueType.state_value:\n                return self.__get_state_value_range()\n            case ValueType.state_action_value:\n                return self.__get_state_action_value_range()\n\n    def __get_state_value_range(self) -&gt; Tuple[float, float]:\n        if self.state_range is not None:\n            return self.state_range\n        maximum_state_value = float(\"-inf\")\n        minimum_state_value = float(\"inf\")\n        for state in self.state_pool.state_to_id.values():\n            state_value = self.agent.get_state_value(state)\n            maximum_state_value = max(maximum_state_value, state_value)\n            minimum_state_value = min(minimum_state_value, state_value)\n\n        self.state_range = (minimum_state_value, maximum_state_value)\n        return self.state_range\n\n    def __get_state_action_value_range(self) -&gt; Tuple[float, float]:\n        if self.action_range is not None:\n            return self.action_range\n\n        maximum_action_value = float(\"-inf\")\n        minimum_action_value = float(\"inf\")\n\n        for state in self.state_pool.state_to_id.values():\n            for action in Action:\n                action_value = self.agent.get_state_action_value(state, action)\n                maximum_action_value = max(maximum_action_value, action_value)\n                minimum_action_value = min(minimum_action_value, action_value)\n\n        self.action_range = (minimum_action_value, maximum_action_value)\n        return self.action_range\n</code></pre>"},{"location":"reference/model/learning_system/value_standardisation/value_range/#src.model.learning_system.value_standardisation.value_range.ValueRange.__init__","title":"<code>__init__(state_pool, agent)</code>","text":"<p>Initialise a value range.</p> <p>Parameters:</p> Name Type Description Default <code>state_pool</code> <code>StatePool</code> <p>the populated set of all possible states to find the range of values.</p> required <code>agent</code> <code>BaseAgent</code> <p>the agent to decide on values</p> required Source code in <code>src/model/learning_system/value_standardisation/value_range.py</code> <pre><code>def __init__(self, state_pool: StatePool, agent: BaseAgent) -&gt; None:\n    \"\"\"Initialise a value range.\n\n    Args:\n        state_pool (StatePool): the populated set of all possible states to\n            find the range of values.\n        agent (BaseAgent): the agent to decide on values\n\n    \"\"\"\n    self.state_pool = state_pool\n    self.agent = agent\n\n    self.action_range: Optional[Tuple[float, float]] = None\n\n    self.state_range: Optional[Tuple[float, float]] = None\n</code></pre>"},{"location":"reference/model/learning_system/value_standardisation/value_range/#src.model.learning_system.value_standardisation.value_range.ValueRange.rescale_value","title":"<code>rescale_value(value_type, absolute_value)</code>","text":"<p>Rescale a value from a value type into the range 0-1.</p> <p>the minimum value of this type would get a value of 0 and the maximum value of this type would get a 1.</p> <p>Parameters:</p> Name Type Description Default <code>value_type</code> <code>ValueType</code> <p>the type of value received</p> required <code>absolute_value</code> <code>float</code> <p>the raw value before rescaling</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>description</p> Source code in <code>src/model/learning_system/value_standardisation/value_range.py</code> <pre><code>def rescale_value(\n    self, value_type: ValueType, absolute_value: float\n) -&gt; float:\n    \"\"\"Rescale a value from a value type into the range 0-1.\n\n    the minimum value of this type would get a value of 0 and the maximum\n    value of this type would get a 1.\n\n    Args:\n        value_type (ValueType): the type of value received\n        absolute_value (float): the raw value before rescaling\n\n    Returns:\n        float: _description_\n    \"\"\"\n    min_value, max_value = self.__get_value_range(value_type)\n    if min_value == max_value:\n        # all values are identical place value in the middle\n        return 0.5\n    return (absolute_value - min_value) / (max_value - min_value)\n</code></pre>"},{"location":"reference/model/learning_system/value_standardisation/value_range/#src.model.learning_system.value_standardisation.value_range.ValueType","title":"<code>ValueType</code>","text":"<p>             Bases: <code>Enum</code></p> <p>Enumerates the possible types of values.</p> Source code in <code>src/model/learning_system/value_standardisation/value_range.py</code> <pre><code>class ValueType(Enum):\n    \"\"\"Enumerates the possible types of values.\"\"\"\n\n    state_value = 0\n    state_action_value = 1\n</code></pre>"},{"location":"reference/model/state/","title":"State","text":"<p>This Package contains functionality for representing each state.</p>"},{"location":"reference/model/state/cell_entities/","title":"Cell Entities","text":""},{"location":"reference/model/state/cell_entities/#src.model.state.cell_entities.CellEntity","title":"<code>CellEntity</code>","text":"<p>             Bases: <code>Enum</code></p> <p>This class enumerates all the possible entities that may be in a cell.</p> Source code in <code>src/model/state/cell_entities.py</code> <pre><code>class CellEntity(Enum):\n    \"\"\"This class enumerates all the possible entities that may be in a cell.\"\"\"\n\n    agent = 1\n    goal = 2\n    empty = 3\n    warning = 4\n</code></pre>"},{"location":"reference/model/state/state_builder/","title":"State Builder","text":""},{"location":"reference/model/state/state_builder/#src.model.state.state_builder.StateBuilder","title":"<code>StateBuilder</code>","text":"<p>             Bases: <code>object</code></p> <p>State builder simplifies creating states.</p> <p>Since states must be immutable the state builder lets you apply multiple changes without creating the intermediary states.</p> Source code in <code>src/model/state/state_builder.py</code> <pre><code>class StateBuilder(object):\n    \"\"\"State builder simplifies creating states.\n\n    Since states must be immutable the state builder lets you apply multiple\n    changes without creating the intermediary states.\n    \"\"\"\n\n    def __init__(\n        self,\n        previous_state: Optional[StateInstance] = None,\n    ) -&gt; None:\n        \"\"\"Initialise the state builder.\n\n        Args:\n            previous_state (Optional[StateInstance]): the state to build from,\n                if not specified an arbitrary state is chosen.\n        \"\"\"\n        if previous_state is None:\n            previous_state = StateInstance.get_blank_state()\n\n        self.entities = previous_state.entities\n        self.agent_location = previous_state.agent_location\n\n    def set_agent_location(self, pos: tuple[int, int]) -&gt; Self:\n        \"\"\"Set the agent's location.\n\n        Args:\n            pos (tuple[int, int]): the agent's new location\n\n        Returns:\n            Self: the builder to continue chaining methods\n        \"\"\"\n        self.agent_location = pos\n        return self\n\n    def set_entity(self, cell: tuple[int, int], entity: CellEntity) -&gt; Self:\n        \"\"\"Set the entity that is in a cell.\n\n        Args:\n            cell (tuple[int, int]): the cell where to update the entity.\n            entity (CellEntity): the new entity at this location.\n\n        Returns:\n            Self: the builder to continue chaining methods\n        \"\"\"\n        self.entities = self.entities.set(cell, entity)\n        return self\n\n    def remove_entity(self, cell: tuple[int, int]) -&gt; Self:\n        \"\"\"Remove the entity that is in a cell.\n\n        Args:\n            cell (tuple[int, int]): the cell where to update an entity.\n\n        Returns:\n            Self: the builder to continue chaining methods\n        \"\"\"\n        self.entities = self.entities.delete(cell)\n        return self\n\n    def build(self) -&gt; StateInstance:\n        \"\"\"Compile the changes into the new state.\n\n        Returns:\n            StateInstance: the new state instance after the changes have been\n            applied.\n        \"\"\"\n        return StateInstance(self.agent_location, self.entities)\n</code></pre>"},{"location":"reference/model/state/state_builder/#src.model.state.state_builder.StateBuilder.__init__","title":"<code>__init__(previous_state=None)</code>","text":"<p>Initialise the state builder.</p> <p>Parameters:</p> Name Type Description Default <code>previous_state</code> <code>Optional[StateInstance]</code> <p>the state to build from, if not specified an arbitrary state is chosen.</p> <code>None</code> Source code in <code>src/model/state/state_builder.py</code> <pre><code>def __init__(\n    self,\n    previous_state: Optional[StateInstance] = None,\n) -&gt; None:\n    \"\"\"Initialise the state builder.\n\n    Args:\n        previous_state (Optional[StateInstance]): the state to build from,\n            if not specified an arbitrary state is chosen.\n    \"\"\"\n    if previous_state is None:\n        previous_state = StateInstance.get_blank_state()\n\n    self.entities = previous_state.entities\n    self.agent_location = previous_state.agent_location\n</code></pre>"},{"location":"reference/model/state/state_builder/#src.model.state.state_builder.StateBuilder.build","title":"<code>build()</code>","text":"<p>Compile the changes into the new state.</p> <p>Returns:</p> Name Type Description <code>StateInstance</code> <code>StateInstance</code> <p>the new state instance after the changes have been</p> <code>StateInstance</code> <p>applied.</p> Source code in <code>src/model/state/state_builder.py</code> <pre><code>def build(self) -&gt; StateInstance:\n    \"\"\"Compile the changes into the new state.\n\n    Returns:\n        StateInstance: the new state instance after the changes have been\n        applied.\n    \"\"\"\n    return StateInstance(self.agent_location, self.entities)\n</code></pre>"},{"location":"reference/model/state/state_builder/#src.model.state.state_builder.StateBuilder.remove_entity","title":"<code>remove_entity(cell)</code>","text":"<p>Remove the entity that is in a cell.</p> <p>Parameters:</p> Name Type Description Default <code>cell</code> <code>tuple[int, int]</code> <p>the cell where to update an entity.</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>the builder to continue chaining methods</p> Source code in <code>src/model/state/state_builder.py</code> <pre><code>def remove_entity(self, cell: tuple[int, int]) -&gt; Self:\n    \"\"\"Remove the entity that is in a cell.\n\n    Args:\n        cell (tuple[int, int]): the cell where to update an entity.\n\n    Returns:\n        Self: the builder to continue chaining methods\n    \"\"\"\n    self.entities = self.entities.delete(cell)\n    return self\n</code></pre>"},{"location":"reference/model/state/state_builder/#src.model.state.state_builder.StateBuilder.set_agent_location","title":"<code>set_agent_location(pos)</code>","text":"<p>Set the agent's location.</p> <p>Parameters:</p> Name Type Description Default <code>pos</code> <code>tuple[int, int]</code> <p>the agent's new location</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>the builder to continue chaining methods</p> Source code in <code>src/model/state/state_builder.py</code> <pre><code>def set_agent_location(self, pos: tuple[int, int]) -&gt; Self:\n    \"\"\"Set the agent's location.\n\n    Args:\n        pos (tuple[int, int]): the agent's new location\n\n    Returns:\n        Self: the builder to continue chaining methods\n    \"\"\"\n    self.agent_location = pos\n    return self\n</code></pre>"},{"location":"reference/model/state/state_builder/#src.model.state.state_builder.StateBuilder.set_entity","title":"<code>set_entity(cell, entity)</code>","text":"<p>Set the entity that is in a cell.</p> <p>Parameters:</p> Name Type Description Default <code>cell</code> <code>tuple[int, int]</code> <p>the cell where to update the entity.</p> required <code>entity</code> <code>CellEntity</code> <p>the new entity at this location.</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>the builder to continue chaining methods</p> Source code in <code>src/model/state/state_builder.py</code> <pre><code>def set_entity(self, cell: tuple[int, int], entity: CellEntity) -&gt; Self:\n    \"\"\"Set the entity that is in a cell.\n\n    Args:\n        cell (tuple[int, int]): the cell where to update the entity.\n        entity (CellEntity): the new entity at this location.\n\n    Returns:\n        Self: the builder to continue chaining methods\n    \"\"\"\n    self.entities = self.entities.set(cell, entity)\n    return self\n</code></pre>"},{"location":"reference/model/state/state_instance/","title":"State Instance","text":""},{"location":"reference/model/state/state_instance/#src.model.state.state_instance.StateInstance","title":"<code>StateInstance</code>  <code>dataclass</code>","text":"<p>             Bases: <code>object</code></p> <p>This class represents a possible state in the grid world of this MDP.</p> Source code in <code>src/model/state/state_instance.py</code> <pre><code>@dataclass(frozen=True, slots=True)\nclass StateInstance(object):\n    \"\"\"This class represents a possible state in the grid world of this MDP.\"\"\"\n\n    agent_location: Tuple[int, int]\n    entities: entities_type\n\n    @classmethod\n    def get_blank_state(cls) -&gt; Self:\n        \"\"\"Create a blank state.\n\n        Returns:\n            Self: a state with no particular features.\n        \"\"\"\n        return cls((0, 0), Map())\n</code></pre>"},{"location":"reference/model/state/state_instance/#src.model.state.state_instance.StateInstance.get_blank_state","title":"<code>get_blank_state()</code>  <code>classmethod</code>","text":"<p>Create a blank state.</p> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>a state with no particular features.</p> Source code in <code>src/model/state/state_instance.py</code> <pre><code>@classmethod\ndef get_blank_state(cls) -&gt; Self:\n    \"\"\"Create a blank state.\n\n    Returns:\n        Self: a state with no particular features.\n    \"\"\"\n    return cls((0, 0), Map())\n</code></pre>"},{"location":"reference/model/state/state_pool/","title":"State Pool","text":""},{"location":"reference/model/state/state_pool/#src.model.state.state_pool.StatePool","title":"<code>StatePool</code>","text":"<p>             Bases: <code>object</code></p> <p>Class that manages the creation of states.</p> <p>This class avoids redundant states and allows for consistent identification</p> Source code in <code>src/model/state/state_pool.py</code> <pre><code>class StatePool(object):\n    \"\"\"Class that manages the creation of states.\n\n    This class avoids redundant states and allows for consistent identification\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialise a state pool.\"\"\"\n        self.id_to_state: Dict[int, StateInstance] = {}\n        self.state_to_id: Dict[StateInstance, int] = {}\n\n    def is_existing_state(self, state: StateInstance) -&gt; bool:\n        \"\"\"Determine weather a state has already been registered.\n\n        Args:\n            state (StateInstance): the state to check\n\n        Returns:\n            bool: true if this state already exists in this pool\n        \"\"\"\n        return state in self.state_to_id\n\n    def get_state_id(self, state: StateInstance) -&gt; int:\n        \"\"\"Get the numeric id for a given state.\n\n        If the state has already been registered with this pool then it should\n        return the existing key. else it should add this state to the pool and\n        return the new state.\n\n        Note, this id is not necessarily globally unique however it is unique in\n        this state pool\n\n        Args:\n            state (StateInstance): the state to get a unique id for\n\n        Returns:\n            int: the id for this state\n        \"\"\"\n        state_to_id = self.state_to_id\n        if state in state_to_id:\n            return state_to_id[state]  # noqa: WPS529 get is too slow\n        new_id = len(state_to_id)\n        state_to_id[state] = new_id\n        self.id_to_state[new_id] = state\n        return new_id\n\n    def get_state_from_id(self, identifier: int) -&gt; StateInstance:\n        \"\"\"Get the state object corresponding to the given key in this pool.\n\n        Args:\n            identifier (int): the key of the state to get\n\n        Returns:\n            StateInstance: the state that is registered under this id\n        \"\"\"\n        return self.id_to_state[identifier]\n</code></pre>"},{"location":"reference/model/state/state_pool/#src.model.state.state_pool.StatePool.__init__","title":"<code>__init__()</code>","text":"<p>Initialise a state pool.</p> Source code in <code>src/model/state/state_pool.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialise a state pool.\"\"\"\n    self.id_to_state: Dict[int, StateInstance] = {}\n    self.state_to_id: Dict[StateInstance, int] = {}\n</code></pre>"},{"location":"reference/model/state/state_pool/#src.model.state.state_pool.StatePool.get_state_from_id","title":"<code>get_state_from_id(identifier)</code>","text":"<p>Get the state object corresponding to the given key in this pool.</p> <p>Parameters:</p> Name Type Description Default <code>identifier</code> <code>int</code> <p>the key of the state to get</p> required <p>Returns:</p> Name Type Description <code>StateInstance</code> <code>StateInstance</code> <p>the state that is registered under this id</p> Source code in <code>src/model/state/state_pool.py</code> <pre><code>def get_state_from_id(self, identifier: int) -&gt; StateInstance:\n    \"\"\"Get the state object corresponding to the given key in this pool.\n\n    Args:\n        identifier (int): the key of the state to get\n\n    Returns:\n        StateInstance: the state that is registered under this id\n    \"\"\"\n    return self.id_to_state[identifier]\n</code></pre>"},{"location":"reference/model/state/state_pool/#src.model.state.state_pool.StatePool.get_state_id","title":"<code>get_state_id(state)</code>","text":"<p>Get the numeric id for a given state.</p> <p>If the state has already been registered with this pool then it should return the existing key. else it should add this state to the pool and return the new state.</p> <p>Note, this id is not necessarily globally unique however it is unique in this state pool</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>StateInstance</code> <p>the state to get a unique id for</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>the id for this state</p> Source code in <code>src/model/state/state_pool.py</code> <pre><code>def get_state_id(self, state: StateInstance) -&gt; int:\n    \"\"\"Get the numeric id for a given state.\n\n    If the state has already been registered with this pool then it should\n    return the existing key. else it should add this state to the pool and\n    return the new state.\n\n    Note, this id is not necessarily globally unique however it is unique in\n    this state pool\n\n    Args:\n        state (StateInstance): the state to get a unique id for\n\n    Returns:\n        int: the id for this state\n    \"\"\"\n    state_to_id = self.state_to_id\n    if state in state_to_id:\n        return state_to_id[state]  # noqa: WPS529 get is too slow\n    new_id = len(state_to_id)\n    state_to_id[state] = new_id\n    self.id_to_state[new_id] = state\n    return new_id\n</code></pre>"},{"location":"reference/model/state/state_pool/#src.model.state.state_pool.StatePool.is_existing_state","title":"<code>is_existing_state(state)</code>","text":"<p>Determine weather a state has already been registered.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>StateInstance</code> <p>the state to check</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>true if this state already exists in this pool</p> Source code in <code>src/model/state/state_pool.py</code> <pre><code>def is_existing_state(self, state: StateInstance) -&gt; bool:\n    \"\"\"Determine weather a state has already been registered.\n\n    Args:\n        state (StateInstance): the state to check\n\n    Returns:\n        bool: true if this state already exists in this pool\n    \"\"\"\n    return state in self.state_to_id\n</code></pre>"},{"location":"reference/view/","title":"View","text":"<p>The view package this package contains the code that defines the view.</p> <p>the view is the user interface with this program.</p>"},{"location":"reference/view/interaction_controls/","title":"Interaction Controls","text":""},{"location":"reference/view/interaction_controls/#src.view.interaction_controls.InteractionControls","title":"<code>InteractionControls</code>","text":"<p>             Bases: <code>QGroupBox</code></p> <p>Widget that contains the controls for interacting with the grid world.</p> Source code in <code>src/view/interaction_controls.py</code> <pre><code>class InteractionControls(QGroupBox):\n    \"\"\"Widget that contains the controls for interacting with the grid world.\"\"\"\n\n    reset_button_text = \"Reset\"\n\n    group_title = \"Simulation Interaction Controls\"\n\n    def __init__(\n        self, parent: QWidget, control_factory: ControlFactory\n    ) -&gt; None:\n        \"\"\"Initialise the controls.\n\n        Args:\n            parent (QWidget): the parent of this widget.\n            control_factory (ControlFactory): the factory to make the controls\n                with.\n        \"\"\"\n        super().__init__(self.group_title, parent)\n\n        layout = QGridLayout(self)\n\n        display_mode = control_factory.create_combo(\n            self,\n            ComboWidgetState(\n                OptionDisplayText.display_mode_options,\n                LearningSystem.initial_global_options.display_mode,\n            ),\n            UserAction.set_display_mode,\n            self.__display_responsive_options,\n        )\n        layout.addWidget(display_mode, 0, 0)\n\n        reset_button = control_factory.create_button(\n            self, self.reset_button_text, UserAction.reset_state\n        )\n        layout.addWidget(reset_button, 0, 1)\n\n        auto_mode = control_factory.create_combo(\n            self,\n            ComboWidgetState(\n                OptionDisplayText.auto_selector_options,\n                LearningSystem.initial_global_options.automatic,\n            ),\n            UserAction.select_auto,\n            self.__auto_responsive_options,\n        )\n        layout.addWidget(auto_mode, 0, 2)\n\n        progress_button = control_factory.create_button(\n            self,\n            OptionDisplayText.progress_button_text.get_text(\n                LearningSystem.initial_global_options.automatic\n            ),\n            UserAction.progress,\n            self.__progress_button_responsive_text,\n        )\n        layout.addWidget(progress_button, 0, 3)\n\n    def __progress_button_responsive_text(self, state: StateDescription) -&gt; str:\n        \"\"\"Calculate the responsive text for the next button.\n\n        Args:\n            state (StateDescription): the current state.\n\n        Returns:\n            str: the string to show on the button.\n        \"\"\"\n        return OptionDisplayText.progress_button_text.get_text(\n            state.global_options.automatic\n        )\n\n    def __auto_responsive_options(\n        self, state: StateDescription\n    ) -&gt; ComboWidgetState:\n        # limited subset of modes for simplicity.\n        mode = (\n            AutomaticOptions.manual\n            if state.global_options.automatic == AutomaticOptions.manual\n            else AutomaticOptions.automatic_playing\n        )\n        return ComboWidgetState(\n            OptionDisplayText.auto_selector_options,\n            mode,\n        )\n\n    def __display_responsive_options(\n        self, state: StateDescription\n    ) -&gt; ComboWidgetState:\n        return ComboWidgetState(\n            OptionDisplayText.display_mode_options,\n            state.global_options.display_mode,\n        )\n</code></pre>"},{"location":"reference/view/interaction_controls/#src.view.interaction_controls.InteractionControls.__init__","title":"<code>__init__(parent, control_factory)</code>","text":"<p>Initialise the controls.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>the parent of this widget.</p> required <code>control_factory</code> <code>ControlFactory</code> <p>the factory to make the controls with.</p> required Source code in <code>src/view/interaction_controls.py</code> <pre><code>def __init__(\n    self, parent: QWidget, control_factory: ControlFactory\n) -&gt; None:\n    \"\"\"Initialise the controls.\n\n    Args:\n        parent (QWidget): the parent of this widget.\n        control_factory (ControlFactory): the factory to make the controls\n            with.\n    \"\"\"\n    super().__init__(self.group_title, parent)\n\n    layout = QGridLayout(self)\n\n    display_mode = control_factory.create_combo(\n        self,\n        ComboWidgetState(\n            OptionDisplayText.display_mode_options,\n            LearningSystem.initial_global_options.display_mode,\n        ),\n        UserAction.set_display_mode,\n        self.__display_responsive_options,\n    )\n    layout.addWidget(display_mode, 0, 0)\n\n    reset_button = control_factory.create_button(\n        self, self.reset_button_text, UserAction.reset_state\n    )\n    layout.addWidget(reset_button, 0, 1)\n\n    auto_mode = control_factory.create_combo(\n        self,\n        ComboWidgetState(\n            OptionDisplayText.auto_selector_options,\n            LearningSystem.initial_global_options.automatic,\n        ),\n        UserAction.select_auto,\n        self.__auto_responsive_options,\n    )\n    layout.addWidget(auto_mode, 0, 2)\n\n    progress_button = control_factory.create_button(\n        self,\n        OptionDisplayText.progress_button_text.get_text(\n            LearningSystem.initial_global_options.automatic\n        ),\n        UserAction.progress,\n        self.__progress_button_responsive_text,\n    )\n    layout.addWidget(progress_button, 0, 3)\n</code></pre>"},{"location":"reference/view/interaction_controls/#src.view.interaction_controls.InteractionControls.__progress_button_responsive_text","title":"<code>__progress_button_responsive_text(state)</code>","text":"<p>Calculate the responsive text for the next button.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>StateDescription</code> <p>the current state.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>the string to show on the button.</p> Source code in <code>src/view/interaction_controls.py</code> <pre><code>def __progress_button_responsive_text(self, state: StateDescription) -&gt; str:\n    \"\"\"Calculate the responsive text for the next button.\n\n    Args:\n        state (StateDescription): the current state.\n\n    Returns:\n        str: the string to show on the button.\n    \"\"\"\n    return OptionDisplayText.progress_button_text.get_text(\n        state.global_options.automatic\n    )\n</code></pre>"},{"location":"reference/view/main_tab_area/","title":"Main Tab Area","text":""},{"location":"reference/view/main_tab_area/#src.view.main_tab_area.MainTabArea","title":"<code>MainTabArea</code>","text":"<p>             Bases: <code>QTabWidget</code></p> <p>Tab widget to contain the main content areas.</p> Source code in <code>src/view/main_tab_area.py</code> <pre><code>class MainTabArea(QTabWidget):\n    \"\"\"Tab widget to contain the main content areas.\"\"\"\n\n    def __init__(\n        self,\n        parent: Optional[QWidget],\n        state_publisher: StatePublisher,\n        report_controller: HyperParameterController,\n    ) -&gt; None:\n        \"\"\"Initialise the tab widget.\n\n        Args:\n            parent (Optional[QWidget]): the parent of the tab widget.\n            state_publisher (StatePublisher): the state publisher for the live\n                updating tabs.\n            report_controller (HyperParameterController): the controller for\n                the report display tab.\n        \"\"\"\n        super().__init__(parent)\n\n        display_state = DisplayState(None)\n        state_publisher.subscribe(display_state)\n        self.addTab(display_state, \"Current State\")\n\n        reward_history = RewardHistory(None)\n        state_publisher.subscribe(reward_history)\n        self.addTab(reward_history, \"Reward History\")\n\n        self.publisher = ReportStatePublisher(self, report_controller)\n\n        search_display = SearchDisplay(None, report_controller, self.publisher)\n        self.addTab(search_display, \"Hyper-Parameter Search\")\n\n        report_display = ReportContainer(\n            None, report_controller, self.publisher\n        )\n        self.addTab(report_display, \"Hyper-Parameter Tuning\")\n</code></pre>"},{"location":"reference/view/main_tab_area/#src.view.main_tab_area.MainTabArea.__init__","title":"<code>__init__(parent, state_publisher, report_controller)</code>","text":"<p>Initialise the tab widget.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>Optional[QWidget]</code> <p>the parent of the tab widget.</p> required <code>state_publisher</code> <code>StatePublisher</code> <p>the state publisher for the live updating tabs.</p> required <code>report_controller</code> <code>HyperParameterController</code> <p>the controller for the report display tab.</p> required Source code in <code>src/view/main_tab_area.py</code> <pre><code>def __init__(\n    self,\n    parent: Optional[QWidget],\n    state_publisher: StatePublisher,\n    report_controller: HyperParameterController,\n) -&gt; None:\n    \"\"\"Initialise the tab widget.\n\n    Args:\n        parent (Optional[QWidget]): the parent of the tab widget.\n        state_publisher (StatePublisher): the state publisher for the live\n            updating tabs.\n        report_controller (HyperParameterController): the controller for\n            the report display tab.\n    \"\"\"\n    super().__init__(parent)\n\n    display_state = DisplayState(None)\n    state_publisher.subscribe(display_state)\n    self.addTab(display_state, \"Current State\")\n\n    reward_history = RewardHistory(None)\n    state_publisher.subscribe(reward_history)\n    self.addTab(reward_history, \"Reward History\")\n\n    self.publisher = ReportStatePublisher(self, report_controller)\n\n    search_display = SearchDisplay(None, report_controller, self.publisher)\n    self.addTab(search_display, \"Hyper-Parameter Search\")\n\n    report_display = ReportContainer(\n        None, report_controller, self.publisher\n    )\n    self.addTab(report_display, \"Hyper-Parameter Tuning\")\n</code></pre>"},{"location":"reference/view/option_controls/","title":"Option Controls","text":""},{"location":"reference/view/option_controls/#src.view.option_controls.OptionControls","title":"<code>OptionControls</code>","text":"<p>             Bases: <code>QGroupBox</code></p> <p>Widget that contains the controls for interacting with the grid world.</p> Source code in <code>src/view/option_controls.py</code> <pre><code>class OptionControls(QGroupBox):\n    \"\"\"Widget that contains the controls for interacting with the grid world.\"\"\"\n\n    group_title = \"Simulation Configuration Controls\"\n\n    reset_button_text = \"reset\"\n\n    def __init__(\n        self, parent: QWidget, control_factory: ControlFactory\n    ) -&gt; None:\n        \"\"\"Initialise the option controls.\n\n        Args:\n            parent (QWidget): the parent of this widget.\n            control_factory (ControlFactory): the factory to make the controls\n                with.\n        \"\"\"\n        super().__init__(self.group_title, parent)\n\n        layout = QGridLayout(self)\n\n        agent = control_factory.create_combo(\n            self,\n            ComboWidgetState(\n                OptionDisplayText.agent_options,\n                LearningSystem.initial_top_options.agent,\n            ),\n            UserAction.set_agent,\n            self.__agent_responsive_options,\n        )\n        layout.addWidget(agent, 0, 0)\n\n        agent_strategy = control_factory.create_combo(\n            self,\n            ComboWidgetState(\n                OptionDisplayText.not_applicable_exploration_option,\n                LearningSystem.initial_top_options.exploration_strategy,\n            ),\n            UserAction.set_agent_strategy,\n            self.__strategy_responsive_options,\n        )\n        layout.addWidget(agent_strategy, 0, 1)\n\n        dynamics = control_factory.create_combo(\n            self,\n            ComboWidgetState(\n                OptionDisplayText.dynamics_options,\n                LearningSystem.initial_top_options.dynamics,\n            ),\n            UserAction.set_dynamics,\n            self.__dynamics_responsive_options,\n        )\n        layout.addWidget(dynamics, 0, 2)\n\n        reset = control_factory.create_button(\n            self, self.reset_button_text, UserAction.reset_system\n        )\n        layout.addWidget(reset, 0, 3)\n\n    def __strategy_responsive_options(\n        self, state: StateDescription\n    ) -&gt; ComboWidgetState:\n        strategy = state.global_options.top_level_options.exploration_strategy\n        if strategy is ExplorationStrategyOptions.not_applicable:\n            return ComboWidgetState(\n                OptionDisplayText.not_applicable_exploration_option,\n                ExplorationStrategyOptions.not_applicable,\n                enabled=False,\n            )\n\n        return ComboWidgetState(\n            OptionDisplayText.applicable_exploration_option, strategy\n        )\n\n    def __agent_responsive_options(\n        self, state: StateDescription\n    ) -&gt; ComboWidgetState:\n        return ComboWidgetState(\n            OptionDisplayText.agent_options,\n            state.global_options.top_level_options.agent,\n        )\n\n    def __dynamics_responsive_options(\n        self, state: StateDescription\n    ) -&gt; ComboWidgetState:\n        return ComboWidgetState(\n            OptionDisplayText.dynamics_options,\n            state.global_options.top_level_options.dynamics,\n        )\n</code></pre>"},{"location":"reference/view/option_controls/#src.view.option_controls.OptionControls.__init__","title":"<code>__init__(parent, control_factory)</code>","text":"<p>Initialise the option controls.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>the parent of this widget.</p> required <code>control_factory</code> <code>ControlFactory</code> <p>the factory to make the controls with.</p> required Source code in <code>src/view/option_controls.py</code> <pre><code>def __init__(\n    self, parent: QWidget, control_factory: ControlFactory\n) -&gt; None:\n    \"\"\"Initialise the option controls.\n\n    Args:\n        parent (QWidget): the parent of this widget.\n        control_factory (ControlFactory): the factory to make the controls\n            with.\n    \"\"\"\n    super().__init__(self.group_title, parent)\n\n    layout = QGridLayout(self)\n\n    agent = control_factory.create_combo(\n        self,\n        ComboWidgetState(\n            OptionDisplayText.agent_options,\n            LearningSystem.initial_top_options.agent,\n        ),\n        UserAction.set_agent,\n        self.__agent_responsive_options,\n    )\n    layout.addWidget(agent, 0, 0)\n\n    agent_strategy = control_factory.create_combo(\n        self,\n        ComboWidgetState(\n            OptionDisplayText.not_applicable_exploration_option,\n            LearningSystem.initial_top_options.exploration_strategy,\n        ),\n        UserAction.set_agent_strategy,\n        self.__strategy_responsive_options,\n    )\n    layout.addWidget(agent_strategy, 0, 1)\n\n    dynamics = control_factory.create_combo(\n        self,\n        ComboWidgetState(\n            OptionDisplayText.dynamics_options,\n            LearningSystem.initial_top_options.dynamics,\n        ),\n        UserAction.set_dynamics,\n        self.__dynamics_responsive_options,\n    )\n    layout.addWidget(dynamics, 0, 2)\n\n    reset = control_factory.create_button(\n        self, self.reset_button_text, UserAction.reset_system\n    )\n    layout.addWidget(reset, 0, 3)\n</code></pre>"},{"location":"reference/view/option_display_text/","title":"Option Display Text","text":""},{"location":"reference/view/option_display_text/#src.view.option_display_text.DisplayTextListing","title":"<code>DisplayTextListing</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Generic[Option]</code></p> <p>Class for listing the display strings for each option.</p> Source code in <code>src/view/option_display_text.py</code> <pre><code>@dataclass(frozen=True, slots=True)\nclass DisplayTextListing(Generic[Option]):\n    \"\"\"Class for listing the display strings for each option.\"\"\"\n\n    texts: Dict[Option, str]\n\n    def get_mapping(self) -&gt; Dict[Option, str]:\n        \"\"\"Get the mapping from options to their display texts.\n\n        Returns:\n            Dict[Option, str]: mapping from options to their display text.\n        \"\"\"\n        return self.texts\n\n    def get_reverse_mapping(self) -&gt; Dict[str, Option]:\n        \"\"\"Get the mapping from display text to the option.\n\n        Returns:\n            Dict[str, Option]: mapping from string to an option.\n        \"\"\"\n        return {txt: opt for opt, txt in self.get_mapping().items()}\n\n    def get_text(self, option: Option) -&gt; str:\n        \"\"\"Get the display text for a given option.\n\n        Args:\n            option (Option): the option to lookup.\n\n        Returns:\n            str: the display text if the option is known.\n        \"\"\"\n        return self.get_mapping()[option]\n\n    def get_option(self, text: str) -&gt; Option:\n        \"\"\"Get the option corresponding to the given display text.\n\n        Args:\n            text (str): the display text to lookup.\n\n        Returns:\n            Option: the option for this display text if one can be\n                found.\n        \"\"\"\n        return self.get_reverse_mapping()[text]\n\n    def list_all_text(self) -&gt; List[str]:\n        \"\"\"List all of the display text options.\n\n        Returns:\n            List[str]: list of all the display text options.\n        \"\"\"\n        return list(self.get_mapping().values())\n\n    def create_subset(self, *opts: Option) -&gt; \"DisplayTextListing[Option]\":\n        \"\"\"Create a listing that is a subset of another.\n\n        Args:\n            opts (Option): The options to include in the subset.\n\n        Returns:\n            DisplayTextListing: the new display text listing with the reduced\n                options.\n        \"\"\"\n        return DisplayTextListing(\n            {opt: txt for opt, txt in self.get_mapping().items() if opt in opts}\n        )\n</code></pre>"},{"location":"reference/view/option_display_text/#src.view.option_display_text.DisplayTextListing.create_subset","title":"<code>create_subset(*opts)</code>","text":"<p>Create a listing that is a subset of another.</p> <p>Parameters:</p> Name Type Description Default <code>opts</code> <code>Option</code> <p>The options to include in the subset.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>DisplayTextListing</code> <code>DisplayTextListing[Option]</code> <p>the new display text listing with the reduced options.</p> Source code in <code>src/view/option_display_text.py</code> <pre><code>def create_subset(self, *opts: Option) -&gt; \"DisplayTextListing[Option]\":\n    \"\"\"Create a listing that is a subset of another.\n\n    Args:\n        opts (Option): The options to include in the subset.\n\n    Returns:\n        DisplayTextListing: the new display text listing with the reduced\n            options.\n    \"\"\"\n    return DisplayTextListing(\n        {opt: txt for opt, txt in self.get_mapping().items() if opt in opts}\n    )\n</code></pre>"},{"location":"reference/view/option_display_text/#src.view.option_display_text.DisplayTextListing.get_mapping","title":"<code>get_mapping()</code>","text":"<p>Get the mapping from options to their display texts.</p> <p>Returns:</p> Type Description <code>Dict[Option, str]</code> <p>Dict[Option, str]: mapping from options to their display text.</p> Source code in <code>src/view/option_display_text.py</code> <pre><code>def get_mapping(self) -&gt; Dict[Option, str]:\n    \"\"\"Get the mapping from options to their display texts.\n\n    Returns:\n        Dict[Option, str]: mapping from options to their display text.\n    \"\"\"\n    return self.texts\n</code></pre>"},{"location":"reference/view/option_display_text/#src.view.option_display_text.DisplayTextListing.get_option","title":"<code>get_option(text)</code>","text":"<p>Get the option corresponding to the given display text.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>the display text to lookup.</p> required <p>Returns:</p> Name Type Description <code>Option</code> <code>Option</code> <p>the option for this display text if one can be found.</p> Source code in <code>src/view/option_display_text.py</code> <pre><code>def get_option(self, text: str) -&gt; Option:\n    \"\"\"Get the option corresponding to the given display text.\n\n    Args:\n        text (str): the display text to lookup.\n\n    Returns:\n        Option: the option for this display text if one can be\n            found.\n    \"\"\"\n    return self.get_reverse_mapping()[text]\n</code></pre>"},{"location":"reference/view/option_display_text/#src.view.option_display_text.DisplayTextListing.get_reverse_mapping","title":"<code>get_reverse_mapping()</code>","text":"<p>Get the mapping from display text to the option.</p> <p>Returns:</p> Type Description <code>Dict[str, Option]</code> <p>Dict[str, Option]: mapping from string to an option.</p> Source code in <code>src/view/option_display_text.py</code> <pre><code>def get_reverse_mapping(self) -&gt; Dict[str, Option]:\n    \"\"\"Get the mapping from display text to the option.\n\n    Returns:\n        Dict[str, Option]: mapping from string to an option.\n    \"\"\"\n    return {txt: opt for opt, txt in self.get_mapping().items()}\n</code></pre>"},{"location":"reference/view/option_display_text/#src.view.option_display_text.DisplayTextListing.get_text","title":"<code>get_text(option)</code>","text":"<p>Get the display text for a given option.</p> <p>Parameters:</p> Name Type Description Default <code>option</code> <code>Option</code> <p>the option to lookup.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>the display text if the option is known.</p> Source code in <code>src/view/option_display_text.py</code> <pre><code>def get_text(self, option: Option) -&gt; str:\n    \"\"\"Get the display text for a given option.\n\n    Args:\n        option (Option): the option to lookup.\n\n    Returns:\n        str: the display text if the option is known.\n    \"\"\"\n    return self.get_mapping()[option]\n</code></pre>"},{"location":"reference/view/option_display_text/#src.view.option_display_text.DisplayTextListing.list_all_text","title":"<code>list_all_text()</code>","text":"<p>List all of the display text options.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: list of all the display text options.</p> Source code in <code>src/view/option_display_text.py</code> <pre><code>def list_all_text(self) -&gt; List[str]:\n    \"\"\"List all of the display text options.\n\n    Returns:\n        List[str]: list of all the display text options.\n    \"\"\"\n    return list(self.get_mapping().values())\n</code></pre>"},{"location":"reference/view/option_display_text/#src.view.option_display_text.OptionDisplayText","title":"<code>OptionDisplayText</code>","text":"<p>             Bases: <code>object</code></p> <p>Class for containing all of the display text listings.</p> Source code in <code>src/view/option_display_text.py</code> <pre><code>class OptionDisplayText(object):\n    \"\"\"Class for containing all of the display text listings.\"\"\"\n\n    agent_options = DisplayTextListing(\n        {\n            AgentOptions.value_iteration_optimised: \"Value Iteration\",\n            AgentOptions.q_learning: \"Q-Learning\",\n        }\n    )\n\n    full_exploration_options = DisplayTextListing(\n        {\n            ExplorationStrategyOptions.not_applicable: \"Not Applicable\",\n            ExplorationStrategyOptions.epsilon_greedy: \"Epsilon Greedy\",\n            ExplorationStrategyOptions.upper_confidence_bound: (\n                \"(UCB) Upper Confidence Bound\"\n            ),\n            ExplorationStrategyOptions.mf_bpi: (\n                \"(MF-BPI) Model-Free Best Policy Identification\"\n            ),\n        }\n    )\n\n    not_applicable_exploration_option = full_exploration_options.create_subset(\n        ExplorationStrategyOptions.not_applicable\n    )\n\n    applicable_exploration_option = full_exploration_options.create_subset(\n        ExplorationStrategyOptions.epsilon_greedy,\n        ExplorationStrategyOptions.upper_confidence_bound,\n        ExplorationStrategyOptions.mf_bpi,\n    )\n\n    dynamics_options = DisplayTextListing(\n        {\n            DynamicsOptions.collection: \"Collection\",\n            DynamicsOptions.cliff: \"Cliff\",\n        }\n    )\n\n    display_mode_options = DisplayTextListing(\n        {\n            DisplayMode.default: \"default\",\n            DisplayMode.best_action: \"best action\",\n            DisplayMode.state_value: \"state value\",\n            DisplayMode.action_value_global: \"action value\",\n            DisplayMode.action_value_local: \"action value local\",\n        }\n    )\n\n    auto_speed_options = DisplayTextListing(\n        {\n            AutomaticOptions.manual: \"Manual\",\n            AutomaticOptions.automatic_playing: \"Auto\",\n            AutomaticOptions.automatic_paused: \"Auto (paused)\",\n        }\n    )\n\n    auto_selector_options = auto_speed_options.create_subset(\n        AutomaticOptions.manual, AutomaticOptions.automatic_playing\n    )\n\n    progress_button_text = DisplayTextListing(\n        {\n            AutomaticOptions.manual: \"Next\",\n            AutomaticOptions.automatic_playing: \"Pause\",\n            AutomaticOptions.automatic_paused: \"Play\",\n        }\n    )\n</code></pre>"},{"location":"reference/view/report_state_publisher/","title":"Report State Publisher","text":""},{"location":"reference/view/report_state_publisher/#src.view.report_state_publisher.BaseReportObserver","title":"<code>BaseReportObserver</code>","text":"<p>             Bases: <code>object</code></p> <p>The base class for report state observers.</p> Source code in <code>src/view/report_state_publisher.py</code> <pre><code>class BaseReportObserver(object):\n    \"\"\"The base class for report state observers.\"\"\"\n\n    def report_state_updated(self, state: HyperParameterState) -&gt; None:\n        \"\"\"Handle report state update events.\n\n        Args:\n            state (HyperParameterState): the new hyper parameter state\n\n        Raises:\n            NotImplementedError: If the method is not overridden by a concrete\n                observer.\n        \"\"\"\n        self.__throw_not_implemented()\n\n    def __throw_not_implemented(self):\n        raise NotImplementedError(\n            \"This method should be overridden by a concrete observer\"\n        )\n</code></pre>"},{"location":"reference/view/report_state_publisher/#src.view.report_state_publisher.BaseReportObserver.report_state_updated","title":"<code>report_state_updated(state)</code>","text":"<p>Handle report state update events.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>HyperParameterState</code> <p>the new hyper parameter state</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the method is not overridden by a concrete observer.</p> Source code in <code>src/view/report_state_publisher.py</code> <pre><code>def report_state_updated(self, state: HyperParameterState) -&gt; None:\n    \"\"\"Handle report state update events.\n\n    Args:\n        state (HyperParameterState): the new hyper parameter state\n\n    Raises:\n        NotImplementedError: If the method is not overridden by a concrete\n            observer.\n    \"\"\"\n    self.__throw_not_implemented()\n</code></pre>"},{"location":"reference/view/report_state_publisher/#src.view.report_state_publisher.ReportStatePublisher","title":"<code>ReportStatePublisher</code>","text":"<p>             Bases: <code>object</code></p> <p>Publisher class for state updates.</p> Source code in <code>src/view/report_state_publisher.py</code> <pre><code>class ReportStatePublisher(object):\n    \"\"\"Publisher class for state updates.\"\"\"\n\n    def __init__(\n        self, parent: QWidget, controller: HyperParameterController\n    ) -&gt; None:\n        \"\"\"Initialise a new state publisher.\n\n        Args:\n            parent (QWidget): the widget that this publisher is associated with.\n                timers do not work without this.\n            controller (HyperParameterController): the controller to listen for\n                state update from.\n        \"\"\"\n        timer = QTimer(parent)\n        timer.timeout.connect(self.check_for_updates)\n        # slow update cycle not performance critical\n        timer.start(100)\n\n        self.update_bridge = controller.update_bridge\n\n        self.observers: list[BaseReportObserver] = []\n\n        # used to provided initial state\n        self.latest_state: Optional[HyperParameterState] = None\n\n        # start updates\n        controller.request_bridge.request_current_state()\n\n    def subscribe(self, observer: BaseReportObserver) -&gt; None:\n        \"\"\"Subscribe a new observer to state updates.\n\n        Args:\n            observer (BaseReportObserver): the observer to listen for state\n                updates.\n        \"\"\"\n        self.observers.append(observer)\n        if self.latest_state is not None:\n            observer.report_state_updated(self.latest_state)\n\n    def check_for_updates(self):\n        \"\"\"Check if any updates to the UI are requested.\"\"\"\n        state = self.update_bridge.get_latest_state()\n        if state is not None:\n            for observer in self.observers:\n                observer.report_state_updated(state)\n</code></pre>"},{"location":"reference/view/report_state_publisher/#src.view.report_state_publisher.ReportStatePublisher.__init__","title":"<code>__init__(parent, controller)</code>","text":"<p>Initialise a new state publisher.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>the widget that this publisher is associated with. timers do not work without this.</p> required <code>controller</code> <code>HyperParameterController</code> <p>the controller to listen for state update from.</p> required Source code in <code>src/view/report_state_publisher.py</code> <pre><code>def __init__(\n    self, parent: QWidget, controller: HyperParameterController\n) -&gt; None:\n    \"\"\"Initialise a new state publisher.\n\n    Args:\n        parent (QWidget): the widget that this publisher is associated with.\n            timers do not work without this.\n        controller (HyperParameterController): the controller to listen for\n            state update from.\n    \"\"\"\n    timer = QTimer(parent)\n    timer.timeout.connect(self.check_for_updates)\n    # slow update cycle not performance critical\n    timer.start(100)\n\n    self.update_bridge = controller.update_bridge\n\n    self.observers: list[BaseReportObserver] = []\n\n    # used to provided initial state\n    self.latest_state: Optional[HyperParameterState] = None\n\n    # start updates\n    controller.request_bridge.request_current_state()\n</code></pre>"},{"location":"reference/view/report_state_publisher/#src.view.report_state_publisher.ReportStatePublisher.check_for_updates","title":"<code>check_for_updates()</code>","text":"<p>Check if any updates to the UI are requested.</p> Source code in <code>src/view/report_state_publisher.py</code> <pre><code>def check_for_updates(self):\n    \"\"\"Check if any updates to the UI are requested.\"\"\"\n    state = self.update_bridge.get_latest_state()\n    if state is not None:\n        for observer in self.observers:\n            observer.report_state_updated(state)\n</code></pre>"},{"location":"reference/view/report_state_publisher/#src.view.report_state_publisher.ReportStatePublisher.subscribe","title":"<code>subscribe(observer)</code>","text":"<p>Subscribe a new observer to state updates.</p> <p>Parameters:</p> Name Type Description Default <code>observer</code> <code>BaseReportObserver</code> <p>the observer to listen for state updates.</p> required Source code in <code>src/view/report_state_publisher.py</code> <pre><code>def subscribe(self, observer: BaseReportObserver) -&gt; None:\n    \"\"\"Subscribe a new observer to state updates.\n\n    Args:\n        observer (BaseReportObserver): the observer to listen for state\n            updates.\n    \"\"\"\n    self.observers.append(observer)\n    if self.latest_state is not None:\n        observer.report_state_updated(self.latest_state)\n</code></pre>"},{"location":"reference/view/state_publisher/","title":"State Publisher","text":""},{"location":"reference/view/state_publisher/#src.view.state_publisher.BaseStateObserver","title":"<code>BaseStateObserver</code>","text":"<p>             Bases: <code>object</code></p> <p>The base class for state observers.</p> Source code in <code>src/view/state_publisher.py</code> <pre><code>class BaseStateObserver(object):\n    \"\"\"The base class for state observers.\"\"\"\n\n    def state_updated(self, state: StateDescription) -&gt; None:\n        \"\"\"Handle state update events.\n\n        Args:\n            state (StateDescription): the new state\n\n        Raises:\n            NotImplementedError: If the method is not overridden by a concrete\n                observer.\n        \"\"\"\n        self.__throw_not_implemented()\n\n    def __throw_not_implemented(self):\n        raise NotImplementedError(\n            \"This method should be overridden by a concrete observer\"\n        )\n</code></pre>"},{"location":"reference/view/state_publisher/#src.view.state_publisher.BaseStateObserver.state_updated","title":"<code>state_updated(state)</code>","text":"<p>Handle state update events.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>StateDescription</code> <p>the new state</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the method is not overridden by a concrete observer.</p> Source code in <code>src/view/state_publisher.py</code> <pre><code>def state_updated(self, state: StateDescription) -&gt; None:\n    \"\"\"Handle state update events.\n\n    Args:\n        state (StateDescription): the new state\n\n    Raises:\n        NotImplementedError: If the method is not overridden by a concrete\n            observer.\n    \"\"\"\n    self.__throw_not_implemented()\n</code></pre>"},{"location":"reference/view/state_publisher/#src.view.state_publisher.StatePublisher","title":"<code>StatePublisher</code>","text":"<p>             Bases: <code>object</code></p> <p>Publisher class for state updates.</p> Source code in <code>src/view/state_publisher.py</code> <pre><code>class StatePublisher(object):\n    \"\"\"Publisher class for state updates.\"\"\"\n\n    def __init__(\n        self, parent: QWidget, controller: LearningSystemController\n    ) -&gt; None:\n        \"\"\"Initialise a new state publisher.\n\n        Args:\n            parent (QWidget): the widget that this publisher is associated with.\n                timers do not work without this.\n            controller (LearningSystemController): the controller to listen for\n                state update from.\n        \"\"\"\n        timer = QTimer(parent)\n        timer.timeout.connect(self.check_for_updates)\n        timer.start(1)\n\n        self.update_bridge = controller.state_update_bridge\n\n        self.observers: list[BaseStateObserver] = []\n\n        # used to provided initial state\n        self.latest_state: Optional[StateDescription] = None\n\n        # start updates\n        controller.user_action_bridge.submit_action(\n            UserAction.fetch_current_state\n        )\n\n    def subscribe(self, observer: BaseStateObserver) -&gt; None:\n        \"\"\"Subscribe a new observer to state updates.\n\n        Args:\n            observer (BaseStateObserver): the observer to listen for state\n                updates.\n        \"\"\"\n        self.observers.append(observer)\n        if self.latest_state is not None:\n            observer.state_updated(self.latest_state)\n\n    def check_for_updates(self):\n        \"\"\"Check if any updates to the UI are requested.\"\"\"\n        state = self.update_bridge.get_latest_state()\n        if state is not None:\n            for observer in self.observers:\n                observer.state_updated(state)\n</code></pre>"},{"location":"reference/view/state_publisher/#src.view.state_publisher.StatePublisher.__init__","title":"<code>__init__(parent, controller)</code>","text":"<p>Initialise a new state publisher.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>the widget that this publisher is associated with. timers do not work without this.</p> required <code>controller</code> <code>LearningSystemController</code> <p>the controller to listen for state update from.</p> required Source code in <code>src/view/state_publisher.py</code> <pre><code>def __init__(\n    self, parent: QWidget, controller: LearningSystemController\n) -&gt; None:\n    \"\"\"Initialise a new state publisher.\n\n    Args:\n        parent (QWidget): the widget that this publisher is associated with.\n            timers do not work without this.\n        controller (LearningSystemController): the controller to listen for\n            state update from.\n    \"\"\"\n    timer = QTimer(parent)\n    timer.timeout.connect(self.check_for_updates)\n    timer.start(1)\n\n    self.update_bridge = controller.state_update_bridge\n\n    self.observers: list[BaseStateObserver] = []\n\n    # used to provided initial state\n    self.latest_state: Optional[StateDescription] = None\n\n    # start updates\n    controller.user_action_bridge.submit_action(\n        UserAction.fetch_current_state\n    )\n</code></pre>"},{"location":"reference/view/state_publisher/#src.view.state_publisher.StatePublisher.check_for_updates","title":"<code>check_for_updates()</code>","text":"<p>Check if any updates to the UI are requested.</p> Source code in <code>src/view/state_publisher.py</code> <pre><code>def check_for_updates(self):\n    \"\"\"Check if any updates to the UI are requested.\"\"\"\n    state = self.update_bridge.get_latest_state()\n    if state is not None:\n        for observer in self.observers:\n            observer.state_updated(state)\n</code></pre>"},{"location":"reference/view/state_publisher/#src.view.state_publisher.StatePublisher.subscribe","title":"<code>subscribe(observer)</code>","text":"<p>Subscribe a new observer to state updates.</p> <p>Parameters:</p> Name Type Description Default <code>observer</code> <code>BaseStateObserver</code> <p>the observer to listen for state updates.</p> required Source code in <code>src/view/state_publisher.py</code> <pre><code>def subscribe(self, observer: BaseStateObserver) -&gt; None:\n    \"\"\"Subscribe a new observer to state updates.\n\n    Args:\n        observer (BaseStateObserver): the observer to listen for state\n            updates.\n    \"\"\"\n    self.observers.append(observer)\n    if self.latest_state is not None:\n        observer.state_updated(self.latest_state)\n</code></pre>"},{"location":"reference/view/view_root_v2/","title":"View Root V2","text":""},{"location":"reference/view/view_root_v2/#src.view.view_root_v2.ReinforcementLearningApp","title":"<code>ReinforcementLearningApp</code>","text":"<p>             Bases: <code>QWidget</code></p> <p>This is the root of the applications main UI.</p> Source code in <code>src/view/view_root_v2.py</code> <pre><code>class ReinforcementLearningApp(QWidget):\n    \"\"\"This is the root of the applications main UI.\"\"\"\n\n    def __init__(\n        self,\n        main_controller: LearningSystemController,\n        report_controller: HyperParameterController,\n    ) -&gt; None:\n        \"\"\"Instantiate the applications user interface.\n\n        Args:\n            main_controller (LearningSystemController): the controller\n                responsible for managing the main learning system.\n            report_controller (HyperParameterController): the controller\n                responsible for creating reports.\n        \"\"\"\n        super().__init__(parent=None, f=Qt.WindowType.Window)\n        self.setWindowTitle(\"RHUL MSci FYP - Reinforcement Learning App\")\n        self.setup_config()\n\n        self.publisher = StatePublisher(self, main_controller)\n        layout = QGridLayout(self)\n\n        control_factory = ControlFactory(main_controller, self.publisher)\n\n        self.option_controls = OptionControls(self, control_factory)\n        layout.addWidget(self.option_controls, 0, 0)\n\n        self.main_tab_area = MainTabArea(\n            self, self.publisher, report_controller\n        )\n        layout.addWidget(self.main_tab_area, 1, 0)\n        layout.setRowStretch(1, 1)\n\n        self.interaction_controls = InteractionControls(self, control_factory)\n        layout.addWidget(self.interaction_controls, 2, 0)\n\n    def setup_config(self):\n        \"\"\"Set app properties from config.\"\"\"\n        config = ConfigReader().gui\n        setup_theme(config.appearance_mode)\n        width, height = config.initial_size\n        self.resize(width, height)\n</code></pre>"},{"location":"reference/view/view_root_v2/#src.view.view_root_v2.ReinforcementLearningApp.__init__","title":"<code>__init__(main_controller, report_controller)</code>","text":"<p>Instantiate the applications user interface.</p> <p>Parameters:</p> Name Type Description Default <code>main_controller</code> <code>LearningSystemController</code> <p>the controller responsible for managing the main learning system.</p> required <code>report_controller</code> <code>HyperParameterController</code> <p>the controller responsible for creating reports.</p> required Source code in <code>src/view/view_root_v2.py</code> <pre><code>def __init__(\n    self,\n    main_controller: LearningSystemController,\n    report_controller: HyperParameterController,\n) -&gt; None:\n    \"\"\"Instantiate the applications user interface.\n\n    Args:\n        main_controller (LearningSystemController): the controller\n            responsible for managing the main learning system.\n        report_controller (HyperParameterController): the controller\n            responsible for creating reports.\n    \"\"\"\n    super().__init__(parent=None, f=Qt.WindowType.Window)\n    self.setWindowTitle(\"RHUL MSci FYP - Reinforcement Learning App\")\n    self.setup_config()\n\n    self.publisher = StatePublisher(self, main_controller)\n    layout = QGridLayout(self)\n\n    control_factory = ControlFactory(main_controller, self.publisher)\n\n    self.option_controls = OptionControls(self, control_factory)\n    layout.addWidget(self.option_controls, 0, 0)\n\n    self.main_tab_area = MainTabArea(\n        self, self.publisher, report_controller\n    )\n    layout.addWidget(self.main_tab_area, 1, 0)\n    layout.setRowStretch(1, 1)\n\n    self.interaction_controls = InteractionControls(self, control_factory)\n    layout.addWidget(self.interaction_controls, 2, 0)\n</code></pre>"},{"location":"reference/view/view_root_v2/#src.view.view_root_v2.ReinforcementLearningApp.setup_config","title":"<code>setup_config()</code>","text":"<p>Set app properties from config.</p> Source code in <code>src/view/view_root_v2.py</code> <pre><code>def setup_config(self):\n    \"\"\"Set app properties from config.\"\"\"\n    config = ConfigReader().gui\n    setup_theme(config.appearance_mode)\n    width, height = config.initial_size\n    self.resize(width, height)\n</code></pre>"},{"location":"reference/view/visibility_observer/","title":"Visibility Observer","text":""},{"location":"reference/view/visibility_observer/#src.view.visibility_observer.BaseVisibilityObserver","title":"<code>BaseVisibilityObserver</code>","text":"<p>             Bases: <code>QWidget</code>, <code>BaseStateObserver</code></p> <p>Class that should observe state updates only while visible.</p> <p>This class avoids wasted work on updates that might not be visible.</p> Source code in <code>src/view/visibility_observer.py</code> <pre><code>class BaseVisibilityObserver(QWidget, BaseStateObserver):\n    \"\"\"Class that should observe state updates only while visible.\n\n    This class avoids wasted work on updates that might not be visible.\n    \"\"\"\n\n    def __init__(self, parent: QWidget | None) -&gt; None:\n        \"\"\"Initialise the observer.\n\n        Args:\n            parent (QWidget | None): The parent widget.\n        \"\"\"\n        super().__init__(parent)\n\n        self._missing_ui_state_update: Optional[StateDescription] = None\n\n    @override\n    def showEvent(self, event: QShowEvent) -&gt; None:  # noqa: N802\n        \"\"\"Handle the show event, necessary if there have been missed updates.\n\n        Args:\n            event (QShowEvent): the show event information.\n        \"\"\"\n        if self._missing_ui_state_update is not None:\n            self.visible_state_updated(self._missing_ui_state_update)\n            self._missing_ui_state_update = None\n        super().showEvent(event)\n\n    def state_updated(self, state: StateDescription) -&gt; None:\n        \"\"\"Handle the state update event.\n\n        Args:\n            state (StateDescription): the new state.\n        \"\"\"\n        if self.isVisible():\n            self.visible_state_updated(state)\n        else:\n            self._missing_ui_state_update = state\n\n    def visible_state_updated(self, state: StateDescription) -&gt; None:\n        \"\"\"Handle the state update only when visible.\n\n        Args:\n            state (StateDescription): the new state.\n\n        Raises:\n            NotImplementedError: if the method is not overridden in the concrete\n                class.\n        \"\"\"\n        raise NotImplementedError(\"Not implemented\")\n</code></pre>"},{"location":"reference/view/visibility_observer/#src.view.visibility_observer.BaseVisibilityObserver.__init__","title":"<code>__init__(parent)</code>","text":"<p>Initialise the observer.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget | None</code> <p>The parent widget.</p> required Source code in <code>src/view/visibility_observer.py</code> <pre><code>def __init__(self, parent: QWidget | None) -&gt; None:\n    \"\"\"Initialise the observer.\n\n    Args:\n        parent (QWidget | None): The parent widget.\n    \"\"\"\n    super().__init__(parent)\n\n    self._missing_ui_state_update: Optional[StateDescription] = None\n</code></pre>"},{"location":"reference/view/visibility_observer/#src.view.visibility_observer.BaseVisibilityObserver.showEvent","title":"<code>showEvent(event)</code>","text":"<p>Handle the show event, necessary if there have been missed updates.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>QShowEvent</code> <p>the show event information.</p> required Source code in <code>src/view/visibility_observer.py</code> <pre><code>@override\ndef showEvent(self, event: QShowEvent) -&gt; None:  # noqa: N802\n    \"\"\"Handle the show event, necessary if there have been missed updates.\n\n    Args:\n        event (QShowEvent): the show event information.\n    \"\"\"\n    if self._missing_ui_state_update is not None:\n        self.visible_state_updated(self._missing_ui_state_update)\n        self._missing_ui_state_update = None\n    super().showEvent(event)\n</code></pre>"},{"location":"reference/view/visibility_observer/#src.view.visibility_observer.BaseVisibilityObserver.state_updated","title":"<code>state_updated(state)</code>","text":"<p>Handle the state update event.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>StateDescription</code> <p>the new state.</p> required Source code in <code>src/view/visibility_observer.py</code> <pre><code>def state_updated(self, state: StateDescription) -&gt; None:\n    \"\"\"Handle the state update event.\n\n    Args:\n        state (StateDescription): the new state.\n    \"\"\"\n    if self.isVisible():\n        self.visible_state_updated(state)\n    else:\n        self._missing_ui_state_update = state\n</code></pre>"},{"location":"reference/view/visibility_observer/#src.view.visibility_observer.BaseVisibilityObserver.visible_state_updated","title":"<code>visible_state_updated(state)</code>","text":"<p>Handle the state update only when visible.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>StateDescription</code> <p>the new state.</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>if the method is not overridden in the concrete class.</p> Source code in <code>src/view/visibility_observer.py</code> <pre><code>def visible_state_updated(self, state: StateDescription) -&gt; None:\n    \"\"\"Handle the state update only when visible.\n\n    Args:\n        state (StateDescription): the new state.\n\n    Raises:\n        NotImplementedError: if the method is not overridden in the concrete\n            class.\n    \"\"\"\n    raise NotImplementedError(\"Not implemented\")\n</code></pre>"},{"location":"reference/view/controls/","title":"Controls","text":"<p>This package contains control widgets.</p> <p>These custom controls are setup to notify the controller</p>"},{"location":"reference/view/controls/control_factory/","title":"Control Factory","text":""},{"location":"reference/view/controls/control_factory/#src.view.controls.control_factory.ControlFactory","title":"<code>ControlFactory</code>","text":"<p>             Bases: <code>object</code></p> <p>Factory class for creating controls.</p> Source code in <code>src/view/controls/control_factory.py</code> <pre><code>class ControlFactory(object):\n    \"\"\"Factory class for creating controls.\"\"\"\n\n    def __init__(\n        self,\n        controller: LearningSystemController,\n        state_update_publisher: StatePublisher,\n    ) -&gt; None:\n        \"\"\"Initialise the factory.\n\n        Args:\n            controller (LearningSystemController): the controller these controls\n                should be connected to.\n            state_update_publisher (StatePublisher): the publisher used by\n                reactive controls.\n        \"\"\"\n        self.controller = controller\n        self.state_update_publisher = state_update_publisher\n\n    def create_button(\n        self,\n        parent: QWidget,\n        text: str,\n        action: UserAction,\n        responsive_text_handler: Optional[responsive_text_handler_type] = None,\n    ) -&gt; CustomButtonWidget:\n        \"\"\"Create the Button widget.\n\n        Args:\n            parent (QWidget): the parent of this widget\n            text (str): the text to display\n            action (UserAction): the action this button should perform when\n                pressed.\n            responsive_text_handler (Optional[responsive_text_handler_type]): an\n                additional property that can be provided to update the text\n                dynamically.\n\n        Returns:\n            CustomButtonWidget: the connected widget.\n        \"\"\"\n        widget = CustomButtonWidget(parent, text, action, self.controller)\n\n        if responsive_text_handler is not None:\n            widget.set_responsive_handler(responsive_text_handler)\n            self.state_update_publisher.subscribe(widget)\n        return widget\n\n    def create_combo(\n        self,\n        parent: QWidget,\n        state: ComboWidgetState,\n        action: UserAction,\n        responsive_options_handler: handler_type,\n    ) -&gt; CustomComboWidget:\n        \"\"\"Create combo box widget with given state.\n\n        Args:\n            parent (QWidget): the parent widget this widget should be rendered\n                into.\n            state (ComboWidgetState): the initial state of the widget\n            action (UserAction): The user action this combo box corresponds to\n            responsive_options_handler (handler_type): an optional\n                handler to make this combo box responsive to state updates.\n\n        Returns:\n            CustomComboWidget: the connected widget.\n        \"\"\"\n        widget = CustomComboWidget(parent, state, action, self.controller)\n        if responsive_options_handler is not None:\n            widget.set_responsive_options_handler(responsive_options_handler)\n            self.state_update_publisher.subscribe(widget)\n\n        return widget\n</code></pre>"},{"location":"reference/view/controls/control_factory/#src.view.controls.control_factory.ControlFactory.__init__","title":"<code>__init__(controller, state_update_publisher)</code>","text":"<p>Initialise the factory.</p> <p>Parameters:</p> Name Type Description Default <code>controller</code> <code>LearningSystemController</code> <p>the controller these controls should be connected to.</p> required <code>state_update_publisher</code> <code>StatePublisher</code> <p>the publisher used by reactive controls.</p> required Source code in <code>src/view/controls/control_factory.py</code> <pre><code>def __init__(\n    self,\n    controller: LearningSystemController,\n    state_update_publisher: StatePublisher,\n) -&gt; None:\n    \"\"\"Initialise the factory.\n\n    Args:\n        controller (LearningSystemController): the controller these controls\n            should be connected to.\n        state_update_publisher (StatePublisher): the publisher used by\n            reactive controls.\n    \"\"\"\n    self.controller = controller\n    self.state_update_publisher = state_update_publisher\n</code></pre>"},{"location":"reference/view/controls/control_factory/#src.view.controls.control_factory.ControlFactory.create_button","title":"<code>create_button(parent, text, action, responsive_text_handler=None)</code>","text":"<p>Create the Button widget.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>the parent of this widget</p> required <code>text</code> <code>str</code> <p>the text to display</p> required <code>action</code> <code>UserAction</code> <p>the action this button should perform when pressed.</p> required <code>responsive_text_handler</code> <code>Optional[responsive_text_handler_type]</code> <p>an additional property that can be provided to update the text dynamically.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>CustomButtonWidget</code> <code>CustomButtonWidget</code> <p>the connected widget.</p> Source code in <code>src/view/controls/control_factory.py</code> <pre><code>def create_button(\n    self,\n    parent: QWidget,\n    text: str,\n    action: UserAction,\n    responsive_text_handler: Optional[responsive_text_handler_type] = None,\n) -&gt; CustomButtonWidget:\n    \"\"\"Create the Button widget.\n\n    Args:\n        parent (QWidget): the parent of this widget\n        text (str): the text to display\n        action (UserAction): the action this button should perform when\n            pressed.\n        responsive_text_handler (Optional[responsive_text_handler_type]): an\n            additional property that can be provided to update the text\n            dynamically.\n\n    Returns:\n        CustomButtonWidget: the connected widget.\n    \"\"\"\n    widget = CustomButtonWidget(parent, text, action, self.controller)\n\n    if responsive_text_handler is not None:\n        widget.set_responsive_handler(responsive_text_handler)\n        self.state_update_publisher.subscribe(widget)\n    return widget\n</code></pre>"},{"location":"reference/view/controls/control_factory/#src.view.controls.control_factory.ControlFactory.create_combo","title":"<code>create_combo(parent, state, action, responsive_options_handler)</code>","text":"<p>Create combo box widget with given state.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>the parent widget this widget should be rendered into.</p> required <code>state</code> <code>ComboWidgetState</code> <p>the initial state of the widget</p> required <code>action</code> <code>UserAction</code> <p>The user action this combo box corresponds to</p> required <code>responsive_options_handler</code> <code>handler_type</code> <p>an optional handler to make this combo box responsive to state updates.</p> required <p>Returns:</p> Name Type Description <code>CustomComboWidget</code> <code>CustomComboWidget</code> <p>the connected widget.</p> Source code in <code>src/view/controls/control_factory.py</code> <pre><code>def create_combo(\n    self,\n    parent: QWidget,\n    state: ComboWidgetState,\n    action: UserAction,\n    responsive_options_handler: handler_type,\n) -&gt; CustomComboWidget:\n    \"\"\"Create combo box widget with given state.\n\n    Args:\n        parent (QWidget): the parent widget this widget should be rendered\n            into.\n        state (ComboWidgetState): the initial state of the widget\n        action (UserAction): The user action this combo box corresponds to\n        responsive_options_handler (handler_type): an optional\n            handler to make this combo box responsive to state updates.\n\n    Returns:\n        CustomComboWidget: the connected widget.\n    \"\"\"\n    widget = CustomComboWidget(parent, state, action, self.controller)\n    if responsive_options_handler is not None:\n        widget.set_responsive_options_handler(responsive_options_handler)\n        self.state_update_publisher.subscribe(widget)\n\n    return widget\n</code></pre>"},{"location":"reference/view/controls/custom_button_widget/","title":"Custom Button Widget","text":""},{"location":"reference/view/controls/custom_button_widget/#src.view.controls.custom_button_widget.CustomButtonWidget","title":"<code>CustomButtonWidget</code>","text":"<p>             Bases: <code>QPushButton</code>, <code>BaseStateObserver</code></p> <p>Custom Button widget configured to update the controller.</p> Source code in <code>src/view/controls/custom_button_widget.py</code> <pre><code>class CustomButtonWidget(QPushButton, BaseStateObserver):\n    \"\"\"Custom Button widget configured to update the controller.\"\"\"\n\n    def __init__(\n        self,\n        parent: QWidget,\n        text: str,\n        action: UserAction,\n        controller: LearningSystemController,\n    ):\n        \"\"\"Initialise the Button widget.\n\n        Args:\n            parent (QWidget): the parent of this widget\n            text (str): the text to display\n            action (UserAction): the action this button should perform when\n                pressed.\n            controller (LearningSystemController): the controller to notify.\n        \"\"\"\n        super().__init__(text, parent)\n        self.action = action\n        self.controller = controller\n\n        self.clicked.connect(self.__click_handler)\n\n        self.responsive_text_handler: Optional[\n            responsive_text_handler_type\n        ] = None\n\n    def set_responsive_handler(\n        self, responsive_text_handler: responsive_text_handler_type\n    ):\n        \"\"\"Set the handler for responsive text.\n\n        Args:\n            responsive_text_handler (responsive_text_handler_type): the method\n                for generating the buttons text.\n        \"\"\"\n        self.responsive_text_handler = responsive_text_handler\n\n    @override\n    def state_updated(self, state: StateDescription) -&gt; None:\n        \"\"\"Handle state update events.\n\n        Args:\n            state (StateDescription): the new state\n        \"\"\"\n        if self.responsive_text_handler is not None:\n            text = self.responsive_text_handler(state)\n            self.setText(text)\n\n    def __click_handler(self) -&gt; None:\n        \"\"\"Update the controller when a click is registered.\"\"\"\n        self.controller.user_action_bridge.submit_action(self.action)\n</code></pre>"},{"location":"reference/view/controls/custom_button_widget/#src.view.controls.custom_button_widget.CustomButtonWidget.__click_handler","title":"<code>__click_handler()</code>","text":"<p>Update the controller when a click is registered.</p> Source code in <code>src/view/controls/custom_button_widget.py</code> <pre><code>def __click_handler(self) -&gt; None:\n    \"\"\"Update the controller when a click is registered.\"\"\"\n    self.controller.user_action_bridge.submit_action(self.action)\n</code></pre>"},{"location":"reference/view/controls/custom_button_widget/#src.view.controls.custom_button_widget.CustomButtonWidget.__init__","title":"<code>__init__(parent, text, action, controller)</code>","text":"<p>Initialise the Button widget.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>the parent of this widget</p> required <code>text</code> <code>str</code> <p>the text to display</p> required <code>action</code> <code>UserAction</code> <p>the action this button should perform when pressed.</p> required <code>controller</code> <code>LearningSystemController</code> <p>the controller to notify.</p> required Source code in <code>src/view/controls/custom_button_widget.py</code> <pre><code>def __init__(\n    self,\n    parent: QWidget,\n    text: str,\n    action: UserAction,\n    controller: LearningSystemController,\n):\n    \"\"\"Initialise the Button widget.\n\n    Args:\n        parent (QWidget): the parent of this widget\n        text (str): the text to display\n        action (UserAction): the action this button should perform when\n            pressed.\n        controller (LearningSystemController): the controller to notify.\n    \"\"\"\n    super().__init__(text, parent)\n    self.action = action\n    self.controller = controller\n\n    self.clicked.connect(self.__click_handler)\n\n    self.responsive_text_handler: Optional[\n        responsive_text_handler_type\n    ] = None\n</code></pre>"},{"location":"reference/view/controls/custom_button_widget/#src.view.controls.custom_button_widget.CustomButtonWidget.set_responsive_handler","title":"<code>set_responsive_handler(responsive_text_handler)</code>","text":"<p>Set the handler for responsive text.</p> <p>Parameters:</p> Name Type Description Default <code>responsive_text_handler</code> <code>responsive_text_handler_type</code> <p>the method for generating the buttons text.</p> required Source code in <code>src/view/controls/custom_button_widget.py</code> <pre><code>def set_responsive_handler(\n    self, responsive_text_handler: responsive_text_handler_type\n):\n    \"\"\"Set the handler for responsive text.\n\n    Args:\n        responsive_text_handler (responsive_text_handler_type): the method\n            for generating the buttons text.\n    \"\"\"\n    self.responsive_text_handler = responsive_text_handler\n</code></pre>"},{"location":"reference/view/controls/custom_button_widget/#src.view.controls.custom_button_widget.CustomButtonWidget.state_updated","title":"<code>state_updated(state)</code>","text":"<p>Handle state update events.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>StateDescription</code> <p>the new state</p> required Source code in <code>src/view/controls/custom_button_widget.py</code> <pre><code>@override\ndef state_updated(self, state: StateDescription) -&gt; None:\n    \"\"\"Handle state update events.\n\n    Args:\n        state (StateDescription): the new state\n    \"\"\"\n    if self.responsive_text_handler is not None:\n        text = self.responsive_text_handler(state)\n        self.setText(text)\n</code></pre>"},{"location":"reference/view/controls/custom_combo_widget/","title":"Custom Combo Widget","text":""},{"location":"reference/view/controls/custom_combo_widget/#src.view.controls.custom_combo_widget.ComboWidgetState","title":"<code>ComboWidgetState</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Generic[Option]</code></p> <p>Class that represents the configuration of a combo box.</p> Source code in <code>src/view/controls/custom_combo_widget.py</code> <pre><code>@dataclass(frozen=True)\nclass ComboWidgetState(Generic[Option]):\n    \"\"\"Class that represents the configuration of a combo box.\"\"\"\n\n    options: DisplayTextListing[Option]\n    selected_option: Option\n    enabled: bool = True\n</code></pre>"},{"location":"reference/view/controls/custom_combo_widget/#src.view.controls.custom_combo_widget.CustomComboWidget","title":"<code>CustomComboWidget</code>","text":"<p>             Bases: <code>QComboBox</code>, <code>BaseStateObserver</code></p> <p>Extension of a combo box widget to provide update functionality.</p> Source code in <code>src/view/controls/custom_combo_widget.py</code> <pre><code>class CustomComboWidget(QComboBox, BaseStateObserver):\n    \"\"\"Extension of a combo box widget to provide update functionality.\"\"\"\n\n    def __init__(\n        self,\n        parent: QWidget,\n        state: ComboWidgetState,\n        action: UserAction,\n        controller: LearningSystemController,\n    ) -&gt; None:\n        \"\"\"Initialise the combo box widget.\n\n        Args:\n            parent (QWidget): the parent widget this widget should be rendered\n                into.\n            state (ComboWidgetState): The configuration of the combo box.\n            action (UserAction): The user action this combo box corresponds to\n            controller (LearningSystemController): the controller to update when\n                the user selects something.\n        \"\"\"\n        super().__init__(parent)\n        self.state = state\n        self.__set_state(state)\n        self.action = action\n        self.controller = controller\n\n        self.responsive_options_handler: Optional[handler_type] = None\n\n        self.currentTextChanged.connect(self.update_handler)\n\n        self.reset_guard = False\n\n    def set_responsive_options_handler(\n        self, responsive_options_handler: handler_type\n    ):\n        \"\"\"Set the handler for responsive options.\n\n        Args:\n            responsive_options_handler (handler_type): he method\n                for generating the options.\n        \"\"\"\n        self.responsive_options_handler = responsive_options_handler\n\n    @override\n    def state_updated(self, state: StateDescription) -&gt; None:\n        \"\"\"Handle state update events.\n\n        Args:\n            state (StateDescription): the new state\n        \"\"\"\n        if self.responsive_options_handler is not None:\n            combo_state = self.responsive_options_handler(state)\n            if combo_state == self.state:\n                return\n            self.__set_state(combo_state)\n\n    def update_handler(self, text: str) -&gt; None:\n        \"\"\"Handle update, send the appropriate request to the user.\n\n        Args:\n            text (str): the option that has been selected.\n        \"\"\"\n        if self.reset_guard:\n            return\n        self.controller.user_action_bridge.submit_action(\n            self.action, self.state.options.get_option(text)\n        )\n\n    def __set_state(self, state: ComboWidgetState):\n        self.reset_guard = True\n        self.state = state\n        self.clear()\n        self.addItems(state.options.list_all_text())\n        current_text = state.options.get_text(state.selected_option)\n        self.setCurrentText(current_text)\n        self.setEnabled(state.enabled)\n        self.reset_guard = False\n</code></pre>"},{"location":"reference/view/controls/custom_combo_widget/#src.view.controls.custom_combo_widget.CustomComboWidget.__init__","title":"<code>__init__(parent, state, action, controller)</code>","text":"<p>Initialise the combo box widget.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>the parent widget this widget should be rendered into.</p> required <code>state</code> <code>ComboWidgetState</code> <p>The configuration of the combo box.</p> required <code>action</code> <code>UserAction</code> <p>The user action this combo box corresponds to</p> required <code>controller</code> <code>LearningSystemController</code> <p>the controller to update when the user selects something.</p> required Source code in <code>src/view/controls/custom_combo_widget.py</code> <pre><code>def __init__(\n    self,\n    parent: QWidget,\n    state: ComboWidgetState,\n    action: UserAction,\n    controller: LearningSystemController,\n) -&gt; None:\n    \"\"\"Initialise the combo box widget.\n\n    Args:\n        parent (QWidget): the parent widget this widget should be rendered\n            into.\n        state (ComboWidgetState): The configuration of the combo box.\n        action (UserAction): The user action this combo box corresponds to\n        controller (LearningSystemController): the controller to update when\n            the user selects something.\n    \"\"\"\n    super().__init__(parent)\n    self.state = state\n    self.__set_state(state)\n    self.action = action\n    self.controller = controller\n\n    self.responsive_options_handler: Optional[handler_type] = None\n\n    self.currentTextChanged.connect(self.update_handler)\n\n    self.reset_guard = False\n</code></pre>"},{"location":"reference/view/controls/custom_combo_widget/#src.view.controls.custom_combo_widget.CustomComboWidget.set_responsive_options_handler","title":"<code>set_responsive_options_handler(responsive_options_handler)</code>","text":"<p>Set the handler for responsive options.</p> <p>Parameters:</p> Name Type Description Default <code>responsive_options_handler</code> <code>handler_type</code> <p>he method for generating the options.</p> required Source code in <code>src/view/controls/custom_combo_widget.py</code> <pre><code>def set_responsive_options_handler(\n    self, responsive_options_handler: handler_type\n):\n    \"\"\"Set the handler for responsive options.\n\n    Args:\n        responsive_options_handler (handler_type): he method\n            for generating the options.\n    \"\"\"\n    self.responsive_options_handler = responsive_options_handler\n</code></pre>"},{"location":"reference/view/controls/custom_combo_widget/#src.view.controls.custom_combo_widget.CustomComboWidget.state_updated","title":"<code>state_updated(state)</code>","text":"<p>Handle state update events.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>StateDescription</code> <p>the new state</p> required Source code in <code>src/view/controls/custom_combo_widget.py</code> <pre><code>@override\ndef state_updated(self, state: StateDescription) -&gt; None:\n    \"\"\"Handle state update events.\n\n    Args:\n        state (StateDescription): the new state\n    \"\"\"\n    if self.responsive_options_handler is not None:\n        combo_state = self.responsive_options_handler(state)\n        if combo_state == self.state:\n            return\n        self.__set_state(combo_state)\n</code></pre>"},{"location":"reference/view/controls/custom_combo_widget/#src.view.controls.custom_combo_widget.CustomComboWidget.update_handler","title":"<code>update_handler(text)</code>","text":"<p>Handle update, send the appropriate request to the user.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>the option that has been selected.</p> required Source code in <code>src/view/controls/custom_combo_widget.py</code> <pre><code>def update_handler(self, text: str) -&gt; None:\n    \"\"\"Handle update, send the appropriate request to the user.\n\n    Args:\n        text (str): the option that has been selected.\n    \"\"\"\n    if self.reset_guard:\n        return\n    self.controller.user_action_bridge.submit_action(\n        self.action, self.state.options.get_option(text)\n    )\n</code></pre>"},{"location":"reference/view/display_state_v2/","title":"Display State V2","text":"<p>This package provides the code needed to render the grid world.</p> <p>It contains the top level widget to display this grid world scene to the user.</p>"},{"location":"reference/view/display_state_v2/display/","title":"Display","text":""},{"location":"reference/view/display_state_v2/display/#src.view.display_state_v2.display.DisplayState","title":"<code>DisplayState</code>","text":"<p>             Bases: <code>BaseVisibilityObserver</code></p> <p>Widget for displaying a given grid world state.</p> Source code in <code>src/view/display_state_v2/display.py</code> <pre><code>class DisplayState(BaseVisibilityObserver):\n    \"\"\"Widget for displaying a given grid world state.\"\"\"\n\n    padding = 10\n\n    cell_margins = 0.1\n    background_color = (200, 200, 200, 0)\n\n    def __init__(self, parent: Optional[QWidget]) -&gt; None:\n        \"\"\"Initialise the state display.\n\n        this widget will display a given state and update it on request.\n\n        Args:\n            parent (QWidget): the parent of this widget.\n        \"\"\"\n        super().__init__(parent)\n\n        self.image_label = QLabel(self)\n        self.image_label.setContentsMargins(0, 0, 0, 0)\n        self.image_label.setStyleSheet(\"border: 0;\")\n        self.setContentsMargins(0, 0, 0, 0)\n\n        layout = QGridLayout(self)\n        layout.setSpacing(0)\n        layout.setContentsMargins(0, 0, 0, 0)\n        layout.addWidget(self.image_label, 0, 0)\n\n        self.state: Optional[StateDescription] = None\n\n    @override\n    def visible_state_updated(self, state: StateDescription):\n        \"\"\"Handle state update events.\n\n        Args:\n            state (StateDescription): the new state\n\n        \"\"\"\n        self.state = state\n        self.__configure_grid()\n\n    @override\n    def resizeEvent(  # noqa: N802 built in method to base class\n        self, event: QResizeEvent\n    ):\n        \"\"\"Handle resize event.\n\n        resize the inner grid based upon the updated dimensions.\n\n        Args:\n            event (QResizeEvent): the resize event\n        \"\"\"\n        self.__configure_grid()\n\n    def __make_blank_image(self):\n        size = self.__get_current_size()\n        image_mode = \"RGBA\"\n        image = Image.new(image_mode, size, self.background_color)\n        image_draw = ImageDraw.Draw(image, image_mode)\n        return image, image_draw\n\n    def __configure_grid(self):\n        if self.state is None:\n            return\n        width, height = self.__get_current_size()\n        expected_cell_size = self.state.grid_world.get_cell_sizing(\n            width, height, self.cell_margins\n        )[0]\n        if expected_cell_size &lt; 10:\n            # cells are too small\n            return\n        self.__populate_cells(self.state)\n        image, image_draw = self.__make_blank_image()\n\n        for cell in self.cells.values():\n            cell.draw(image, image_draw)\n\n        self.image_label.setPixmap(QPixmap.fromImage(ImageQt(image)))\n\n    def __populate_cells(\n        self,\n        state: StateDescription,\n    ):\n        self.cells = {}\n        width, height = self.__get_current_size()\n        cell_positions = state.grid_world.list_cell_positions(\n            width, height, self.cell_margins\n        )\n\n        for cell_position in cell_positions:\n            (\n                cell_coordinate,\n                bounding_box,\n            ) = cell_position\n            self.cells[cell_coordinate] = Cell(\n                state.global_options,\n                state.cell_config[cell_coordinate],\n                bounding_box,\n            )\n\n    def __get_current_size(self):\n        width = self.image_label.contentsRect().width() - self.padding\n        height = self.image_label.contentsRect().height() - self.padding\n        return width, height\n</code></pre>"},{"location":"reference/view/display_state_v2/display/#src.view.display_state_v2.display.DisplayState.__init__","title":"<code>__init__(parent)</code>","text":"<p>Initialise the state display.</p> <p>this widget will display a given state and update it on request.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>the parent of this widget.</p> required Source code in <code>src/view/display_state_v2/display.py</code> <pre><code>def __init__(self, parent: Optional[QWidget]) -&gt; None:\n    \"\"\"Initialise the state display.\n\n    this widget will display a given state and update it on request.\n\n    Args:\n        parent (QWidget): the parent of this widget.\n    \"\"\"\n    super().__init__(parent)\n\n    self.image_label = QLabel(self)\n    self.image_label.setContentsMargins(0, 0, 0, 0)\n    self.image_label.setStyleSheet(\"border: 0;\")\n    self.setContentsMargins(0, 0, 0, 0)\n\n    layout = QGridLayout(self)\n    layout.setSpacing(0)\n    layout.setContentsMargins(0, 0, 0, 0)\n    layout.addWidget(self.image_label, 0, 0)\n\n    self.state: Optional[StateDescription] = None\n</code></pre>"},{"location":"reference/view/display_state_v2/display/#src.view.display_state_v2.display.DisplayState.resizeEvent","title":"<code>resizeEvent(event)</code>","text":"<p>Handle resize event.</p> <p>resize the inner grid based upon the updated dimensions.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>QResizeEvent</code> <p>the resize event</p> required Source code in <code>src/view/display_state_v2/display.py</code> <pre><code>@override\ndef resizeEvent(  # noqa: N802 built in method to base class\n    self, event: QResizeEvent\n):\n    \"\"\"Handle resize event.\n\n    resize the inner grid based upon the updated dimensions.\n\n    Args:\n        event (QResizeEvent): the resize event\n    \"\"\"\n    self.__configure_grid()\n</code></pre>"},{"location":"reference/view/display_state_v2/display/#src.view.display_state_v2.display.DisplayState.visible_state_updated","title":"<code>visible_state_updated(state)</code>","text":"<p>Handle state update events.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>StateDescription</code> <p>the new state</p> required Source code in <code>src/view/display_state_v2/display.py</code> <pre><code>@override\ndef visible_state_updated(self, state: StateDescription):\n    \"\"\"Handle state update events.\n\n    Args:\n        state (StateDescription): the new state\n\n    \"\"\"\n    self.state = state\n    self.__configure_grid()\n</code></pre>"},{"location":"reference/view/display_state_v2/cell/","title":"Cell","text":"<p>This package is for the drawing of a cell in the grid world view.</p>"},{"location":"reference/view/display_state_v2/cell/arrow_layer/","title":"Arrow Layer","text":""},{"location":"reference/view/display_state_v2/cell/arrow_layer/#src.view.display_state_v2.cell.arrow_layer.ArrowLayer","title":"<code>ArrowLayer</code>","text":"<p>             Bases: <code>BaseLayer</code></p> <p>The layer responsible for drawing the background of the cell.</p> Source code in <code>src/view/display_state_v2/cell/arrow_layer.py</code> <pre><code>class ArrowLayer(BaseLayer):\n    \"\"\"The layer responsible for drawing the background of the cell.\"\"\"\n\n    def draw(self):\n        \"\"\"Draw the arrow layer.\"\"\"\n        match self.options.display_mode:\n            case DisplayMode.action_value_global:\n                self.__draw_specific_arrows(\n                    self.config.action_values_normalised\n                )\n            case DisplayMode.action_value_local:\n                self.__draw_specific_arrows(\n                    self.__rescale_values_locally(\n                        self.config.action_values_raw\n                    ),\n                )\n            case _:\n                return\n\n    def __draw_specific_arrows(self, action_values: action_value_description):\n        for action, action_value in action_values.items():\n            if action_value is not None:\n                self.__draw_arrow(action, action_value)\n\n    def __draw_arrow(self, action: Action, action_value: float):\n        size = self.cell_layout.get_bounding_box_size(self.bounding_box) // 3\n        color = self.value_to_color(action_value)\n        icon = self.icon_loader.get_action_icon(action, size, color)\n\n        dir_x, dir_y = GridWorld.action_direction[action]\n\n        relative_position = ((dir_x + 1) / 2, (dir_y + 1) / 2)\n        self.draw_icon(icon, size, relative_position)\n\n    def __rescale_values_locally(\n        self, action_values: action_value_description\n    ) -&gt; action_value_description:\n        \"\"\"Rescale the action values in this cell 0-1.\n\n        this should only be based on the values in this cell rather than the\n        global range of values.\n\n        Args:\n            action_values (action_value_description): the action values of this\n                cell.\n\n        Returns:\n            action_value_description: the scaled action values in the range 0-1\n        \"\"\"\n        min_value = float(\"inf\")\n        max_value = float(\"-inf\")\n\n        for action_value in action_values.values():\n            if action_value is None:\n                continue\n            min_value = min(action_value, min_value)\n            max_value = max(action_value, max_value)\n\n        rescaled_values: action_value_description = {}\n        value_range = max_value - min_value\n        for action, action_value in action_values.items():\n            if action_value is None:\n                rescaled_values[action] = None\n                continue\n            rescaled_values[action] = (action_value - min_value) / value_range\n        return rescaled_values\n</code></pre>"},{"location":"reference/view/display_state_v2/cell/arrow_layer/#src.view.display_state_v2.cell.arrow_layer.ArrowLayer.__rescale_values_locally","title":"<code>__rescale_values_locally(action_values)</code>","text":"<p>Rescale the action values in this cell 0-1.</p> <p>this should only be based on the values in this cell rather than the global range of values.</p> <p>Parameters:</p> Name Type Description Default <code>action_values</code> <code>action_value_description</code> <p>the action values of this cell.</p> required <p>Returns:</p> Name Type Description <code>action_value_description</code> <code>action_value_description</code> <p>the scaled action values in the range 0-1</p> Source code in <code>src/view/display_state_v2/cell/arrow_layer.py</code> <pre><code>def __rescale_values_locally(\n    self, action_values: action_value_description\n) -&gt; action_value_description:\n    \"\"\"Rescale the action values in this cell 0-1.\n\n    this should only be based on the values in this cell rather than the\n    global range of values.\n\n    Args:\n        action_values (action_value_description): the action values of this\n            cell.\n\n    Returns:\n        action_value_description: the scaled action values in the range 0-1\n    \"\"\"\n    min_value = float(\"inf\")\n    max_value = float(\"-inf\")\n\n    for action_value in action_values.values():\n        if action_value is None:\n            continue\n        min_value = min(action_value, min_value)\n        max_value = max(action_value, max_value)\n\n    rescaled_values: action_value_description = {}\n    value_range = max_value - min_value\n    for action, action_value in action_values.items():\n        if action_value is None:\n            rescaled_values[action] = None\n            continue\n        rescaled_values[action] = (action_value - min_value) / value_range\n    return rescaled_values\n</code></pre>"},{"location":"reference/view/display_state_v2/cell/arrow_layer/#src.view.display_state_v2.cell.arrow_layer.ArrowLayer.draw","title":"<code>draw()</code>","text":"<p>Draw the arrow layer.</p> Source code in <code>src/view/display_state_v2/cell/arrow_layer.py</code> <pre><code>def draw(self):\n    \"\"\"Draw the arrow layer.\"\"\"\n    match self.options.display_mode:\n        case DisplayMode.action_value_global:\n            self.__draw_specific_arrows(\n                self.config.action_values_normalised\n            )\n        case DisplayMode.action_value_local:\n            self.__draw_specific_arrows(\n                self.__rescale_values_locally(\n                    self.config.action_values_raw\n                ),\n            )\n        case _:\n            return\n</code></pre>"},{"location":"reference/view/display_state_v2/cell/background_layer/","title":"Background Layer","text":""},{"location":"reference/view/display_state_v2/cell/background_layer/#src.view.display_state_v2.cell.background_layer.BackgroundLayer","title":"<code>BackgroundLayer</code>","text":"<p>             Bases: <code>BaseLayer</code></p> <p>The layer responsible for drawing the background of the cell.</p> Source code in <code>src/view/display_state_v2/cell/background_layer.py</code> <pre><code>class BackgroundLayer(BaseLayer):\n    \"\"\"The layer responsible for drawing the background of the cell.\"\"\"\n\n    default_background_color: rgb_type = (80, 80, 80)\n\n    def draw(self):\n        \"\"\"Draw the background layer.\"\"\"\n        fill, outline = self.__cell_mode_color()\n\n        self.drawing_context.rounded_rectangle(\n            self.bounding_box,\n            self.cell_layout.border_width,\n            fill=fill,\n            outline=outline,\n            width=self.cell_layout.border_width,\n        )\n\n    def __cell_mode_color(\n        self,\n    ) -&gt; Tuple[rgb_type, rgb_type]:\n        \"\"\"Get the color for the inner and outer background based on the mode.\n\n        Returns:\n            Tuple[str, str]: inner and outer color\n        \"\"\"\n        default_color = self.default_background_color\n        if self.options.display_mode is not DisplayMode.state_value:\n            return default_color, default_color\n        cell_value_color = self.__cell_color()\n\n        if self.config.cell_entity is CellEntity.empty:\n            return cell_value_color, cell_value_color\n\n        return default_color, cell_value_color\n\n    def __cell_color(self) -&gt; rgb_type:\n        \"\"\"Get the color the cell should be based upon the value.\n\n        red represents a low value and green represents a good value\n\n        Returns:\n            rgb_type: the hex color of the cell based on this value.\n        \"\"\"\n        cell_value = self.config.cell_value_normalised\n        if cell_value is None:\n            return self.default_background_color\n        return self.value_to_color(cell_value)\n</code></pre>"},{"location":"reference/view/display_state_v2/cell/background_layer/#src.view.display_state_v2.cell.background_layer.BackgroundLayer.__cell_color","title":"<code>__cell_color()</code>","text":"<p>Get the color the cell should be based upon the value.</p> <p>red represents a low value and green represents a good value</p> <p>Returns:</p> Name Type Description <code>rgb_type</code> <code>rgb_type</code> <p>the hex color of the cell based on this value.</p> Source code in <code>src/view/display_state_v2/cell/background_layer.py</code> <pre><code>def __cell_color(self) -&gt; rgb_type:\n    \"\"\"Get the color the cell should be based upon the value.\n\n    red represents a low value and green represents a good value\n\n    Returns:\n        rgb_type: the hex color of the cell based on this value.\n    \"\"\"\n    cell_value = self.config.cell_value_normalised\n    if cell_value is None:\n        return self.default_background_color\n    return self.value_to_color(cell_value)\n</code></pre>"},{"location":"reference/view/display_state_v2/cell/background_layer/#src.view.display_state_v2.cell.background_layer.BackgroundLayer.__cell_mode_color","title":"<code>__cell_mode_color()</code>","text":"<p>Get the color for the inner and outer background based on the mode.</p> <p>Returns:</p> Type Description <code>Tuple[rgb_type, rgb_type]</code> <p>Tuple[str, str]: inner and outer color</p> Source code in <code>src/view/display_state_v2/cell/background_layer.py</code> <pre><code>def __cell_mode_color(\n    self,\n) -&gt; Tuple[rgb_type, rgb_type]:\n    \"\"\"Get the color for the inner and outer background based on the mode.\n\n    Returns:\n        Tuple[str, str]: inner and outer color\n    \"\"\"\n    default_color = self.default_background_color\n    if self.options.display_mode is not DisplayMode.state_value:\n        return default_color, default_color\n    cell_value_color = self.__cell_color()\n\n    if self.config.cell_entity is CellEntity.empty:\n        return cell_value_color, cell_value_color\n\n    return default_color, cell_value_color\n</code></pre>"},{"location":"reference/view/display_state_v2/cell/background_layer/#src.view.display_state_v2.cell.background_layer.BackgroundLayer.draw","title":"<code>draw()</code>","text":"<p>Draw the background layer.</p> Source code in <code>src/view/display_state_v2/cell/background_layer.py</code> <pre><code>def draw(self):\n    \"\"\"Draw the background layer.\"\"\"\n    fill, outline = self.__cell_mode_color()\n\n    self.drawing_context.rounded_rectangle(\n        self.bounding_box,\n        self.cell_layout.border_width,\n        fill=fill,\n        outline=outline,\n        width=self.cell_layout.border_width,\n    )\n</code></pre>"},{"location":"reference/view/display_state_v2/cell/base_layer/","title":"Base Layer","text":""},{"location":"reference/view/display_state_v2/cell/base_layer/#src.view.display_state_v2.cell.base_layer.BaseLayer","title":"<code>BaseLayer</code>  <code>dataclass</code>","text":"<p>             Bases: <code>object</code></p> <p>Represents one layer of the cell's drawing.</p> Source code in <code>src/view/display_state_v2/cell/base_layer.py</code> <pre><code>@dataclass(slots=True, frozen=True)\nclass BaseLayer(object):\n    \"\"\"Represents one layer of the cell's drawing.\"\"\"\n\n    options: GlobalOptions\n    config: CellConfiguration\n    canvas: Image\n    drawing_context: ImageDraw\n    bounding_box: Tuple[int, int, int, int]\n    cell_layout: CellLayout\n    icon_loader = IconLoader()\n\n    def draw(self):\n        \"\"\"Draw this layer to the canvas.\n\n        Raises:\n            RuntimeError: if this method is not overridden.\n        \"\"\"\n        raise RuntimeError(\"Draw should be overridden by concrete class\")\n\n    def draw_icon(\n        self,\n        icon: Image,\n        size: int,\n        rel_pos: Tuple[float, float] = (0.5, 0.5),\n    ):\n        \"\"\"Draw an icon in the cell.\n\n        rel_pos is relative to the bounding box of this layer.\n\n        Args:\n            icon (Image): the icon to display\n            size (int): the size of the icon to display\n            rel_pos (Tuple[float, float], optional): the position in the cell.\n                Defaults to the centre.\n        \"\"\"\n        min_x, min_y, max_x, _max_y = self.bounding_box\n        rel_x, rel_y = rel_pos\n\n        space = max_x - min_x - size\n        location = (\n            min_x + int(rel_x * space),\n            min_y + int(rel_y * space),\n        )\n\n        icon_alpha = icon.getchannel(\"A\")\n        self.canvas.paste(icon, location, icon_alpha)\n\n    def value_to_color(self, worth: float) -&gt; rgb_type:\n        \"\"\"Convert a floating point value to a color.\n\n        Args:\n            worth (float): the value to represent in the range 0 to 1.\n\n        Returns:\n            rgb_type: the color as rgb values in the range 0-255\n        \"\"\"\n        hue = worth / 3  # Range from red to green\n        saturation = 1.0\n        lightness = 0.5\n        color_range = 255\n\n        red, green, blue = hls_to_rgb(hue, lightness, saturation)\n        return (\n            int(color_range * red),\n            int(color_range * green),\n            int(color_range * blue),\n        )\n</code></pre>"},{"location":"reference/view/display_state_v2/cell/base_layer/#src.view.display_state_v2.cell.base_layer.BaseLayer.draw","title":"<code>draw()</code>","text":"<p>Draw this layer to the canvas.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if this method is not overridden.</p> Source code in <code>src/view/display_state_v2/cell/base_layer.py</code> <pre><code>def draw(self):\n    \"\"\"Draw this layer to the canvas.\n\n    Raises:\n        RuntimeError: if this method is not overridden.\n    \"\"\"\n    raise RuntimeError(\"Draw should be overridden by concrete class\")\n</code></pre>"},{"location":"reference/view/display_state_v2/cell/base_layer/#src.view.display_state_v2.cell.base_layer.BaseLayer.draw_icon","title":"<code>draw_icon(icon, size, rel_pos=(0.5, 0.5))</code>","text":"<p>Draw an icon in the cell.</p> <p>rel_pos is relative to the bounding box of this layer.</p> <p>Parameters:</p> Name Type Description Default <code>icon</code> <code>Image</code> <p>the icon to display</p> required <code>size</code> <code>int</code> <p>the size of the icon to display</p> required <code>rel_pos</code> <code>Tuple[float, float]</code> <p>the position in the cell. Defaults to the centre.</p> <code>(0.5, 0.5)</code> Source code in <code>src/view/display_state_v2/cell/base_layer.py</code> <pre><code>def draw_icon(\n    self,\n    icon: Image,\n    size: int,\n    rel_pos: Tuple[float, float] = (0.5, 0.5),\n):\n    \"\"\"Draw an icon in the cell.\n\n    rel_pos is relative to the bounding box of this layer.\n\n    Args:\n        icon (Image): the icon to display\n        size (int): the size of the icon to display\n        rel_pos (Tuple[float, float], optional): the position in the cell.\n            Defaults to the centre.\n    \"\"\"\n    min_x, min_y, max_x, _max_y = self.bounding_box\n    rel_x, rel_y = rel_pos\n\n    space = max_x - min_x - size\n    location = (\n        min_x + int(rel_x * space),\n        min_y + int(rel_y * space),\n    )\n\n    icon_alpha = icon.getchannel(\"A\")\n    self.canvas.paste(icon, location, icon_alpha)\n</code></pre>"},{"location":"reference/view/display_state_v2/cell/base_layer/#src.view.display_state_v2.cell.base_layer.BaseLayer.value_to_color","title":"<code>value_to_color(worth)</code>","text":"<p>Convert a floating point value to a color.</p> <p>Parameters:</p> Name Type Description Default <code>worth</code> <code>float</code> <p>the value to represent in the range 0 to 1.</p> required <p>Returns:</p> Name Type Description <code>rgb_type</code> <code>rgb_type</code> <p>the color as rgb values in the range 0-255</p> Source code in <code>src/view/display_state_v2/cell/base_layer.py</code> <pre><code>def value_to_color(self, worth: float) -&gt; rgb_type:\n    \"\"\"Convert a floating point value to a color.\n\n    Args:\n        worth (float): the value to represent in the range 0 to 1.\n\n    Returns:\n        rgb_type: the color as rgb values in the range 0-255\n    \"\"\"\n    hue = worth / 3  # Range from red to green\n    saturation = 1.0\n    lightness = 0.5\n    color_range = 255\n\n    red, green, blue = hls_to_rgb(hue, lightness, saturation)\n    return (\n        int(color_range * red),\n        int(color_range * green),\n        int(color_range * blue),\n    )\n</code></pre>"},{"location":"reference/view/display_state_v2/cell/cell/","title":"Cell","text":""},{"location":"reference/view/display_state_v2/cell/cell/#src.view.display_state_v2.cell.cell.Cell","title":"<code>Cell</code>","text":"<p>             Bases: <code>object</code></p> <p>Widget to display an individual cell.</p> Source code in <code>src/view/display_state_v2/cell/cell.py</code> <pre><code>class Cell(object):\n    \"\"\"Widget to display an individual cell.\"\"\"\n\n    def __init__(\n        self,\n        options: GlobalOptions,\n        config: CellConfiguration,\n        bounding_box: Tuple[int, int, int, int],\n    ) -&gt; None:\n        \"\"\"Initialise the cell.\n\n        displays the cell as a rounded rectangle with icons.\n\n        Args:\n            options (GlobalOptions): the global configuration used in rendering\n                each cell.\n            config (CellConfiguration): the configuration of how this cell\n                should present.\n            bounding_box (Tuple[int, int, int, int]): the position and size of\n                this cell on the canvas.\n        \"\"\"\n        self.config = config\n        self.options = options\n        self.cell_layout = CellLayout(bounding_box)\n\n    def draw(\n        self,\n        canvas: Image,\n        drawing_context: ImageDraw,\n    ):\n        \"\"\"Draw the cell to the canvas.\n\n        Args:\n            canvas (Image): the image to draw to\n            drawing_context (ImageDraw): the drawing context\n        \"\"\"\n        BackgroundLayer(\n            self.options,\n            self.config,\n            canvas,\n            drawing_context,\n            self.cell_layout.bounding_box,\n            self.cell_layout,\n        ).draw()\n        MainIconLayer(\n            self.options,\n            self.config,\n            canvas,\n            drawing_context,\n            self.cell_layout.inset_bounding_box(\n                self.cell_layout.padding + self.cell_layout.border_width\n            ),\n            self.cell_layout,\n        ).draw()\n        ArrowLayer(\n            self.options,\n            self.config,\n            canvas,\n            drawing_context,\n            self.cell_layout.inset_bounding_box(self.cell_layout.padding),\n            self.cell_layout,\n        ).draw()\n</code></pre>"},{"location":"reference/view/display_state_v2/cell/cell/#src.view.display_state_v2.cell.cell.Cell.__init__","title":"<code>__init__(options, config, bounding_box)</code>","text":"<p>Initialise the cell.</p> <p>displays the cell as a rounded rectangle with icons.</p> <p>Parameters:</p> Name Type Description Default <code>options</code> <code>GlobalOptions</code> <p>the global configuration used in rendering each cell.</p> required <code>config</code> <code>CellConfiguration</code> <p>the configuration of how this cell should present.</p> required <code>bounding_box</code> <code>Tuple[int, int, int, int]</code> <p>the position and size of this cell on the canvas.</p> required Source code in <code>src/view/display_state_v2/cell/cell.py</code> <pre><code>def __init__(\n    self,\n    options: GlobalOptions,\n    config: CellConfiguration,\n    bounding_box: Tuple[int, int, int, int],\n) -&gt; None:\n    \"\"\"Initialise the cell.\n\n    displays the cell as a rounded rectangle with icons.\n\n    Args:\n        options (GlobalOptions): the global configuration used in rendering\n            each cell.\n        config (CellConfiguration): the configuration of how this cell\n            should present.\n        bounding_box (Tuple[int, int, int, int]): the position and size of\n            this cell on the canvas.\n    \"\"\"\n    self.config = config\n    self.options = options\n    self.cell_layout = CellLayout(bounding_box)\n</code></pre>"},{"location":"reference/view/display_state_v2/cell/cell/#src.view.display_state_v2.cell.cell.Cell.draw","title":"<code>draw(canvas, drawing_context)</code>","text":"<p>Draw the cell to the canvas.</p> <p>Parameters:</p> Name Type Description Default <code>canvas</code> <code>Image</code> <p>the image to draw to</p> required <code>drawing_context</code> <code>ImageDraw</code> <p>the drawing context</p> required Source code in <code>src/view/display_state_v2/cell/cell.py</code> <pre><code>def draw(\n    self,\n    canvas: Image,\n    drawing_context: ImageDraw,\n):\n    \"\"\"Draw the cell to the canvas.\n\n    Args:\n        canvas (Image): the image to draw to\n        drawing_context (ImageDraw): the drawing context\n    \"\"\"\n    BackgroundLayer(\n        self.options,\n        self.config,\n        canvas,\n        drawing_context,\n        self.cell_layout.bounding_box,\n        self.cell_layout,\n    ).draw()\n    MainIconLayer(\n        self.options,\n        self.config,\n        canvas,\n        drawing_context,\n        self.cell_layout.inset_bounding_box(\n            self.cell_layout.padding + self.cell_layout.border_width\n        ),\n        self.cell_layout,\n    ).draw()\n    ArrowLayer(\n        self.options,\n        self.config,\n        canvas,\n        drawing_context,\n        self.cell_layout.inset_bounding_box(self.cell_layout.padding),\n        self.cell_layout,\n    ).draw()\n</code></pre>"},{"location":"reference/view/display_state_v2/cell/cell_layout/","title":"Cell Layout","text":""},{"location":"reference/view/display_state_v2/cell/cell_layout/#src.view.display_state_v2.cell.cell_layout.CellLayout","title":"<code>CellLayout</code>","text":"<p>             Bases: <code>object</code></p> <p>Class for managing the layout and configuration of each cell.</p> Source code in <code>src/view/display_state_v2/cell/cell_layout.py</code> <pre><code>class CellLayout(object):\n    \"\"\"Class for managing the layout and configuration of each cell.\"\"\"\n\n    min_border_width: int = 8\n    min_padding: int = 2\n    padding_ratio: float = 0.1\n    border_ratio: float = 0.1\n\n    def __init__(self, bounding_box: Tuple[int, int, int, int]):\n        \"\"\"Initialise the cell layout.\n\n        Args:\n            bounding_box (Tuple[int, int, int, int]): the size of the cell.\n        \"\"\"\n        self.bounding_box = bounding_box\n        self.cell_size = self.get_bounding_box_size(bounding_box)\n        self.border_width = int(\n            max(self.border_ratio * self.cell_size, self.min_border_width)\n        )\n        self.padding = int(\n            max(self.padding_ratio * self.cell_size, self.min_padding)\n        )\n\n    def get_bounding_box_size(\n        self, bounding_box: Tuple[int, int, int, int]\n    ) -&gt; int:\n        \"\"\"Get the size of a bounding box.\n\n        Args:\n            bounding_box (Tuple[int, int, int, int]): the box to measure\n\n        Returns:\n            int: the minimum length along one edge.\n        \"\"\"\n        min_x, min_y, max_x, max_y = bounding_box\n\n        return min(max_x - min_x, max_y - min_y)\n\n    def contains_point(self, pos: Tuple[int, int]) -&gt; bool:\n        \"\"\"Determine weather this cell contains a point.\n\n        Checks its bounding box.\n\n        Args:\n            pos (Tuple[int, int]): the position to check\n\n        Returns:\n            bool: True if this point is in the bounding box\n        \"\"\"\n        pos_x, pos_y = pos\n        min_x, min_y, max_x, max_y = self.bounding_box\n        return min_x &lt;= pos_x &lt;= max_x and min_y &lt;= pos_y &lt;= max_y\n\n    def inset_bounding_box(\n        self, inset_amount: int\n    ) -&gt; Tuple[int, int, int, int]:\n        \"\"\"Get the bounding box that has been inset.\n\n        Args:\n            inset_amount (int): the amount to make the box smaller\n\n        Returns:\n            Tuple[int, int, int, int]: the new bounding box that has been inset\n        \"\"\"\n        min_x, min_y, max_x, max_y = self.bounding_box\n        return (\n            min_x + inset_amount,\n            min_y + inset_amount,\n            max_x - inset_amount,\n            max_y - inset_amount,\n        )\n</code></pre>"},{"location":"reference/view/display_state_v2/cell/cell_layout/#src.view.display_state_v2.cell.cell_layout.CellLayout.__init__","title":"<code>__init__(bounding_box)</code>","text":"<p>Initialise the cell layout.</p> <p>Parameters:</p> Name Type Description Default <code>bounding_box</code> <code>Tuple[int, int, int, int]</code> <p>the size of the cell.</p> required Source code in <code>src/view/display_state_v2/cell/cell_layout.py</code> <pre><code>def __init__(self, bounding_box: Tuple[int, int, int, int]):\n    \"\"\"Initialise the cell layout.\n\n    Args:\n        bounding_box (Tuple[int, int, int, int]): the size of the cell.\n    \"\"\"\n    self.bounding_box = bounding_box\n    self.cell_size = self.get_bounding_box_size(bounding_box)\n    self.border_width = int(\n        max(self.border_ratio * self.cell_size, self.min_border_width)\n    )\n    self.padding = int(\n        max(self.padding_ratio * self.cell_size, self.min_padding)\n    )\n</code></pre>"},{"location":"reference/view/display_state_v2/cell/cell_layout/#src.view.display_state_v2.cell.cell_layout.CellLayout.contains_point","title":"<code>contains_point(pos)</code>","text":"<p>Determine weather this cell contains a point.</p> <p>Checks its bounding box.</p> <p>Parameters:</p> Name Type Description Default <code>pos</code> <code>Tuple[int, int]</code> <p>the position to check</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if this point is in the bounding box</p> Source code in <code>src/view/display_state_v2/cell/cell_layout.py</code> <pre><code>def contains_point(self, pos: Tuple[int, int]) -&gt; bool:\n    \"\"\"Determine weather this cell contains a point.\n\n    Checks its bounding box.\n\n    Args:\n        pos (Tuple[int, int]): the position to check\n\n    Returns:\n        bool: True if this point is in the bounding box\n    \"\"\"\n    pos_x, pos_y = pos\n    min_x, min_y, max_x, max_y = self.bounding_box\n    return min_x &lt;= pos_x &lt;= max_x and min_y &lt;= pos_y &lt;= max_y\n</code></pre>"},{"location":"reference/view/display_state_v2/cell/cell_layout/#src.view.display_state_v2.cell.cell_layout.CellLayout.get_bounding_box_size","title":"<code>get_bounding_box_size(bounding_box)</code>","text":"<p>Get the size of a bounding box.</p> <p>Parameters:</p> Name Type Description Default <code>bounding_box</code> <code>Tuple[int, int, int, int]</code> <p>the box to measure</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>the minimum length along one edge.</p> Source code in <code>src/view/display_state_v2/cell/cell_layout.py</code> <pre><code>def get_bounding_box_size(\n    self, bounding_box: Tuple[int, int, int, int]\n) -&gt; int:\n    \"\"\"Get the size of a bounding box.\n\n    Args:\n        bounding_box (Tuple[int, int, int, int]): the box to measure\n\n    Returns:\n        int: the minimum length along one edge.\n    \"\"\"\n    min_x, min_y, max_x, max_y = bounding_box\n\n    return min(max_x - min_x, max_y - min_y)\n</code></pre>"},{"location":"reference/view/display_state_v2/cell/cell_layout/#src.view.display_state_v2.cell.cell_layout.CellLayout.inset_bounding_box","title":"<code>inset_bounding_box(inset_amount)</code>","text":"<p>Get the bounding box that has been inset.</p> <p>Parameters:</p> Name Type Description Default <code>inset_amount</code> <code>int</code> <p>the amount to make the box smaller</p> required <p>Returns:</p> Type Description <code>Tuple[int, int, int, int]</code> <p>Tuple[int, int, int, int]: the new bounding box that has been inset</p> Source code in <code>src/view/display_state_v2/cell/cell_layout.py</code> <pre><code>def inset_bounding_box(\n    self, inset_amount: int\n) -&gt; Tuple[int, int, int, int]:\n    \"\"\"Get the bounding box that has been inset.\n\n    Args:\n        inset_amount (int): the amount to make the box smaller\n\n    Returns:\n        Tuple[int, int, int, int]: the new bounding box that has been inset\n    \"\"\"\n    min_x, min_y, max_x, max_y = self.bounding_box\n    return (\n        min_x + inset_amount,\n        min_y + inset_amount,\n        max_x - inset_amount,\n        max_y - inset_amount,\n    )\n</code></pre>"},{"location":"reference/view/display_state_v2/cell/main_icon_layer/","title":"Main Icon Layer","text":""},{"location":"reference/view/display_state_v2/cell/main_icon_layer/#src.view.display_state_v2.cell.main_icon_layer.MainIconLayer","title":"<code>MainIconLayer</code>","text":"<p>             Bases: <code>BaseLayer</code></p> <p>The layer responsible for drawing the background of the cell.</p> Source code in <code>src/view/display_state_v2/cell/main_icon_layer.py</code> <pre><code>class MainIconLayer(BaseLayer):\n    \"\"\"The layer responsible for drawing the background of the cell.\"\"\"\n\n    def draw(self):\n        \"\"\"Draw the main icon.\"\"\"\n        size = self.cell_layout.get_bounding_box_size(self.bounding_box)\n        icon = self.__get_main_icon(size)\n        if icon is None:\n            return\n        self.draw_icon(icon, size)\n\n    def __get_main_icon(self, size: int) -&gt; Optional[Image]:\n        \"\"\"Get what the main icon should be based upon the cell config.\n\n        Args:\n            size (int): the size the icon should be.\n\n        Returns:\n            Image: the image that corresponds to what the main icon should be\n        \"\"\"\n        cell_entity = self.config.cell_entity\n        loader = self.icon_loader\n        match self.options.display_mode:\n            case DisplayMode.default | DisplayMode.state_value:\n                return loader.get_cell_entity_icon(cell_entity, size)\n            case (\n                DisplayMode.action_value_global | DisplayMode.action_value_local\n            ):\n                return None\n            case DisplayMode.best_action:\n                best_action = self.__get_best_action()\n                if best_action is None:\n                    return loader.get_cell_entity_icon(cell_entity, size)\n\n                return loader.get_action_icon(best_action, size)\n\n    def __get_best_action(self) -&gt; Optional[Action]:\n        \"\"\"Get the action that has the best value.\n\n        Returns:\n            Optional[Action]: the best action if there is one.\n        \"\"\"\n        action_values = self.config.action_values_raw\n        best_action_value = float(\"-inf\")\n        best_action = None\n        for action in Action:\n            action_value = action_values[action]\n            if action_value is None:\n                continue\n            if best_action_value is None:\n                best_action_value = action_value\n                best_action = action\n            elif action_value &gt; best_action_value:\n                best_action_value = action_value\n                best_action = action\n        return best_action\n</code></pre>"},{"location":"reference/view/display_state_v2/cell/main_icon_layer/#src.view.display_state_v2.cell.main_icon_layer.MainIconLayer.__get_best_action","title":"<code>__get_best_action()</code>","text":"<p>Get the action that has the best value.</p> <p>Returns:</p> Type Description <code>Optional[Action]</code> <p>Optional[Action]: the best action if there is one.</p> Source code in <code>src/view/display_state_v2/cell/main_icon_layer.py</code> <pre><code>def __get_best_action(self) -&gt; Optional[Action]:\n    \"\"\"Get the action that has the best value.\n\n    Returns:\n        Optional[Action]: the best action if there is one.\n    \"\"\"\n    action_values = self.config.action_values_raw\n    best_action_value = float(\"-inf\")\n    best_action = None\n    for action in Action:\n        action_value = action_values[action]\n        if action_value is None:\n            continue\n        if best_action_value is None:\n            best_action_value = action_value\n            best_action = action\n        elif action_value &gt; best_action_value:\n            best_action_value = action_value\n            best_action = action\n    return best_action\n</code></pre>"},{"location":"reference/view/display_state_v2/cell/main_icon_layer/#src.view.display_state_v2.cell.main_icon_layer.MainIconLayer.__get_main_icon","title":"<code>__get_main_icon(size)</code>","text":"<p>Get what the main icon should be based upon the cell config.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int</code> <p>the size the icon should be.</p> required <p>Returns:</p> Name Type Description <code>Image</code> <code>Optional[Image]</code> <p>the image that corresponds to what the main icon should be</p> Source code in <code>src/view/display_state_v2/cell/main_icon_layer.py</code> <pre><code>def __get_main_icon(self, size: int) -&gt; Optional[Image]:\n    \"\"\"Get what the main icon should be based upon the cell config.\n\n    Args:\n        size (int): the size the icon should be.\n\n    Returns:\n        Image: the image that corresponds to what the main icon should be\n    \"\"\"\n    cell_entity = self.config.cell_entity\n    loader = self.icon_loader\n    match self.options.display_mode:\n        case DisplayMode.default | DisplayMode.state_value:\n            return loader.get_cell_entity_icon(cell_entity, size)\n        case (\n            DisplayMode.action_value_global | DisplayMode.action_value_local\n        ):\n            return None\n        case DisplayMode.best_action:\n            best_action = self.__get_best_action()\n            if best_action is None:\n                return loader.get_cell_entity_icon(cell_entity, size)\n\n            return loader.get_action_icon(best_action, size)\n</code></pre>"},{"location":"reference/view/display_state_v2/cell/main_icon_layer/#src.view.display_state_v2.cell.main_icon_layer.MainIconLayer.draw","title":"<code>draw()</code>","text":"<p>Draw the main icon.</p> Source code in <code>src/view/display_state_v2/cell/main_icon_layer.py</code> <pre><code>def draw(self):\n    \"\"\"Draw the main icon.\"\"\"\n    size = self.cell_layout.get_bounding_box_size(self.bounding_box)\n    icon = self.__get_main_icon(size)\n    if icon is None:\n        return\n    self.draw_icon(icon, size)\n</code></pre>"},{"location":"reference/view/icons/","title":"Icons","text":"<p>Package for loading icons into custom tkinter.</p>"},{"location":"reference/view/icons/load_icon/","title":"Load Icon","text":""},{"location":"reference/view/icons/load_icon/#src.view.icons.load_icon.Icon","title":"<code>Icon</code>","text":"<p>             Bases: <code>Enum</code></p> <p>Enumerates all possible icons available.</p> Source code in <code>src/view/icons/load_icon.py</code> <pre><code>class Icon(Enum):\n    \"\"\"Enumerates all possible icons available.\"\"\"\n\n    robot = \"robot\"\n    flag = \"flag\"\n    no_entry = \"do-not-enter\"\n    up_arrow = \"up-arrow\"\n    down_arrow = \"down-arrow\"\n    right_arrow = \"right-arrow\"\n    left_arrow = \"left-arrow\"\n    empty = \"empty\"\n</code></pre>"},{"location":"reference/view/icons/load_icon/#src.view.icons.load_icon.IconLoader","title":"<code>IconLoader</code>","text":"<p>             Bases: <code>object</code></p> <p>Load Icon images into the application.</p> Source code in <code>src/view/icons/load_icon.py</code> <pre><code>class IconLoader(object):\n    \"\"\"Load Icon images into the application.\"\"\"\n\n    _instance = None\n\n    # icon -&gt; normal icon, light icon\n    # avoid loading the same icon file multiple times\n    bitmap_cache: Dict[Icon, Image] = {}\n\n    # cache icon size and color because they will likely be used a lot\n    variant_cache: Dict[IconVariantSpecification, Image] = {}\n\n    default_color = (255, 255, 255)\n\n    def __new__(cls) -&gt; Self:\n        \"\"\"Create a config object.\n\n        Overridden to provide the singleton patten, there must only be one\n        IconLoader object. there should only be one cache so there is not need\n        for more than one loader\n\n        Returns:\n            Self: The config object with the loaded data\n        \"\"\"\n        # https://python-patterns.guide/gang-of-four/singleton/\n        if cls._instance is None:\n            cls._instance = super().__new__(cls)\n        return cls._instance\n\n    def get_path(self, icon: Icon) -&gt; str:\n        \"\"\"Get an icon's file path.\n\n        Args:\n            icon (Icon): the icon to find the path for.\n\n        Returns:\n            str: the absolute path to the icon file.\n        \"\"\"\n        return path.abspath(\n            path.join(path.dirname(__file__), f\"{icon.value}.png\")\n        )\n\n    rgb_component_max = 255\n\n    def get_coloured_icon(\n        self, image: Image, color: Tuple[int, int, int]\n    ) -&gt; Image:\n        \"\"\"Convert a black icon to a specific color.\n\n        sets all non-transparent pixels to the color.\n\n        Args:\n            image (Image): the image to convert,\n            color (str): must represent a valid color\n\n        Returns:\n            Image: the image with a white foreground\n        \"\"\"\n        np_color = np.array(color, dtype=int)\n\n        img_array = np.array(image.convert(\"RGBA\"))\n\n        rgb = img_array[:, :, :3]\n        alpha = img_array[:, :, 3]\n        non_transparent_pixels = alpha != 0\n        # set icon color to wight\n        rgb[non_transparent_pixels] = np_color\n\n        return Pillow.fromarray(img_array)\n\n    action_mapping: Dict[Action, Icon] = {\n        Action.up: Icon.up_arrow,\n        Action.down: Icon.down_arrow,\n        Action.left: Icon.left_arrow,\n        Action.right: Icon.right_arrow,\n    }\n\n    def get_action_icon(\n        self,\n        action: Action,\n        size: int,\n        color: Tuple[int, int, int] = default_color,\n    ) -&gt; Image:\n        \"\"\"Get the appropriate arrow icon for a given action.\n\n        Args:\n            action (Action): the action to represent\n            size (int): the size the icon should be displayed by tkinter\n            color (str): the color of the icon\n\n        Returns:\n            Image: the image pointing in that actions direction.\n        \"\"\"\n        return self.get_icon(self.action_mapping[action], size, color)\n\n    cell_entity_mapping = {\n        CellEntity.agent: Icon.robot,\n        CellEntity.goal: Icon.flag,\n        CellEntity.warning: Icon.no_entry,\n        CellEntity.empty: Icon.empty,\n    }\n\n    def get_cell_entity_icon(\n        self,\n        entity: CellEntity,\n        size: int,\n        color: Tuple[int, int, int] = default_color,\n    ) -&gt; Image:\n        \"\"\"Get the appropriate icon for a given cell entity.\n\n        Args:\n            entity (CellEntity): the entity to represent\n            size (int): the size the icon should be displayed by tkinter\n            color (str): the color of the icon\n\n        Returns:\n            Image: the image of this cell entity\n        \"\"\"\n        return self.get_icon(self.cell_entity_mapping[entity], size, color)\n\n    def get_icon(\n        self,\n        icon: Icon,\n        size: int,\n        color: Tuple[int, int, int] = default_color,\n    ) -&gt; Image:\n        \"\"\"Get the custom tkinter image object for a given icon.\n\n        Args:\n            icon (Icon): the icon to display\n            size (int): the size the icon should be displayed by tkinter\n            color (str): the color of the icon\n\n        Returns:\n            Image: the image representing this icon\n        \"\"\"\n        size = max(size, 1)\n        cache_key = IconVariantSpecification(icon, size, color)\n        existing_image = self.variant_cache.get(cache_key, None)\n        if existing_image is not None:\n            return existing_image\n\n        image_raw = self.__get_icon_raw_files(icon)\n\n        coloured_icon = self.get_coloured_icon(image_raw, color)\n        # resize image\n        coloured_icon.thumbnail((size, size))\n\n        self.variant_cache[cache_key] = coloured_icon\n\n        return coloured_icon\n\n    def __get_icon_raw_files(self, icon: Icon) -&gt; Image:\n        cached_file = self.bitmap_cache.get(icon, None)\n        if cached_file is not None:\n            return cached_file\n\n        icon_raw = Pillow.open(self.get_path(icon))\n\n        self.bitmap_cache[icon] = icon_raw\n        return icon_raw\n</code></pre>"},{"location":"reference/view/icons/load_icon/#src.view.icons.load_icon.IconLoader.__new__","title":"<code>__new__()</code>","text":"<p>Create a config object.</p> <p>Overridden to provide the singleton patten, there must only be one IconLoader object. there should only be one cache so there is not need for more than one loader</p> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The config object with the loaded data</p> Source code in <code>src/view/icons/load_icon.py</code> <pre><code>def __new__(cls) -&gt; Self:\n    \"\"\"Create a config object.\n\n    Overridden to provide the singleton patten, there must only be one\n    IconLoader object. there should only be one cache so there is not need\n    for more than one loader\n\n    Returns:\n        Self: The config object with the loaded data\n    \"\"\"\n    # https://python-patterns.guide/gang-of-four/singleton/\n    if cls._instance is None:\n        cls._instance = super().__new__(cls)\n    return cls._instance\n</code></pre>"},{"location":"reference/view/icons/load_icon/#src.view.icons.load_icon.IconLoader.get_action_icon","title":"<code>get_action_icon(action, size, color=default_color)</code>","text":"<p>Get the appropriate arrow icon for a given action.</p> <p>Parameters:</p> Name Type Description Default <code>action</code> <code>Action</code> <p>the action to represent</p> required <code>size</code> <code>int</code> <p>the size the icon should be displayed by tkinter</p> required <code>color</code> <code>str</code> <p>the color of the icon</p> <code>default_color</code> <p>Returns:</p> Name Type Description <code>Image</code> <code>Image</code> <p>the image pointing in that actions direction.</p> Source code in <code>src/view/icons/load_icon.py</code> <pre><code>def get_action_icon(\n    self,\n    action: Action,\n    size: int,\n    color: Tuple[int, int, int] = default_color,\n) -&gt; Image:\n    \"\"\"Get the appropriate arrow icon for a given action.\n\n    Args:\n        action (Action): the action to represent\n        size (int): the size the icon should be displayed by tkinter\n        color (str): the color of the icon\n\n    Returns:\n        Image: the image pointing in that actions direction.\n    \"\"\"\n    return self.get_icon(self.action_mapping[action], size, color)\n</code></pre>"},{"location":"reference/view/icons/load_icon/#src.view.icons.load_icon.IconLoader.get_cell_entity_icon","title":"<code>get_cell_entity_icon(entity, size, color=default_color)</code>","text":"<p>Get the appropriate icon for a given cell entity.</p> <p>Parameters:</p> Name Type Description Default <code>entity</code> <code>CellEntity</code> <p>the entity to represent</p> required <code>size</code> <code>int</code> <p>the size the icon should be displayed by tkinter</p> required <code>color</code> <code>str</code> <p>the color of the icon</p> <code>default_color</code> <p>Returns:</p> Name Type Description <code>Image</code> <code>Image</code> <p>the image of this cell entity</p> Source code in <code>src/view/icons/load_icon.py</code> <pre><code>def get_cell_entity_icon(\n    self,\n    entity: CellEntity,\n    size: int,\n    color: Tuple[int, int, int] = default_color,\n) -&gt; Image:\n    \"\"\"Get the appropriate icon for a given cell entity.\n\n    Args:\n        entity (CellEntity): the entity to represent\n        size (int): the size the icon should be displayed by tkinter\n        color (str): the color of the icon\n\n    Returns:\n        Image: the image of this cell entity\n    \"\"\"\n    return self.get_icon(self.cell_entity_mapping[entity], size, color)\n</code></pre>"},{"location":"reference/view/icons/load_icon/#src.view.icons.load_icon.IconLoader.get_coloured_icon","title":"<code>get_coloured_icon(image, color)</code>","text":"<p>Convert a black icon to a specific color.</p> <p>sets all non-transparent pixels to the color.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>Image</code> <p>the image to convert,</p> required <code>color</code> <code>str</code> <p>must represent a valid color</p> required <p>Returns:</p> Name Type Description <code>Image</code> <code>Image</code> <p>the image with a white foreground</p> Source code in <code>src/view/icons/load_icon.py</code> <pre><code>def get_coloured_icon(\n    self, image: Image, color: Tuple[int, int, int]\n) -&gt; Image:\n    \"\"\"Convert a black icon to a specific color.\n\n    sets all non-transparent pixels to the color.\n\n    Args:\n        image (Image): the image to convert,\n        color (str): must represent a valid color\n\n    Returns:\n        Image: the image with a white foreground\n    \"\"\"\n    np_color = np.array(color, dtype=int)\n\n    img_array = np.array(image.convert(\"RGBA\"))\n\n    rgb = img_array[:, :, :3]\n    alpha = img_array[:, :, 3]\n    non_transparent_pixels = alpha != 0\n    # set icon color to wight\n    rgb[non_transparent_pixels] = np_color\n\n    return Pillow.fromarray(img_array)\n</code></pre>"},{"location":"reference/view/icons/load_icon/#src.view.icons.load_icon.IconLoader.get_icon","title":"<code>get_icon(icon, size, color=default_color)</code>","text":"<p>Get the custom tkinter image object for a given icon.</p> <p>Parameters:</p> Name Type Description Default <code>icon</code> <code>Icon</code> <p>the icon to display</p> required <code>size</code> <code>int</code> <p>the size the icon should be displayed by tkinter</p> required <code>color</code> <code>str</code> <p>the color of the icon</p> <code>default_color</code> <p>Returns:</p> Name Type Description <code>Image</code> <code>Image</code> <p>the image representing this icon</p> Source code in <code>src/view/icons/load_icon.py</code> <pre><code>def get_icon(\n    self,\n    icon: Icon,\n    size: int,\n    color: Tuple[int, int, int] = default_color,\n) -&gt; Image:\n    \"\"\"Get the custom tkinter image object for a given icon.\n\n    Args:\n        icon (Icon): the icon to display\n        size (int): the size the icon should be displayed by tkinter\n        color (str): the color of the icon\n\n    Returns:\n        Image: the image representing this icon\n    \"\"\"\n    size = max(size, 1)\n    cache_key = IconVariantSpecification(icon, size, color)\n    existing_image = self.variant_cache.get(cache_key, None)\n    if existing_image is not None:\n        return existing_image\n\n    image_raw = self.__get_icon_raw_files(icon)\n\n    coloured_icon = self.get_coloured_icon(image_raw, color)\n    # resize image\n    coloured_icon.thumbnail((size, size))\n\n    self.variant_cache[cache_key] = coloured_icon\n\n    return coloured_icon\n</code></pre>"},{"location":"reference/view/icons/load_icon/#src.view.icons.load_icon.IconLoader.get_path","title":"<code>get_path(icon)</code>","text":"<p>Get an icon's file path.</p> <p>Parameters:</p> Name Type Description Default <code>icon</code> <code>Icon</code> <p>the icon to find the path for.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>the absolute path to the icon file.</p> Source code in <code>src/view/icons/load_icon.py</code> <pre><code>def get_path(self, icon: Icon) -&gt; str:\n    \"\"\"Get an icon's file path.\n\n    Args:\n        icon (Icon): the icon to find the path for.\n\n    Returns:\n        str: the absolute path to the icon file.\n    \"\"\"\n    return path.abspath(\n        path.join(path.dirname(__file__), f\"{icon.value}.png\")\n    )\n</code></pre>"},{"location":"reference/view/icons/load_icon/#src.view.icons.load_icon.IconVariantSpecification","title":"<code>IconVariantSpecification</code>  <code>dataclass</code>","text":"<p>             Bases: <code>object</code></p> <p>Specifies a particular variant of an icon for cacheing purposes.</p> Source code in <code>src/view/icons/load_icon.py</code> <pre><code>@dataclass(frozen=True)\nclass IconVariantSpecification(object):\n    \"\"\"Specifies a particular variant of an icon for cacheing purposes.\"\"\"\n\n    icon_type: Icon\n    size: int\n    color: rgb_type\n</code></pre>"},{"location":"reference/view/statistics/","title":"Statistics","text":"<p>This package contains widget for displaying statistics information.</p>"},{"location":"reference/view/statistics/matplotlib_setup/","title":"Matplotlib Setup","text":""},{"location":"reference/view/statistics/matplotlib_setup/#src.view.statistics.matplotlib_setup.create_canvas","title":"<code>create_canvas(figure)</code>","text":"<p>Method for getting canvas element.</p> <p>This method hides the setup for matplotlib backend that violates the linting rules</p> <p>Parameters:</p> Name Type Description Default <code>figure</code> <code>Figure</code> <p>the figure this canvas should display.</p> required <p>Returns:</p> Name Type Description <code>FigureCanvasQTAgg</code> <code>FigureCanvasQTAgg</code> <p>The canvas.</p> Source code in <code>src/view/statistics/matplotlib_setup.py</code> <pre><code>def create_canvas(figure: Figure) -&gt; FigureCanvasQTAgg:\n    \"\"\"Method for getting canvas element.\n\n    This method hides the setup for matplotlib backend that violates the linting\n    rules\n\n    Args:\n        figure (Figure): the figure this canvas should display.\n\n    Returns:\n        FigureCanvasQTAgg: The canvas.\n    \"\"\"\n    return FigureCanvasQTAgg(figure)\n</code></pre>"},{"location":"reference/view/statistics/plotting/","title":"Plotting","text":""},{"location":"reference/view/statistics/plotting/#src.view.statistics.plotting.BasePlotter","title":"<code>BasePlotter</code>","text":"<p>             Bases: <code>object</code></p> <p>Class for providing plotting information.</p> Source code in <code>src/view/statistics/plotting.py</code> <pre><code>class BasePlotter(object):\n    \"\"\"Class for providing plotting information.\"\"\"\n\n    def plot_data(self, axes: Axes):\n        \"\"\"Get the content for a plotting canvas.\n\n        This can assume the canvas is clear.\n\n        Args:\n            axes (Axes): the axes to plot to.\n\n        Raises:\n            NotImplementedError: If this method is not overridden by a concrete\n                class\n        \"\"\"\n        raise NotImplementedError(\n            \"This method should be implemented in the concrete implementation\"\n        )\n</code></pre>"},{"location":"reference/view/statistics/plotting/#src.view.statistics.plotting.BasePlotter.plot_data","title":"<code>plot_data(axes)</code>","text":"<p>Get the content for a plotting canvas.</p> <p>This can assume the canvas is clear.</p> <p>Parameters:</p> Name Type Description Default <code>axes</code> <code>Axes</code> <p>the axes to plot to.</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If this method is not overridden by a concrete class</p> Source code in <code>src/view/statistics/plotting.py</code> <pre><code>def plot_data(self, axes: Axes):\n    \"\"\"Get the content for a plotting canvas.\n\n    This can assume the canvas is clear.\n\n    Args:\n        axes (Axes): the axes to plot to.\n\n    Raises:\n        NotImplementedError: If this method is not overridden by a concrete\n            class\n    \"\"\"\n    raise NotImplementedError(\n        \"This method should be implemented in the concrete implementation\"\n    )\n</code></pre>"},{"location":"reference/view/statistics/plotting/#src.view.statistics.plotting.PlottingCanvas","title":"<code>PlottingCanvas</code>","text":"<p>             Bases: <code>QWidget</code></p> <p>Canvas widget for displaying and saving charts.</p> Source code in <code>src/view/statistics/plotting.py</code> <pre><code>class PlottingCanvas(QWidget):\n    \"\"\"Canvas widget for displaying and saving charts.\"\"\"\n\n    save_text = \"Save Plot\"\n    save_caption_text = \"Save Plot Filename\"\n    save_file_format = \"pdf\"\n    save_file_filter = \"PDF (*.pdf)\"\n    save_size = 3\n\n    def __init__(self, parent: Optional[QWidget], plotter: BasePlotter) -&gt; None:\n        \"\"\"Initialise a plotting canvas.\n\n        Args:\n            parent (Optional[QWidget]): the parent this canvas should be\n                rendered in.\n            plotter (BasePlotter): the code responsible for doing the plotting\n\n        Raises:\n            RuntimeError: If there is an issue with\n        \"\"\"\n        super().__init__(parent)\n\n        layout = QGridLayout(self)\n        self.plotter = plotter\n        ThemeContextManager.update_theme_context(ThemeContext.application)\n        self.figure = Figure()\n        self.canvas = create_canvas(self.figure)\n        layout.addWidget(self.canvas, 0, 0)\n        axes = self.figure.subplots()\n        if not isinstance(axes, Axes):\n            raise RuntimeError(\"Incorrect axes object\")\n        self.axes = axes\n\n        save_button = QPushButton(self.save_text, self)\n        save_button.clicked.connect(self.__save_requested)\n        layout.addWidget(save_button, 1, 0, Qt.AlignmentFlag.AlignRight)\n\n    def request_update(self):\n        \"\"\"Request an update to refresh the data.\"\"\"\n        ThemeContextManager.update_theme_context(ThemeContext.application)\n        self.axes.clear()\n        self.plotter.plot_data(self.axes)\n        self.canvas.draw()\n\n    def __save_requested(self):\n        path = QFileDialog.getSaveFileName(\n            self, self.save_caption_text, os.getcwd(), self.save_file_filter\n        )[0]\n        ThemeContextManager.update_theme_context(ThemeContext.saving)\n        save_figure = Figure((self.save_size * 2, self.save_size))\n        save_axes = save_figure.subplots()\n        if not isinstance(save_axes, Axes):\n            raise RuntimeError(\"Incorrect axes object\")\n        self.plotter.plot_data(save_axes)\n\n        if not path.endswith(self.save_file_format):\n            path = f\"{path}.{self.save_file_format}\"\n        save_figure.savefig(path, pad_inches=0.5, bbox_inches=\"tight\")\n</code></pre>"},{"location":"reference/view/statistics/plotting/#src.view.statistics.plotting.PlottingCanvas.__init__","title":"<code>__init__(parent, plotter)</code>","text":"<p>Initialise a plotting canvas.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>Optional[QWidget]</code> <p>the parent this canvas should be rendered in.</p> required <code>plotter</code> <code>BasePlotter</code> <p>the code responsible for doing the plotting</p> required <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If there is an issue with</p> Source code in <code>src/view/statistics/plotting.py</code> <pre><code>def __init__(self, parent: Optional[QWidget], plotter: BasePlotter) -&gt; None:\n    \"\"\"Initialise a plotting canvas.\n\n    Args:\n        parent (Optional[QWidget]): the parent this canvas should be\n            rendered in.\n        plotter (BasePlotter): the code responsible for doing the plotting\n\n    Raises:\n        RuntimeError: If there is an issue with\n    \"\"\"\n    super().__init__(parent)\n\n    layout = QGridLayout(self)\n    self.plotter = plotter\n    ThemeContextManager.update_theme_context(ThemeContext.application)\n    self.figure = Figure()\n    self.canvas = create_canvas(self.figure)\n    layout.addWidget(self.canvas, 0, 0)\n    axes = self.figure.subplots()\n    if not isinstance(axes, Axes):\n        raise RuntimeError(\"Incorrect axes object\")\n    self.axes = axes\n\n    save_button = QPushButton(self.save_text, self)\n    save_button.clicked.connect(self.__save_requested)\n    layout.addWidget(save_button, 1, 0, Qt.AlignmentFlag.AlignRight)\n</code></pre>"},{"location":"reference/view/statistics/plotting/#src.view.statistics.plotting.PlottingCanvas.request_update","title":"<code>request_update()</code>","text":"<p>Request an update to refresh the data.</p> Source code in <code>src/view/statistics/plotting.py</code> <pre><code>def request_update(self):\n    \"\"\"Request an update to refresh the data.\"\"\"\n    ThemeContextManager.update_theme_context(ThemeContext.application)\n    self.axes.clear()\n    self.plotter.plot_data(self.axes)\n    self.canvas.draw()\n</code></pre>"},{"location":"reference/view/statistics/reward_history/","title":"Reward History","text":""},{"location":"reference/view/statistics/reward_history/#src.view.statistics.reward_history.RewardHistory","title":"<code>RewardHistory</code>","text":"<p>             Bases: <code>BaseVisibilityObserver</code>, <code>BasePlotter</code></p> <p>Widget for displaying the historical reward history.</p> Source code in <code>src/view/statistics/reward_history.py</code> <pre><code>class RewardHistory(BaseVisibilityObserver, BasePlotter):\n    \"\"\"Widget for displaying the historical reward history.\"\"\"\n\n    def __init__(self, parent: Optional[QWidget]) -&gt; None:\n        \"\"\"Initialise the reward history widget.\n\n        uses matplotlib to create graphs.\n\n        Args:\n            parent (Optional[QWidget]): _description_\n\n        Raises:\n            RuntimeError: If there is an issue with matplotlib.\n        \"\"\"\n        super().__init__(parent)\n\n        layout = QGridLayout(self)\n\n        self.canvas = PlottingCanvas(self, self)\n        layout.addWidget(self.canvas, 0, 0)\n\n        self.current_stats: Optional[StatisticsRecord] = None\n\n    min_window_size = 3\n    preferred_window_steps = 50\n\n    @override\n    def plot_data(self, axes: Axes):\n        \"\"\"Get the content for the plotting canvas.\n\n        Args:\n            axes (Axes): the axes to plot to.\n        \"\"\"\n        axes.set_xlabel(\"Time steps\")\n        axes.set_ylabel(\"Reward\")\n        axes.set_title(\"Reward vs Time\")\n        if self.current_stats is None:\n            return\n\n        time_steps = self.current_stats.time_step\n        x_axis = np.arange(time_steps)\n        y_axis = np.array(self.current_stats.reward_history)\n        axes.plot(\n            x_axis,\n            y_axis,\n            \"ro\",\n            label=\"Rewards\",\n        )\n\n        if time_steps &gt; self.min_window_size:\n            window_size = int(\n                max(\n                    self.min_window_size,\n                    time_steps / self.preferred_window_steps,\n                ),\n            )\n\n            x_moving_average, y_moving_average = self.__moving_average(\n                x_axis, y_axis, window_size\n            )\n            axes.plot(\n                x_moving_average,\n                y_moving_average,\n                \"b-\",\n                label=f\"Moving Average, Width: {window_size}\",\n            )\n\n        axes.legend(loc=\"upper left\")\n\n    @override\n    def visible_state_updated(self, state: StateDescription) -&gt; None:\n        \"\"\"Update the figure when new data is available.\n\n        Args:\n            state (StateDescription): the new state.\n        \"\"\"\n        if state.statistics == self.current_stats:\n            return\n        self.current_stats = state.statistics\n        self.canvas.request_update()\n\n    def __moving_average(\n        self, x_axis: np.ndarray, rewards: np.ndarray, window_size: int\n    ) -&gt; Tuple[np.ndarray, np.ndarray]:\n        # inspiration: https://stackoverflow.com/questions/14313510\n        weights = np.repeat(1.0, window_size) / window_size\n        moving_avg = np.convolve(rewards, weights, \"valid\")\n        return x_axis[window_size - 2 : -1], moving_avg\n</code></pre>"},{"location":"reference/view/statistics/reward_history/#src.view.statistics.reward_history.RewardHistory.__init__","title":"<code>__init__(parent)</code>","text":"<p>Initialise the reward history widget.</p> <p>uses matplotlib to create graphs.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>Optional[QWidget]</code> <p>description</p> required <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If there is an issue with matplotlib.</p> Source code in <code>src/view/statistics/reward_history.py</code> <pre><code>def __init__(self, parent: Optional[QWidget]) -&gt; None:\n    \"\"\"Initialise the reward history widget.\n\n    uses matplotlib to create graphs.\n\n    Args:\n        parent (Optional[QWidget]): _description_\n\n    Raises:\n        RuntimeError: If there is an issue with matplotlib.\n    \"\"\"\n    super().__init__(parent)\n\n    layout = QGridLayout(self)\n\n    self.canvas = PlottingCanvas(self, self)\n    layout.addWidget(self.canvas, 0, 0)\n\n    self.current_stats: Optional[StatisticsRecord] = None\n</code></pre>"},{"location":"reference/view/statistics/reward_history/#src.view.statistics.reward_history.RewardHistory.plot_data","title":"<code>plot_data(axes)</code>","text":"<p>Get the content for the plotting canvas.</p> <p>Parameters:</p> Name Type Description Default <code>axes</code> <code>Axes</code> <p>the axes to plot to.</p> required Source code in <code>src/view/statistics/reward_history.py</code> <pre><code>@override\ndef plot_data(self, axes: Axes):\n    \"\"\"Get the content for the plotting canvas.\n\n    Args:\n        axes (Axes): the axes to plot to.\n    \"\"\"\n    axes.set_xlabel(\"Time steps\")\n    axes.set_ylabel(\"Reward\")\n    axes.set_title(\"Reward vs Time\")\n    if self.current_stats is None:\n        return\n\n    time_steps = self.current_stats.time_step\n    x_axis = np.arange(time_steps)\n    y_axis = np.array(self.current_stats.reward_history)\n    axes.plot(\n        x_axis,\n        y_axis,\n        \"ro\",\n        label=\"Rewards\",\n    )\n\n    if time_steps &gt; self.min_window_size:\n        window_size = int(\n            max(\n                self.min_window_size,\n                time_steps / self.preferred_window_steps,\n            ),\n        )\n\n        x_moving_average, y_moving_average = self.__moving_average(\n            x_axis, y_axis, window_size\n        )\n        axes.plot(\n            x_moving_average,\n            y_moving_average,\n            \"b-\",\n            label=f\"Moving Average, Width: {window_size}\",\n        )\n\n    axes.legend(loc=\"upper left\")\n</code></pre>"},{"location":"reference/view/statistics/reward_history/#src.view.statistics.reward_history.RewardHistory.visible_state_updated","title":"<code>visible_state_updated(state)</code>","text":"<p>Update the figure when new data is available.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>StateDescription</code> <p>the new state.</p> required Source code in <code>src/view/statistics/reward_history.py</code> <pre><code>@override\ndef visible_state_updated(self, state: StateDescription) -&gt; None:\n    \"\"\"Update the figure when new data is available.\n\n    Args:\n        state (StateDescription): the new state.\n    \"\"\"\n    if state.statistics == self.current_stats:\n        return\n    self.current_stats = state.statistics\n    self.canvas.request_update()\n</code></pre>"},{"location":"reference/view/statistics/report_display/","title":"Report Display","text":"<p>This package contains the widget for displaying tuning reports.</p>"},{"location":"reference/view/statistics/report_display/progress_indicator/","title":"Progress Indicator","text":""},{"location":"reference/view/statistics/report_display/progress_indicator/#src.view.statistics.report_display.progress_indicator.ProgressIndicator","title":"<code>ProgressIndicator</code>","text":"<p>             Bases: <code>QWidget</code>, <code>BaseReportObserver</code></p> <p>This widget displays to the user the current progress of the report.</p> Source code in <code>src/view/statistics/report_display/progress_indicator.py</code> <pre><code>class ProgressIndicator(QWidget, BaseReportObserver):\n    \"\"\"This widget displays to the user the current progress of the report.\"\"\"\n\n    progress_bar_steps = 100\n\n    def __init__(self, parent: Optional[QWidget]) -&gt; None:\n        \"\"\"Initialise the report progress indicator.\n\n        Args:\n            parent (Optional[QWidget]): the parent of the report progress\n                indicator.\n        \"\"\"\n        super().__init__(parent)\n\n        layout = QGridLayout(self)\n\n        label = QLabel(\"Report Generation Progress...\")\n        layout.addWidget(label, 0, 0, Qt.AlignmentFlag.AlignBottom)\n\n        self.progress_bar = QProgressBar(self)\n        self.progress_bar.setRange(0, self.progress_bar_steps)\n        layout.addWidget(self.progress_bar, 1, 0, Qt.AlignmentFlag.AlignTop)\n\n    @override\n    def report_state_updated(self, state: HyperParameterState) -&gt; None:\n        \"\"\"Handle when the report progress is updated.\n\n        Args:\n            state (HyperParameterState): the new state encompassing the current\n                progress\n        \"\"\"\n        report = state.report.current_report\n        if report is None:\n            return\n        progress = state.report.pending_requests.get(report, None)\n        if progress is None:\n            return\n\n        self.progress_bar.setValue(int(self.progress_bar_steps * progress))\n</code></pre>"},{"location":"reference/view/statistics/report_display/progress_indicator/#src.view.statistics.report_display.progress_indicator.ProgressIndicator.__init__","title":"<code>__init__(parent)</code>","text":"<p>Initialise the report progress indicator.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>Optional[QWidget]</code> <p>the parent of the report progress indicator.</p> required Source code in <code>src/view/statistics/report_display/progress_indicator.py</code> <pre><code>def __init__(self, parent: Optional[QWidget]) -&gt; None:\n    \"\"\"Initialise the report progress indicator.\n\n    Args:\n        parent (Optional[QWidget]): the parent of the report progress\n            indicator.\n    \"\"\"\n    super().__init__(parent)\n\n    layout = QGridLayout(self)\n\n    label = QLabel(\"Report Generation Progress...\")\n    layout.addWidget(label, 0, 0, Qt.AlignmentFlag.AlignBottom)\n\n    self.progress_bar = QProgressBar(self)\n    self.progress_bar.setRange(0, self.progress_bar_steps)\n    layout.addWidget(self.progress_bar, 1, 0, Qt.AlignmentFlag.AlignTop)\n</code></pre>"},{"location":"reference/view/statistics/report_display/progress_indicator/#src.view.statistics.report_display.progress_indicator.ProgressIndicator.report_state_updated","title":"<code>report_state_updated(state)</code>","text":"<p>Handle when the report progress is updated.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>HyperParameterState</code> <p>the new state encompassing the current progress</p> required Source code in <code>src/view/statistics/report_display/progress_indicator.py</code> <pre><code>@override\ndef report_state_updated(self, state: HyperParameterState) -&gt; None:\n    \"\"\"Handle when the report progress is updated.\n\n    Args:\n        state (HyperParameterState): the new state encompassing the current\n            progress\n    \"\"\"\n    report = state.report.current_report\n    if report is None:\n        return\n    progress = state.report.pending_requests.get(report, None)\n    if progress is None:\n        return\n\n    self.progress_bar.setValue(int(self.progress_bar_steps * progress))\n</code></pre>"},{"location":"reference/view/statistics/report_display/report_container/","title":"Report Container","text":""},{"location":"reference/view/statistics/report_display/report_container/#src.view.statistics.report_display.report_container.MainWidgetSwitcher","title":"<code>MainWidgetSwitcher</code>","text":"<p>             Bases: <code>QStackedWidget</code>, <code>BaseReportObserver</code></p> <p>Widget that switches to the appropriate display for the current state.</p> Source code in <code>src/view/statistics/report_display/report_container.py</code> <pre><code>class MainWidgetSwitcher(QStackedWidget, BaseReportObserver):\n    \"\"\"Widget that switches to the appropriate display for the current state.\"\"\"\n\n    def __init__(\n        self, parent: Optional[QWidget], publisher: ReportStatePublisher\n    ) -&gt; None:\n        \"\"\"Initialise the widget switcher.\n\n        Args:\n            parent (Optional[QWidget]): the parent of this widget\n            publisher (ReportStatePublisher): the publisher providing the update\n                events that drive this switcher.\n        \"\"\"\n        super().__init__(parent)\n\n        placeholder_text = QLabel(\"Select parameter to analyse.\")\n        placeholder_text.setAlignment(Qt.AlignmentFlag.AlignCenter)\n        self.addWidget(placeholder_text)\n\n        self.progress_bar = ProgressIndicator(self)\n        self.addWidget(self.progress_bar)\n        publisher.subscribe(self.progress_bar)\n\n        self.information_display = ReportInformationDisplay(self)\n        self.addWidget(self.information_display)\n        publisher.subscribe(self.information_display)\n\n        publisher.subscribe(self)\n\n    @override\n    def report_state_updated(self, state: HyperParameterState) -&gt; None:\n        \"\"\"Update the figure when a new report is provided.\n\n        Args:\n            state (HyperParameterState): the new report information.\n        \"\"\"\n        report = state.report\n        report_parameter = report.current_report\n        if report_parameter is None:\n            return\n\n        if report_parameter in report.pending_requests:\n            self.setCurrentWidget(self.progress_bar)\n\n        if report_parameter in report.available_reports:\n            self.setCurrentWidget(self.information_display)\n</code></pre>"},{"location":"reference/view/statistics/report_display/report_container/#src.view.statistics.report_display.report_container.MainWidgetSwitcher.__init__","title":"<code>__init__(parent, publisher)</code>","text":"<p>Initialise the widget switcher.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>Optional[QWidget]</code> <p>the parent of this widget</p> required <code>publisher</code> <code>ReportStatePublisher</code> <p>the publisher providing the update events that drive this switcher.</p> required Source code in <code>src/view/statistics/report_display/report_container.py</code> <pre><code>def __init__(\n    self, parent: Optional[QWidget], publisher: ReportStatePublisher\n) -&gt; None:\n    \"\"\"Initialise the widget switcher.\n\n    Args:\n        parent (Optional[QWidget]): the parent of this widget\n        publisher (ReportStatePublisher): the publisher providing the update\n            events that drive this switcher.\n    \"\"\"\n    super().__init__(parent)\n\n    placeholder_text = QLabel(\"Select parameter to analyse.\")\n    placeholder_text.setAlignment(Qt.AlignmentFlag.AlignCenter)\n    self.addWidget(placeholder_text)\n\n    self.progress_bar = ProgressIndicator(self)\n    self.addWidget(self.progress_bar)\n    publisher.subscribe(self.progress_bar)\n\n    self.information_display = ReportInformationDisplay(self)\n    self.addWidget(self.information_display)\n    publisher.subscribe(self.information_display)\n\n    publisher.subscribe(self)\n</code></pre>"},{"location":"reference/view/statistics/report_display/report_container/#src.view.statistics.report_display.report_container.MainWidgetSwitcher.report_state_updated","title":"<code>report_state_updated(state)</code>","text":"<p>Update the figure when a new report is provided.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>HyperParameterState</code> <p>the new report information.</p> required Source code in <code>src/view/statistics/report_display/report_container.py</code> <pre><code>@override\ndef report_state_updated(self, state: HyperParameterState) -&gt; None:\n    \"\"\"Update the figure when a new report is provided.\n\n    Args:\n        state (HyperParameterState): the new report information.\n    \"\"\"\n    report = state.report\n    report_parameter = report.current_report\n    if report_parameter is None:\n        return\n\n    if report_parameter in report.pending_requests:\n        self.setCurrentWidget(self.progress_bar)\n\n    if report_parameter in report.available_reports:\n        self.setCurrentWidget(self.information_display)\n</code></pre>"},{"location":"reference/view/statistics/report_display/report_container/#src.view.statistics.report_display.report_container.ReportContainer","title":"<code>ReportContainer</code>","text":"<p>             Bases: <code>QWidget</code></p> <p>Widget for displaying a hyper parameter report.</p> Source code in <code>src/view/statistics/report_display/report_container.py</code> <pre><code>class ReportContainer(QWidget):\n    \"\"\"Widget for displaying a hyper parameter report.\"\"\"\n\n    def __init__(\n        self,\n        parent: Optional[QWidget],\n        report_controller: HyperParameterController,\n        publisher: ReportStatePublisher,\n    ) -&gt; None:\n        \"\"\"Initialise the report display widget.\n\n        uses matplotlib to create graphs.\n\n        Args:\n            parent (Optional[QWidget]): the parent of this widget.\n            report_controller (HyperParameterController): the controller to\n                interact with the report information.\n            publisher (ReportStatePublisher): the publisher that notifies the\n                report to updates.\n\n        \"\"\"\n        super().__init__(parent)\n\n        self.layout_manager = QGridLayout(self)\n\n        selector = ReportSelector(self, report_controller)\n        self.layout_manager.addWidget(selector, 0, 0)\n        publisher.subscribe(selector)\n\n        self.main_widget_area = MainWidgetSwitcher(self, publisher)\n        self.layout_manager.addWidget(self.main_widget_area, 1, 0)\n</code></pre>"},{"location":"reference/view/statistics/report_display/report_container/#src.view.statistics.report_display.report_container.ReportContainer.__init__","title":"<code>__init__(parent, report_controller, publisher)</code>","text":"<p>Initialise the report display widget.</p> <p>uses matplotlib to create graphs.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>Optional[QWidget]</code> <p>the parent of this widget.</p> required <code>report_controller</code> <code>HyperParameterController</code> <p>the controller to interact with the report information.</p> required <code>publisher</code> <code>ReportStatePublisher</code> <p>the publisher that notifies the report to updates.</p> required Source code in <code>src/view/statistics/report_display/report_container.py</code> <pre><code>def __init__(\n    self,\n    parent: Optional[QWidget],\n    report_controller: HyperParameterController,\n    publisher: ReportStatePublisher,\n) -&gt; None:\n    \"\"\"Initialise the report display widget.\n\n    uses matplotlib to create graphs.\n\n    Args:\n        parent (Optional[QWidget]): the parent of this widget.\n        report_controller (HyperParameterController): the controller to\n            interact with the report information.\n        publisher (ReportStatePublisher): the publisher that notifies the\n            report to updates.\n\n    \"\"\"\n    super().__init__(parent)\n\n    self.layout_manager = QGridLayout(self)\n\n    selector = ReportSelector(self, report_controller)\n    self.layout_manager.addWidget(selector, 0, 0)\n    publisher.subscribe(selector)\n\n    self.main_widget_area = MainWidgetSwitcher(self, publisher)\n    self.layout_manager.addWidget(self.main_widget_area, 1, 0)\n</code></pre>"},{"location":"reference/view/statistics/report_display/report_information_display/","title":"Report Information Display","text":""},{"location":"reference/view/statistics/report_display/report_information_display/#src.view.statistics.report_display.report_information_display.ReportInformationDisplay","title":"<code>ReportInformationDisplay</code>","text":"<p>             Bases: <code>QWidget</code>, <code>BaseReportObserver</code>, <code>BasePlotter</code></p> <p>This widget displays to the user the information from the report.</p> Source code in <code>src/view/statistics/report_display/report_information_display.py</code> <pre><code>class ReportInformationDisplay(QWidget, BaseReportObserver, BasePlotter):\n    \"\"\"This widget displays to the user the information from the report.\"\"\"\n\n    progress_bar_steps = 100\n\n    def __init__(self, parent: Optional[QWidget]) -&gt; None:\n        \"\"\"Initialise the report progress indicator.\n\n        Args:\n            parent (Optional[QWidget]): the parent of the report progress\n                indicator.\n\n        Raises:\n            RuntimeError: If there is an issue with matplotlib.\n        \"\"\"\n        super().__init__(parent)\n\n        layout = QGridLayout(self)\n\n        self.canvas = PlottingCanvas(self, self)\n        layout.addWidget(self.canvas, 0, 0)\n\n        self.current_report: Optional[HyperParameterReport] = None\n\n    @override\n    def report_state_updated(self, state: HyperParameterState) -&gt; None:\n        \"\"\"Handle when the report progress is updated.\n\n        Args:\n            state (HyperParameterState): the new state encompassing the current\n                progress\n        \"\"\"\n        report_parameter = state.report.current_report\n        if report_parameter is None:\n            return\n\n        report_unchanged = (\n            self.current_report is not None\n            and report_parameter is self.current_report.parameter\n        )\n\n        if report_unchanged:\n            return\n        report_data = state.report.available_reports.get(report_parameter, None)\n        if report_data is None:\n            return\n\n        self.current_report = report_data\n        self.canvas.request_update()\n\n    @override\n    def plot_data(self, axes: Axes):\n        \"\"\"Get the content for the plotting canvas.\n\n        Args:\n            axes (Axes): the axes to plot to.\n        \"\"\"\n        if self.current_report is None:\n            return\n\n        details = TuningInformation.get_parameter_details(\n            self.current_report.parameter\n        )\n        axes.set_title(f\"{details.get_display_name()} vs Total Reward\")\n        axes.set_xlabel(f\"{details.get_display_name()} Value\")\n        axes.set_ylabel(\"Total Reward\")\n        axes.fill_between(\n            self.current_report.x_axis,\n            self.current_report.lower_confidence_bound,\n            self.current_report.upper_confidence_bound,\n            color=\"b\",\n            alpha=0.1 * 3,\n        )\n        axes.plot(self.current_report.x_axis, self.current_report.y_axis, \"r-\")\n</code></pre>"},{"location":"reference/view/statistics/report_display/report_information_display/#src.view.statistics.report_display.report_information_display.ReportInformationDisplay.__init__","title":"<code>__init__(parent)</code>","text":"<p>Initialise the report progress indicator.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>Optional[QWidget]</code> <p>the parent of the report progress indicator.</p> required <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If there is an issue with matplotlib.</p> Source code in <code>src/view/statistics/report_display/report_information_display.py</code> <pre><code>def __init__(self, parent: Optional[QWidget]) -&gt; None:\n    \"\"\"Initialise the report progress indicator.\n\n    Args:\n        parent (Optional[QWidget]): the parent of the report progress\n            indicator.\n\n    Raises:\n        RuntimeError: If there is an issue with matplotlib.\n    \"\"\"\n    super().__init__(parent)\n\n    layout = QGridLayout(self)\n\n    self.canvas = PlottingCanvas(self, self)\n    layout.addWidget(self.canvas, 0, 0)\n\n    self.current_report: Optional[HyperParameterReport] = None\n</code></pre>"},{"location":"reference/view/statistics/report_display/report_information_display/#src.view.statistics.report_display.report_information_display.ReportInformationDisplay.plot_data","title":"<code>plot_data(axes)</code>","text":"<p>Get the content for the plotting canvas.</p> <p>Parameters:</p> Name Type Description Default <code>axes</code> <code>Axes</code> <p>the axes to plot to.</p> required Source code in <code>src/view/statistics/report_display/report_information_display.py</code> <pre><code>@override\ndef plot_data(self, axes: Axes):\n    \"\"\"Get the content for the plotting canvas.\n\n    Args:\n        axes (Axes): the axes to plot to.\n    \"\"\"\n    if self.current_report is None:\n        return\n\n    details = TuningInformation.get_parameter_details(\n        self.current_report.parameter\n    )\n    axes.set_title(f\"{details.get_display_name()} vs Total Reward\")\n    axes.set_xlabel(f\"{details.get_display_name()} Value\")\n    axes.set_ylabel(\"Total Reward\")\n    axes.fill_between(\n        self.current_report.x_axis,\n        self.current_report.lower_confidence_bound,\n        self.current_report.upper_confidence_bound,\n        color=\"b\",\n        alpha=0.1 * 3,\n    )\n    axes.plot(self.current_report.x_axis, self.current_report.y_axis, \"r-\")\n</code></pre>"},{"location":"reference/view/statistics/report_display/report_information_display/#src.view.statistics.report_display.report_information_display.ReportInformationDisplay.report_state_updated","title":"<code>report_state_updated(state)</code>","text":"<p>Handle when the report progress is updated.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>HyperParameterState</code> <p>the new state encompassing the current progress</p> required Source code in <code>src/view/statistics/report_display/report_information_display.py</code> <pre><code>@override\ndef report_state_updated(self, state: HyperParameterState) -&gt; None:\n    \"\"\"Handle when the report progress is updated.\n\n    Args:\n        state (HyperParameterState): the new state encompassing the current\n            progress\n    \"\"\"\n    report_parameter = state.report.current_report\n    if report_parameter is None:\n        return\n\n    report_unchanged = (\n        self.current_report is not None\n        and report_parameter is self.current_report.parameter\n    )\n\n    if report_unchanged:\n        return\n    report_data = state.report.available_reports.get(report_parameter, None)\n    if report_data is None:\n        return\n\n    self.current_report = report_data\n    self.canvas.request_update()\n</code></pre>"},{"location":"reference/view/statistics/report_display/report_selector/","title":"Report Selector","text":""},{"location":"reference/view/statistics/report_display/report_selector/#src.view.statistics.report_display.report_selector.ReportSelector","title":"<code>ReportSelector</code>","text":"<p>             Bases: <code>QComboBox</code>, <code>BaseReportObserver</code></p> <p>Widget to allow the user to select a hyper parameter for analysis.</p> Source code in <code>src/view/statistics/report_display/report_selector.py</code> <pre><code>class ReportSelector(QComboBox, BaseReportObserver):\n    \"\"\"Widget to allow the user to select a hyper parameter for analysis.\"\"\"\n\n    none_selected_text = \"None Selected\"\n\n    def __init__(\n        self,\n        parent: Optional[QWidget],\n        report_controller: HyperParameterController,\n    ) -&gt; None:\n        \"\"\"Initialise the report selector.\n\n        Args:\n            parent (Optional[QWidget]): the parent of this widget.\n            report_controller (HyperParameterController): the controller to\n                notify when the user selects a different report..\n        \"\"\"\n        super().__init__(parent)\n\n        hyper_parameters = TuningInformation.tunable_parameters()\n        self.controller = report_controller\n        self.options = {\n            TuningInformation.get_parameter_details(parameter).name: parameter\n            for parameter in hyper_parameters\n        }\n\n        self.reset_guard = False\n\n        self.currentTextChanged.connect(self.update_handler)\n        self.current_items: List[str] = []\n\n    def update_handler(self, text: str) -&gt; None:\n        \"\"\"Handle update, send the appropriate request to the controller.\n\n        Args:\n            text (str): the option that has been selected.\n        \"\"\"\n        if self.reset_guard:\n            return\n        if text is self.none_selected_text:\n            return\n        self.controller.request_bridge.request_report(self.options[text])\n\n    @override\n    def report_state_updated(self, state: HyperParameterState) -&gt; None:\n        \"\"\"Update the figure when a new report is provided.\n\n        Args:\n            state (HyperParameterState): the new report information.\n        \"\"\"\n        self.reset_guard = True\n        current_report = state.report.current_report\n        update_options: Dict[Optional[HyperParameter], str] = {\n            option: name for name, option in self.options.items()\n        }\n        if current_report is None:\n            update_options[None] = self.none_selected_text\n\n        new_items = list(update_options.values())\n        # avoid redundant updates can cause flickering\n        if new_items != self.current_items:\n            self.clear()\n            self.addItems(new_items)\n            self.current_items = new_items\n\n        new_current_text = update_options[current_report]\n        if self.currentText() != new_current_text:\n            self.setCurrentText(new_current_text)\n        self.reset_guard = False\n</code></pre>"},{"location":"reference/view/statistics/report_display/report_selector/#src.view.statistics.report_display.report_selector.ReportSelector.__init__","title":"<code>__init__(parent, report_controller)</code>","text":"<p>Initialise the report selector.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>Optional[QWidget]</code> <p>the parent of this widget.</p> required <code>report_controller</code> <code>HyperParameterController</code> <p>the controller to notify when the user selects a different report..</p> required Source code in <code>src/view/statistics/report_display/report_selector.py</code> <pre><code>def __init__(\n    self,\n    parent: Optional[QWidget],\n    report_controller: HyperParameterController,\n) -&gt; None:\n    \"\"\"Initialise the report selector.\n\n    Args:\n        parent (Optional[QWidget]): the parent of this widget.\n        report_controller (HyperParameterController): the controller to\n            notify when the user selects a different report..\n    \"\"\"\n    super().__init__(parent)\n\n    hyper_parameters = TuningInformation.tunable_parameters()\n    self.controller = report_controller\n    self.options = {\n        TuningInformation.get_parameter_details(parameter).name: parameter\n        for parameter in hyper_parameters\n    }\n\n    self.reset_guard = False\n\n    self.currentTextChanged.connect(self.update_handler)\n    self.current_items: List[str] = []\n</code></pre>"},{"location":"reference/view/statistics/report_display/report_selector/#src.view.statistics.report_display.report_selector.ReportSelector.report_state_updated","title":"<code>report_state_updated(state)</code>","text":"<p>Update the figure when a new report is provided.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>HyperParameterState</code> <p>the new report information.</p> required Source code in <code>src/view/statistics/report_display/report_selector.py</code> <pre><code>@override\ndef report_state_updated(self, state: HyperParameterState) -&gt; None:\n    \"\"\"Update the figure when a new report is provided.\n\n    Args:\n        state (HyperParameterState): the new report information.\n    \"\"\"\n    self.reset_guard = True\n    current_report = state.report.current_report\n    update_options: Dict[Optional[HyperParameter], str] = {\n        option: name for name, option in self.options.items()\n    }\n    if current_report is None:\n        update_options[None] = self.none_selected_text\n\n    new_items = list(update_options.values())\n    # avoid redundant updates can cause flickering\n    if new_items != self.current_items:\n        self.clear()\n        self.addItems(new_items)\n        self.current_items = new_items\n\n    new_current_text = update_options[current_report]\n    if self.currentText() != new_current_text:\n        self.setCurrentText(new_current_text)\n    self.reset_guard = False\n</code></pre>"},{"location":"reference/view/statistics/report_display/report_selector/#src.view.statistics.report_display.report_selector.ReportSelector.update_handler","title":"<code>update_handler(text)</code>","text":"<p>Handle update, send the appropriate request to the controller.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>the option that has been selected.</p> required Source code in <code>src/view/statistics/report_display/report_selector.py</code> <pre><code>def update_handler(self, text: str) -&gt; None:\n    \"\"\"Handle update, send the appropriate request to the controller.\n\n    Args:\n        text (str): the option that has been selected.\n    \"\"\"\n    if self.reset_guard:\n        return\n    if text is self.none_selected_text:\n        return\n    self.controller.request_bridge.request_report(self.options[text])\n</code></pre>"},{"location":"reference/view/statistics/search_results/","title":"Search Results","text":"<p>This package contains the code to display the results of a random search.</p>"},{"location":"reference/view/statistics/search_results/container/","title":"Container","text":""},{"location":"reference/view/statistics/search_results/container/#src.view.statistics.search_results.container.SearchDisplay","title":"<code>SearchDisplay</code>","text":"<p>             Bases: <code>QWidget</code>, <code>BaseReportObserver</code></p> <p>Display the results of the ongoing random search.</p> <p>This class contains the controls to update the search and the updated details.</p> Source code in <code>src/view/statistics/search_results/container.py</code> <pre><code>class SearchDisplay(QWidget, BaseReportObserver):\n    \"\"\"Display the results of the ongoing random search.\n\n    This class contains the controls to update the search and the updated\n    details.\n    \"\"\"\n\n    def __init__(\n        self,\n        parent: Optional[QWidget],\n        report_controller: HyperParameterController,\n        publisher: ReportStatePublisher,\n    ) -&gt; None:\n        \"\"\"Initialise the search display.\n\n        Args:\n            parent (Optional[QWidget]): the parent this widget is mounted in.\n            report_controller (HyperParameterController): the controller to\n                interact with.\n            publisher (ReportStatePublisher): the publisher to notify the\n                display of updates.\n        \"\"\"\n        super().__init__(parent)\n        layout = QGridLayout(self)\n\n        button = SearchStartButton(self, report_controller)\n        publisher.subscribe(button)\n        layout.addWidget(button, 0, 0)\n\n        self.scroll_area = QScrollArea(self)\n        self.scroll_area.setAlignment(Qt.AlignmentFlag.AlignCenter)\n        layout.addWidget(self.scroll_area, 1, 0)\n\n        publisher.subscribe(self)\n\n        self.lest_search_state: Optional[RandomSearchState] = None\n\n    @override\n    def report_state_updated(self, state: HyperParameterState) -&gt; None:\n        \"\"\"Update the details view with new information.\n\n        Args:\n            state (HyperParameterState): The current state.\n        \"\"\"\n        search_state = state.search\n        if search_state == self.lest_search_state:\n            return\n        self.lest_search_state = search_state\n        # save scroll position\n        v_scrollbar = self.scroll_area.verticalScrollBar()\n        h_scrollbar = self.scroll_area.horizontalScrollBar()\n        v_pos = v_scrollbar.sliderPosition()\n        h_pos = h_scrollbar.sliderPosition()\n        # scroll position lost\n        self.scroll_area.setWidget(\n            SearchDisplayInstance(self.scroll_area, search_state),\n        )\n        # restore scroll position\n        v_scrollbar.setSliderPosition(v_pos)\n        h_scrollbar.setSliderPosition(h_pos)\n</code></pre>"},{"location":"reference/view/statistics/search_results/container/#src.view.statistics.search_results.container.SearchDisplay.__init__","title":"<code>__init__(parent, report_controller, publisher)</code>","text":"<p>Initialise the search display.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>Optional[QWidget]</code> <p>the parent this widget is mounted in.</p> required <code>report_controller</code> <code>HyperParameterController</code> <p>the controller to interact with.</p> required <code>publisher</code> <code>ReportStatePublisher</code> <p>the publisher to notify the display of updates.</p> required Source code in <code>src/view/statistics/search_results/container.py</code> <pre><code>def __init__(\n    self,\n    parent: Optional[QWidget],\n    report_controller: HyperParameterController,\n    publisher: ReportStatePublisher,\n) -&gt; None:\n    \"\"\"Initialise the search display.\n\n    Args:\n        parent (Optional[QWidget]): the parent this widget is mounted in.\n        report_controller (HyperParameterController): the controller to\n            interact with.\n        publisher (ReportStatePublisher): the publisher to notify the\n            display of updates.\n    \"\"\"\n    super().__init__(parent)\n    layout = QGridLayout(self)\n\n    button = SearchStartButton(self, report_controller)\n    publisher.subscribe(button)\n    layout.addWidget(button, 0, 0)\n\n    self.scroll_area = QScrollArea(self)\n    self.scroll_area.setAlignment(Qt.AlignmentFlag.AlignCenter)\n    layout.addWidget(self.scroll_area, 1, 0)\n\n    publisher.subscribe(self)\n\n    self.lest_search_state: Optional[RandomSearchState] = None\n</code></pre>"},{"location":"reference/view/statistics/search_results/container/#src.view.statistics.search_results.container.SearchDisplay.report_state_updated","title":"<code>report_state_updated(state)</code>","text":"<p>Update the details view with new information.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>HyperParameterState</code> <p>The current state.</p> required Source code in <code>src/view/statistics/search_results/container.py</code> <pre><code>@override\ndef report_state_updated(self, state: HyperParameterState) -&gt; None:\n    \"\"\"Update the details view with new information.\n\n    Args:\n        state (HyperParameterState): The current state.\n    \"\"\"\n    search_state = state.search\n    if search_state == self.lest_search_state:\n        return\n    self.lest_search_state = search_state\n    # save scroll position\n    v_scrollbar = self.scroll_area.verticalScrollBar()\n    h_scrollbar = self.scroll_area.horizontalScrollBar()\n    v_pos = v_scrollbar.sliderPosition()\n    h_pos = h_scrollbar.sliderPosition()\n    # scroll position lost\n    self.scroll_area.setWidget(\n        SearchDisplayInstance(self.scroll_area, search_state),\n    )\n    # restore scroll position\n    v_scrollbar.setSliderPosition(v_pos)\n    h_scrollbar.setSliderPosition(h_pos)\n</code></pre>"},{"location":"reference/view/statistics/search_results/display/","title":"Display","text":""},{"location":"reference/view/statistics/search_results/display/#src.view.statistics.search_results.display.SearchDisplayInstance","title":"<code>SearchDisplayInstance</code>","text":"<p>             Bases: <code>QWidget</code></p> <p>Display the results of a random search.</p> Source code in <code>src/view/statistics/search_results/display.py</code> <pre><code>class SearchDisplayInstance(QWidget):\n    \"\"\"Display the results of a random search.\"\"\"\n\n    dynamics_used_text = \"Dynamics\"\n    exploration_strategy_text = \"Exploration Strategy\"\n\n    best_value_text = \"Best Total Reward\"\n    total_attempts_text = \"Total Attempts\"\n\n    def __init__(\n        self, parent: Optional[QWidget], search_state: RandomSearchState\n    ) -&gt; None:\n        \"\"\"Initialise the display.\n\n        Args:\n            parent (Optional[QWidget]): the parent of this widget.\n            search_state (RandomSearchState): the state to display.\n        \"\"\"\n        super().__init__(parent)\n        layout = QGridLayout(self)\n\n        columns = 2\n\n        for index, search_area in enumerate(search_state.search_areas.values()):\n            section = SearchDisplaySection(self, search_state, search_area)\n            layout.addWidget(section, index // columns, index % columns)\n</code></pre>"},{"location":"reference/view/statistics/search_results/display/#src.view.statistics.search_results.display.SearchDisplayInstance.__init__","title":"<code>__init__(parent, search_state)</code>","text":"<p>Initialise the display.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>Optional[QWidget]</code> <p>the parent of this widget.</p> required <code>search_state</code> <code>RandomSearchState</code> <p>the state to display.</p> required Source code in <code>src/view/statistics/search_results/display.py</code> <pre><code>def __init__(\n    self, parent: Optional[QWidget], search_state: RandomSearchState\n) -&gt; None:\n    \"\"\"Initialise the display.\n\n    Args:\n        parent (Optional[QWidget]): the parent of this widget.\n        search_state (RandomSearchState): the state to display.\n    \"\"\"\n    super().__init__(parent)\n    layout = QGridLayout(self)\n\n    columns = 2\n\n    for index, search_area in enumerate(search_state.search_areas.values()):\n        section = SearchDisplaySection(self, search_state, search_area)\n        layout.addWidget(section, index // columns, index % columns)\n</code></pre>"},{"location":"reference/view/statistics/search_results/display/#src.view.statistics.search_results.display.SearchDisplaySection","title":"<code>SearchDisplaySection</code>","text":"<p>             Bases: <code>QFrame</code></p> <p>Display the results of a random search.</p> Source code in <code>src/view/statistics/search_results/display.py</code> <pre><code>class SearchDisplaySection(QFrame):\n    \"\"\"Display the results of a random search.\"\"\"\n\n    dynamics_used_text = \"Dynamics\"\n    exploration_strategy_text = \"Exploration Strategy\"\n\n    best_value_text = \"Best Total Reward\"\n    total_attempts_text = \"Total Attempts\"\n    potential_reward_text = \"Potential Reward\"\n    regret = \"Regret\"\n    missing_value_text = \"\u2014\"\n\n    top_title = \"Configuration\"\n    middle_title = \"Statistics\"\n    parameters_title = \"Best Hyperparameter Values\"\n\n    def __init__(\n        self,\n        parent: Optional[QWidget],\n        search_state: RandomSearchState,\n        search_area: SearchArea,\n    ) -&gt; None:\n        \"\"\"Initialise the display.\n\n        Args:\n            parent (Optional[QWidget]): the parent of this widget.\n            search_state (RandomSearchState): the search state information.\n            search_area (SearchArea): the search area to display.\n        \"\"\"\n        super().__init__(parent)\n\n        self.setFrameShape(self.Shape.Box)\n        self.layout_manager = QGridLayout(self)\n        self.row: int = 0\n\n        potential_reward = None\n        if search_state.optimal_rewards is not None:\n            potential_reward = search_state.optimal_rewards[\n                search_area.options.dynamics\n            ]\n\n        self.__populate_config(search_area)\n        self.__populate_stats(search_area, potential_reward)\n        self.__populate_parameters(search_area)\n\n    def __populate_config(self, search_area: SearchArea):\n        options = search_area.options\n\n        self.__add_title(self.top_title)\n        self.__add_row(\n            self.exploration_strategy_text,\n            OptionDisplayText.full_exploration_options.get_text(\n                options.exploration_strategy\n            ),\n        )\n        self.__add_row(\n            self.dynamics_used_text,\n            OptionDisplayText.dynamics_options.get_text(options.dynamics),\n        )\n\n    def __populate_stats(\n        self, search_area: SearchArea, potential_reward: Optional[float]\n    ):\n        self.__add_title(self.middle_title)\n        self.__add_row(self.best_value_text, search_area.best_value)\n        self.__add_row(self.potential_reward_text, potential_reward)\n\n        if potential_reward is None or search_area.best_value is None:\n            self.__add_row(self.regret, None)\n        else:\n            self.__add_row(\n                self.regret, potential_reward - search_area.best_value\n            )\n\n        self.__add_row(self.total_attempts_text, search_area.combinations_tried)\n\n    def __populate_parameters(self, search_area: SearchArea):\n        self.__add_title(self.parameters_title)\n        best_parameters = search_area.best_parameters\n\n        for parameter, parameter_value in best_parameters.items():\n            details = TuningInformation.get_parameter_details(parameter)\n\n            self.__add_row(\n                details.name, parameter_value, details.integer_valued\n            )\n\n    def __add_title(self, title: str):\n        title_label = QLabel(title, self)\n\n        current_font = title_label.font()\n        current_font.setBold(True)\n        current_font.setPointSize(current_font.pointSize() + 2)\n        title_label.setFont(current_font)\n        self.layout_manager.addWidget(title_label, self.row, 0, 1, 2)\n        self.row += 1\n\n    def __add_row(\n        self,\n        label: str,\n        row_data: Union[float, int, str, None],\n        display_as_int: bool = False,\n    ):\n        self.layout_manager.addWidget(\n            QLabel(label, self),\n            self.row,\n            0,\n        )\n        text = None\n\n        if row_data is None:\n            text = self.missing_value_text\n        elif isinstance(row_data, int) or display_as_int:\n            text = f\"{row_data: d}\"\n        elif isinstance(row_data, float):\n            text = f\"{row_data: .3f}\"\n        else:\n            text = row_data\n\n        alignment = (\n            Qt.AlignmentFlag.AlignCenter\n            if row_data is None\n            else Qt.AlignmentFlag.AlignLeft\n        )\n        data_label = self.__add_selection(QLabel(text, self))\n\n        self.layout_manager.addWidget(data_label, self.row, 1, alignment)\n        self.row += 1\n\n    def __add_selection(self, label: QLabel) -&gt; QLabel:\n        flags = (\n            Qt.TextInteractionFlag.TextSelectableByMouse\n            | Qt.TextInteractionFlag.TextSelectableByKeyboard\n        )\n        label.setTextInteractionFlags(flags)\n        return label\n</code></pre>"},{"location":"reference/view/statistics/search_results/display/#src.view.statistics.search_results.display.SearchDisplaySection.__init__","title":"<code>__init__(parent, search_state, search_area)</code>","text":"<p>Initialise the display.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>Optional[QWidget]</code> <p>the parent of this widget.</p> required <code>search_state</code> <code>RandomSearchState</code> <p>the search state information.</p> required <code>search_area</code> <code>SearchArea</code> <p>the search area to display.</p> required Source code in <code>src/view/statistics/search_results/display.py</code> <pre><code>def __init__(\n    self,\n    parent: Optional[QWidget],\n    search_state: RandomSearchState,\n    search_area: SearchArea,\n) -&gt; None:\n    \"\"\"Initialise the display.\n\n    Args:\n        parent (Optional[QWidget]): the parent of this widget.\n        search_state (RandomSearchState): the search state information.\n        search_area (SearchArea): the search area to display.\n    \"\"\"\n    super().__init__(parent)\n\n    self.setFrameShape(self.Shape.Box)\n    self.layout_manager = QGridLayout(self)\n    self.row: int = 0\n\n    potential_reward = None\n    if search_state.optimal_rewards is not None:\n        potential_reward = search_state.optimal_rewards[\n            search_area.options.dynamics\n        ]\n\n    self.__populate_config(search_area)\n    self.__populate_stats(search_area, potential_reward)\n    self.__populate_parameters(search_area)\n</code></pre>"},{"location":"reference/view/statistics/search_results/start_button/","title":"Start Button","text":""},{"location":"reference/view/statistics/search_results/start_button/#src.view.statistics.search_results.start_button.SearchStartButton","title":"<code>SearchStartButton</code>","text":"<p>             Bases: <code>QPushButton</code>, <code>BaseReportObserver</code></p> <p>Button to control the starting and stopping of a random search.</p> Source code in <code>src/view/statistics/search_results/start_button.py</code> <pre><code>class SearchStartButton(QPushButton, BaseReportObserver):\n    \"\"\"Button to control the starting and stopping of a random search.\"\"\"\n\n    start_text = \"start\"\n    stop_text = \"stop\"\n\n    def __init__(\n        self,\n        parent: QWidget,\n        controller: HyperParameterController,\n    ):\n        \"\"\"Initialise the start button.\n\n        Args:\n            parent (QWidget): the parent this widget should be a part of.\n            controller (HyperParameterController): the controller to update\n                when pressed.\n        \"\"\"\n        self.start_search = True\n        super().__init__(self.start_text, parent)\n        self.controller = controller\n\n        self.clicked.connect(self.__click_handler)\n\n    @override\n    def report_state_updated(self, state: HyperParameterState) -&gt; None:\n        \"\"\"Update the buttons function when the mode changes.\n\n        Args:\n            state (HyperParameterState): the new state.\n        \"\"\"\n        start_search = not state.search.searching\n        if start_search == self.start_text:\n            return\n        self.start_search = start_search\n        new_text = self.start_text if start_search else self.stop_text\n        self.setText(new_text)\n\n    def __click_handler(self):\n        self.controller.request_bridge.set_search_state(self.start_search)\n</code></pre>"},{"location":"reference/view/statistics/search_results/start_button/#src.view.statistics.search_results.start_button.SearchStartButton.__init__","title":"<code>__init__(parent, controller)</code>","text":"<p>Initialise the start button.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>the parent this widget should be a part of.</p> required <code>controller</code> <code>HyperParameterController</code> <p>the controller to update when pressed.</p> required Source code in <code>src/view/statistics/search_results/start_button.py</code> <pre><code>def __init__(\n    self,\n    parent: QWidget,\n    controller: HyperParameterController,\n):\n    \"\"\"Initialise the start button.\n\n    Args:\n        parent (QWidget): the parent this widget should be a part of.\n        controller (HyperParameterController): the controller to update\n            when pressed.\n    \"\"\"\n    self.start_search = True\n    super().__init__(self.start_text, parent)\n    self.controller = controller\n\n    self.clicked.connect(self.__click_handler)\n</code></pre>"},{"location":"reference/view/statistics/search_results/start_button/#src.view.statistics.search_results.start_button.SearchStartButton.report_state_updated","title":"<code>report_state_updated(state)</code>","text":"<p>Update the buttons function when the mode changes.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>HyperParameterState</code> <p>the new state.</p> required Source code in <code>src/view/statistics/search_results/start_button.py</code> <pre><code>@override\ndef report_state_updated(self, state: HyperParameterState) -&gt; None:\n    \"\"\"Update the buttons function when the mode changes.\n\n    Args:\n        state (HyperParameterState): the new state.\n    \"\"\"\n    start_search = not state.search.searching\n    if start_search == self.start_text:\n        return\n    self.start_search = start_search\n    new_text = self.start_text if start_search else self.stop_text\n    self.setText(new_text)\n</code></pre>"}]}