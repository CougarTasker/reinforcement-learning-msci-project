{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Final Year Project Documentation","text":"<p>This site contains the documentation for this project, please navigate the reference section in the left panel or use the search tool in the top right.</p> <p>The project consists of three main sections:</p> <ul> <li>Model<ul> <li>This package contains the code for the reinforcement learning models such as the agents and dynamics.</li> </ul> </li> <li>View<ul> <li>This package contains the code for the user interface it displays the state of model and allows the user to interact with it.</li> </ul> </li> <li>Controller<ul> <li>This package contains the code that links the Model and View. </li> </ul> </li> </ul> <p>and two entry points:</p> <ul> <li>Main<ul> <li>This is the main usual entrypoint of the application</li> </ul> </li> <li>Profile<ul> <li>This is a secondary entrypoint that sets up a profiler before starting the application</li> </ul> </li> </ul> <p>This documentation site was generated with mkdocs.</p>"},{"location":"#documentation-commands","title":"Documentation Commands","text":"<p>To start a server that will allow you to see the documentation locally.</p> <pre><code>poetry run mkdocs serve -a localhost:3000\n</code></pre> <p>To make a new build of the documentation locally.</p> <pre><code>poetry run mkdocs build\n</code></pre>"},{"location":"SUMMARY/","title":"SUMMARY","text":"<ul> <li>Reference<ul> <li>Controller<ul> <li>Base Bridge</li> <li>Learning System Controller</li> <li>State Update Bridge</li> <li>User Action Bridge</li> </ul> </li> <li>Main</li> <li>Model<ul> <li>Agents<ul> <li>Base Agent</li> <li>Q Learning<ul> <li>Agent</li> <li>Dynamic Q Table</li> <li>Exploration Strategies<ul> <li>Base Strategy</li> <li>Epsilon Greedy Strategy</li> <li>Options</li> </ul> </li> <li>Reward Replay Queue</li> </ul> </li> <li>Value Iteration<ul> <li>Agent</li> <li>Agent Optimised</li> <li>Dynamics Distribution</li> <li>Types</li> </ul> </li> </ul> </li> <li>Config<ul> <li>Agent Section</li> <li>Base Section</li> <li>Grid World Section</li> <li>Gui Section</li> <li>Reader</li> </ul> </li> <li>Dynamics<ul> <li>Actions</li> <li>Base Dynamics</li> <li>Collection Dynamics</li> <li>Grid World</li> </ul> </li> <li>Learning System<ul> <li>Base Entity Decorator</li> <li>Cell Configuration<ul> <li>Cell Configuration</li> <li>Cell Configuration Factory</li> <li>Cell State Lookup</li> </ul> </li> <li>Global Options</li> <li>Learning Instance</li> <li>Learning System</li> <li>Options</li> <li>State Description<ul> <li>State Description</li> <li>State Description Factory</li> </ul> </li> <li>Top Entities</li> <li>Value Standardisation<ul> <li>Normaliser</li> <li>Normaliser Factory</li> <li>Value Range</li> </ul> </li> </ul> </li> <li>State<ul> <li>Cell Entities</li> <li>State Builder</li> <li>State Instance</li> <li>State Pool</li> </ul> </li> </ul> </li> <li>Profile</li> <li>View<ul> <li>Controls<ul> <li>Control Factory</li> <li>Custom Button Widget</li> <li>Custom Combo Widget</li> </ul> </li> <li>Grid World View V2<ul> <li>Auto Speed State Manager</li> <li>Display State V2<ul> <li>Cell<ul> <li>Arrow Layer</li> <li>Background Layer</li> <li>Base Layer</li> <li>Cell</li> <li>Cell Layout</li> <li>Main Icon Layer</li> </ul> </li> <li>Display</li> </ul> </li> <li>Grid World V2</li> <li>Interaction Controls</li> </ul> </li> <li>Icons<ul> <li>Load Icon</li> </ul> </li> <li>Option Controls</li> <li>State Publisher</li> <li>View Root V2</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/","title":"Reference","text":"<p>This package contains the source code to the project.</p>"},{"location":"reference/main/","title":"Main","text":""},{"location":"reference/main/#src.main.main","title":"<code>main()</code>","text":"<p>Start the application.</p> <p>The main entry point into the application.</p> Source code in <code>src/main.py</code> <pre><code>def main():\n    \"\"\"Start the application.\n\n    The main entry point into the application.\n    \"\"\"\n    with LearningSystemController() as controller:\n        qt = QApplication(sys.argv)\n        app = ReinforcementLearningApp(controller)\n        app.show()\n        qt.exec()\n</code></pre>"},{"location":"reference/profile/","title":"Profile","text":""},{"location":"reference/profile/#src.profile.one_process_profiling","title":"<code>one_process_profiling()</code>","text":"<p>Run the profiled code.</p> <p>The code in this method will be profiled by the application.</p> Source code in <code>src/profile.py</code> <pre><code>def one_process_profiling():\n    \"\"\"Run the profiled code.\n\n    The code in this method will be profiled by the application.\n    \"\"\"\n    ls = LearningSystem()\n\n    ls.update_options(\n        GlobalOptions(\n            AgentOptions.value_iteration_optimised,\n            DynamicsOptions.collection,\n            ExplorationStrategyOptions.not_applicable,\n            DisplayMode.state_value,\n        )\n    )\n\n    qt = QApplication()\n    display_state = DisplayState(None)\n    display_state.show()\n    display_state.resize(application_size, application_size)\n\n    def loop():\n        cs = ls.get_current_state()\n        display_state.set_state(cs)\n        ls.learning_instance.perform_action()\n\n    timer = QTimer(display_state)\n    timer.timeout.connect(loop)\n    timer.start(1)\n    qt.exec()\n</code></pre>"},{"location":"reference/profile/#src.profile.profile","title":"<code>profile()</code>","text":"<p>Entry point for profiling the application.</p> Source code in <code>src/profile.py</code> <pre><code>def profile():\n    \"\"\"Entry point for profiling the application.\"\"\"\n    profiler = cProfile.Profile()\n    profiler.enable()\n    try:\n        profiled_code()\n    finally:\n        profiler.disable()\n        ps = pstats.Stats(profiler)\n        ps.dump_stats(\"profile_result.prof\")\n</code></pre>"},{"location":"reference/profile/#src.profile.profiled_code","title":"<code>profiled_code()</code>","text":"<p>Run the profiled code.</p> <p>The code in this method will be profiled by the application.</p> Source code in <code>src/profile.py</code> <pre><code>def profiled_code():\n    \"\"\"Run the profiled code.\n\n    The code in this method will be profiled by the application.\n    \"\"\"\n    with LearningSystemController() as controller:\n        qt = QApplication()\n        app = ReinforcementLearningApp(controller)\n        controller.user_action_bridge.submit_action(UserAction.start_auto)\n        app.show()\n        app.resize(application_size, application_size)\n        qt.exec()\n</code></pre>"},{"location":"reference/controller/","title":"Controller","text":"<p>This package contains the controllers.</p> <p>These act as the bridge between the view and the model</p>"},{"location":"reference/controller/base_bridge/","title":"Base Bridge","text":""},{"location":"reference/controller/base_bridge/#src.controller.base_bridge.BaseBridge","title":"<code>BaseBridge</code>","text":"<p>             Bases: <code>object</code></p> <p>Bases class that represents a bridge between two processes.</p> Source code in <code>src/controller/base_bridge.py</code> <pre><code>class BaseBridge(object):\n    \"\"\"Bases class that represents a bridge between two processes.\"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialise a bridge.\"\"\"\n        manager = Manager()\n        self.state_lock = manager.Lock()\n        self.port = manager.Value(int, 0)\n        self.state = manager.Value(BridgeState, BridgeState.none)\n        self.socket = None\n\n    def add_item(self, queue_item: Any):\n        \"\"\"Add item to the queue, not blocking.\n\n        Args:\n            queue_item (Any): The item to be added.\n        \"\"\"\n        self.__get_socket().send_pyobj(queue_item)\n\n    def get_item_blocking(self) -&gt; Any:\n        \"\"\"Get the next item in the queue while blocking.\n\n        Returns:\n            Any: the next item.\n        \"\"\"\n        return self.__get_socket().recv_pyobj()\n\n    def get_item_non_blocking(self) -&gt; Any:\n        \"\"\"Get the latest item on the queue.\n\n        Returns:\n            Any: the latest item. None if the queue is empty\n        \"\"\"\n        try:\n            return self.__get_socket().recv_pyobj(NOBLOCK)\n        except Again:\n            return None\n\n    def __get_socket(self):\n        if self.socket is not None:\n            return self.socket\n\n        with self.state_lock:\n            match self.state.get():\n                case BridgeState.none:\n                    self.socket = Context().socket(PAIR)\n                    port = self.socket.bind_to_random_port(\"tcp://*\")\n                    self.port.set(port)\n                    self.state.set(BridgeState.port_bound)\n                case BridgeState.port_bound:\n                    self.socket = Context().socket(PAIR)\n                    self.socket.connect(f\"tcp://localhost:{self.port.get()}\")\n                    self.state.set(BridgeState.connected)\n                case BridgeState.connected:\n                    raise RuntimeError(\"connected while missing bridge end\")\n\n        return self.socket\n</code></pre>"},{"location":"reference/controller/base_bridge/#src.controller.base_bridge.BaseBridge.__init__","title":"<code>__init__()</code>","text":"<p>Initialise a bridge.</p> Source code in <code>src/controller/base_bridge.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialise a bridge.\"\"\"\n    manager = Manager()\n    self.state_lock = manager.Lock()\n    self.port = manager.Value(int, 0)\n    self.state = manager.Value(BridgeState, BridgeState.none)\n    self.socket = None\n</code></pre>"},{"location":"reference/controller/base_bridge/#src.controller.base_bridge.BaseBridge.add_item","title":"<code>add_item(queue_item)</code>","text":"<p>Add item to the queue, not blocking.</p> <p>Parameters:</p> Name Type Description Default <code>queue_item</code> <code>Any</code> <p>The item to be added.</p> required Source code in <code>src/controller/base_bridge.py</code> <pre><code>def add_item(self, queue_item: Any):\n    \"\"\"Add item to the queue, not blocking.\n\n    Args:\n        queue_item (Any): The item to be added.\n    \"\"\"\n    self.__get_socket().send_pyobj(queue_item)\n</code></pre>"},{"location":"reference/controller/base_bridge/#src.controller.base_bridge.BaseBridge.get_item_blocking","title":"<code>get_item_blocking()</code>","text":"<p>Get the next item in the queue while blocking.</p> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>the next item.</p> Source code in <code>src/controller/base_bridge.py</code> <pre><code>def get_item_blocking(self) -&gt; Any:\n    \"\"\"Get the next item in the queue while blocking.\n\n    Returns:\n        Any: the next item.\n    \"\"\"\n    return self.__get_socket().recv_pyobj()\n</code></pre>"},{"location":"reference/controller/base_bridge/#src.controller.base_bridge.BaseBridge.get_item_non_blocking","title":"<code>get_item_non_blocking()</code>","text":"<p>Get the latest item on the queue.</p> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>the latest item. None if the queue is empty</p> Source code in <code>src/controller/base_bridge.py</code> <pre><code>def get_item_non_blocking(self) -&gt; Any:\n    \"\"\"Get the latest item on the queue.\n\n    Returns:\n        Any: the latest item. None if the queue is empty\n    \"\"\"\n    try:\n        return self.__get_socket().recv_pyobj(NOBLOCK)\n    except Again:\n        return None\n</code></pre>"},{"location":"reference/controller/base_bridge/#src.controller.base_bridge.BridgeState","title":"<code>BridgeState</code>","text":"<p>             Bases: <code>Enum</code></p> <p>Enumerates the possible connection states of the bridge.</p> Source code in <code>src/controller/base_bridge.py</code> <pre><code>class BridgeState(Enum):\n    \"\"\"Enumerates the possible connection states of the bridge.\"\"\"\n\n    none = 0\n    port_bound = 1\n    connected = 2\n</code></pre>"},{"location":"reference/controller/learning_system_controller/","title":"Learning System Controller","text":""},{"location":"reference/controller/learning_system_controller/#src.controller.learning_system_controller.LearningSystemController","title":"<code>LearningSystemController</code>","text":"<p>             Bases: <code>object</code></p> <p>Controller for managing learning systems.</p> Source code in <code>src/controller/learning_system_controller.py</code> <pre><code>class LearningSystemController(object):\n    \"\"\"Controller for managing learning systems.\"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialise the learning system controller.\"\"\"\n        self.system = LearningSystem()\n        self.user_action_bridge = UserActionBridge()\n        self.state_update_bridge = StateUpdateBridge()\n        self.auto = False\n\n        self.model_process: Optional[Process] = None\n\n    def __enter__(self) -&gt; Self:\n        \"\"\"Enter the context manager.\n\n        the context manager is used for cleaning up processes gracefully.\n\n        Returns:\n            Self: the factory.\n        \"\"\"\n        self.model_process = Process(target=self.model_mainloop, daemon=True)\n        self.model_process.start()\n        return self\n\n    def __exit__(self, exc_type, exc_value, exc_tb) -&gt; None:\n        \"\"\"Exit the context, clean up the resources.\n\n        Args:\n            exc_type (Any): Not used.\n            exc_value (Any): Not used.\n            exc_tb (Any): Not used.\n        \"\"\"\n        self.user_action_bridge.submit_action(UserAction.end)\n        if self.model_process is not None:\n            self.model_process.join()\n\n    def model_mainloop(\n        self,\n    ):\n        \"\"\"Run the main loop of the model process.\n\n        Raises:\n            RuntimeError: if an unsupported action is made.\n        \"\"\"\n        user_action_bridge = self.user_action_bridge\n        while True:\n            action = None\n            if self.auto:\n                while action is None:\n                    action = user_action_bridge.get_action_non_blocking()\n                    self.one_step()\n            else:\n                action = user_action_bridge.get_action()\n\n            match action:\n                case UserActionMessage(action=UserAction.end):\n                    break\n                case UserActionMessage(action=UserAction.one_step):\n                    self.one_step()\n                    self.send_current_state()\n                case UserActionMessage(action=UserAction.start_auto):\n                    self.auto = True\n                case UserActionMessage(action=UserAction.stop_auto):\n                    self.auto = False\n                case UserActionMessage(action=UserAction.reset_state):\n                    self.system.learning_instance.reset_state()\n                    self.send_current_state()\n                case UserActionMessage(action=UserAction.fetch_current_state):\n                    self.send_current_state()\n                case UserActionMessage(\n                    action=UserAction.set_display_mode, payload=display_mode\n                ):\n                    self.system.update_options(\n                        replace(self.system.options, display_mode=display_mode)\n                    )\n                    self.send_current_state()\n\n                case UserActionMessage(\n                    action=UserAction.set_agent, payload=agent\n                ):\n                    self.system.update_options(\n                        replace(self.system.options, agent=agent)\n                    )\n                    self.send_current_state()\n                case UserActionMessage(\n                    action=UserAction.set_dynamics, payload=dynamics\n                ):\n                    self.system.update_options(\n                        replace(self.system.options, dynamics=dynamics)\n                    )\n                    self.send_current_state()\n                case UserActionMessage(\n                    action=UserAction.set_agent_strategy, payload=agent_strategy\n                ):\n                    self.system.update_options(\n                        replace(\n                            self.system.options, agent_strategy=agent_strategy\n                        )\n                    )\n                    self.send_current_state()\n                case UserActionMessage(action=UserAction.reset_system):\n                    self.system.reset_top_level()\n                    self.send_current_state()\n                case _:\n                    raise RuntimeError(\"Unknown action performed.\")\n\n    def one_step(self):\n        \"\"\"Perform one step.\"\"\"\n        self.system.learning_instance.perform_action()\n        self.send_current_state()\n\n    def send_current_state(self):\n        \"\"\"Send the current state to the view.\"\"\"\n        current_state = self.system.get_current_state()\n        self.state_update_bridge.update_state(current_state)\n</code></pre>"},{"location":"reference/controller/learning_system_controller/#src.controller.learning_system_controller.LearningSystemController.__enter__","title":"<code>__enter__()</code>","text":"<p>Enter the context manager.</p> <p>the context manager is used for cleaning up processes gracefully.</p> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>the factory.</p> Source code in <code>src/controller/learning_system_controller.py</code> <pre><code>def __enter__(self) -&gt; Self:\n    \"\"\"Enter the context manager.\n\n    the context manager is used for cleaning up processes gracefully.\n\n    Returns:\n        Self: the factory.\n    \"\"\"\n    self.model_process = Process(target=self.model_mainloop, daemon=True)\n    self.model_process.start()\n    return self\n</code></pre>"},{"location":"reference/controller/learning_system_controller/#src.controller.learning_system_controller.LearningSystemController.__exit__","title":"<code>__exit__(exc_type, exc_value, exc_tb)</code>","text":"<p>Exit the context, clean up the resources.</p> <p>Parameters:</p> Name Type Description Default <code>exc_type</code> <code>Any</code> <p>Not used.</p> required <code>exc_value</code> <code>Any</code> <p>Not used.</p> required <code>exc_tb</code> <code>Any</code> <p>Not used.</p> required Source code in <code>src/controller/learning_system_controller.py</code> <pre><code>def __exit__(self, exc_type, exc_value, exc_tb) -&gt; None:\n    \"\"\"Exit the context, clean up the resources.\n\n    Args:\n        exc_type (Any): Not used.\n        exc_value (Any): Not used.\n        exc_tb (Any): Not used.\n    \"\"\"\n    self.user_action_bridge.submit_action(UserAction.end)\n    if self.model_process is not None:\n        self.model_process.join()\n</code></pre>"},{"location":"reference/controller/learning_system_controller/#src.controller.learning_system_controller.LearningSystemController.__init__","title":"<code>__init__()</code>","text":"<p>Initialise the learning system controller.</p> Source code in <code>src/controller/learning_system_controller.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialise the learning system controller.\"\"\"\n    self.system = LearningSystem()\n    self.user_action_bridge = UserActionBridge()\n    self.state_update_bridge = StateUpdateBridge()\n    self.auto = False\n\n    self.model_process: Optional[Process] = None\n</code></pre>"},{"location":"reference/controller/learning_system_controller/#src.controller.learning_system_controller.LearningSystemController.model_mainloop","title":"<code>model_mainloop()</code>","text":"<p>Run the main loop of the model process.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if an unsupported action is made.</p> Source code in <code>src/controller/learning_system_controller.py</code> <pre><code>def model_mainloop(\n    self,\n):\n    \"\"\"Run the main loop of the model process.\n\n    Raises:\n        RuntimeError: if an unsupported action is made.\n    \"\"\"\n    user_action_bridge = self.user_action_bridge\n    while True:\n        action = None\n        if self.auto:\n            while action is None:\n                action = user_action_bridge.get_action_non_blocking()\n                self.one_step()\n        else:\n            action = user_action_bridge.get_action()\n\n        match action:\n            case UserActionMessage(action=UserAction.end):\n                break\n            case UserActionMessage(action=UserAction.one_step):\n                self.one_step()\n                self.send_current_state()\n            case UserActionMessage(action=UserAction.start_auto):\n                self.auto = True\n            case UserActionMessage(action=UserAction.stop_auto):\n                self.auto = False\n            case UserActionMessage(action=UserAction.reset_state):\n                self.system.learning_instance.reset_state()\n                self.send_current_state()\n            case UserActionMessage(action=UserAction.fetch_current_state):\n                self.send_current_state()\n            case UserActionMessage(\n                action=UserAction.set_display_mode, payload=display_mode\n            ):\n                self.system.update_options(\n                    replace(self.system.options, display_mode=display_mode)\n                )\n                self.send_current_state()\n\n            case UserActionMessage(\n                action=UserAction.set_agent, payload=agent\n            ):\n                self.system.update_options(\n                    replace(self.system.options, agent=agent)\n                )\n                self.send_current_state()\n            case UserActionMessage(\n                action=UserAction.set_dynamics, payload=dynamics\n            ):\n                self.system.update_options(\n                    replace(self.system.options, dynamics=dynamics)\n                )\n                self.send_current_state()\n            case UserActionMessage(\n                action=UserAction.set_agent_strategy, payload=agent_strategy\n            ):\n                self.system.update_options(\n                    replace(\n                        self.system.options, agent_strategy=agent_strategy\n                    )\n                )\n                self.send_current_state()\n            case UserActionMessage(action=UserAction.reset_system):\n                self.system.reset_top_level()\n                self.send_current_state()\n            case _:\n                raise RuntimeError(\"Unknown action performed.\")\n</code></pre>"},{"location":"reference/controller/learning_system_controller/#src.controller.learning_system_controller.LearningSystemController.one_step","title":"<code>one_step()</code>","text":"<p>Perform one step.</p> Source code in <code>src/controller/learning_system_controller.py</code> <pre><code>def one_step(self):\n    \"\"\"Perform one step.\"\"\"\n    self.system.learning_instance.perform_action()\n    self.send_current_state()\n</code></pre>"},{"location":"reference/controller/learning_system_controller/#src.controller.learning_system_controller.LearningSystemController.send_current_state","title":"<code>send_current_state()</code>","text":"<p>Send the current state to the view.</p> Source code in <code>src/controller/learning_system_controller.py</code> <pre><code>def send_current_state(self):\n    \"\"\"Send the current state to the view.\"\"\"\n    current_state = self.system.get_current_state()\n    self.state_update_bridge.update_state(current_state)\n</code></pre>"},{"location":"reference/controller/state_update_bridge/","title":"State Update Bridge","text":""},{"location":"reference/controller/state_update_bridge/#src.controller.state_update_bridge.StateUpdateBridge","title":"<code>StateUpdateBridge</code>","text":"<p>             Bases: <code>BaseBridge</code></p> <p>Bridge for passing state updates to the view.</p> Source code in <code>src/controller/state_update_bridge.py</code> <pre><code>class StateUpdateBridge(BaseBridge):\n    \"\"\"Bridge for passing state updates to the view.\"\"\"\n\n    def update_state(self, state: StateDescription):\n        \"\"\"Set the new state to be displayed.\n\n        Args:\n            state (StateDescription): The new state.\n        \"\"\"\n        self.add_item(state)\n\n    def get_latest_state(self) -&gt; Optional[StateDescription]:\n        \"\"\"Get the last (most recent) new state.\n\n        Returns:\n            Optional[StateDescription]: the new state, none if none has been set\n        \"\"\"\n        return self.get_item_non_blocking()\n</code></pre>"},{"location":"reference/controller/state_update_bridge/#src.controller.state_update_bridge.StateUpdateBridge.get_latest_state","title":"<code>get_latest_state()</code>","text":"<p>Get the last (most recent) new state.</p> <p>Returns:</p> Type Description <code>Optional[StateDescription]</code> <p>Optional[StateDescription]: the new state, none if none has been set</p> Source code in <code>src/controller/state_update_bridge.py</code> <pre><code>def get_latest_state(self) -&gt; Optional[StateDescription]:\n    \"\"\"Get the last (most recent) new state.\n\n    Returns:\n        Optional[StateDescription]: the new state, none if none has been set\n    \"\"\"\n    return self.get_item_non_blocking()\n</code></pre>"},{"location":"reference/controller/state_update_bridge/#src.controller.state_update_bridge.StateUpdateBridge.update_state","title":"<code>update_state(state)</code>","text":"<p>Set the new state to be displayed.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>StateDescription</code> <p>The new state.</p> required Source code in <code>src/controller/state_update_bridge.py</code> <pre><code>def update_state(self, state: StateDescription):\n    \"\"\"Set the new state to be displayed.\n\n    Args:\n        state (StateDescription): The new state.\n    \"\"\"\n    self.add_item(state)\n</code></pre>"},{"location":"reference/controller/user_action_bridge/","title":"User Action Bridge","text":""},{"location":"reference/controller/user_action_bridge/#src.controller.user_action_bridge.UserAction","title":"<code>UserAction</code>","text":"<p>             Bases: <code>Enum</code></p> <p>Enumerate all possible user actions.</p> Source code in <code>src/controller/user_action_bridge.py</code> <pre><code>class UserAction(Enum):\n    \"\"\"Enumerate all possible user actions.\"\"\"\n\n    one_step = 0\n    start_auto = 1\n    stop_auto = 2\n    reset_state = 3\n    fetch_current_state = 4\n    set_display_mode = 5\n    set_agent = 6\n    set_dynamics = 7\n    set_agent_strategy = 8\n    reset_system = 9\n    end = 10\n</code></pre>"},{"location":"reference/controller/user_action_bridge/#src.controller.user_action_bridge.UserActionBridge","title":"<code>UserActionBridge</code>","text":"<p>             Bases: <code>BaseBridge</code></p> <p>Bridge for passing the user actions from the view to the model.</p> Source code in <code>src/controller/user_action_bridge.py</code> <pre><code>class UserActionBridge(BaseBridge):\n    \"\"\"Bridge for passing the user actions from the view to the model.\"\"\"\n\n    def submit_action(self, action: UserAction, payload: Any = None):\n        \"\"\"Submit an action to be processed.\n\n        Args:\n            action (UserAction): the action the user has performed.\n            payload (Any): the data to send, defaults to None.\n        \"\"\"\n        self.add_item(UserActionMessage(action, payload))\n\n    def get_action(self) -&gt; UserActionMessage:\n        \"\"\"Get the latest action the user has performed.\n\n        This is blocking.\n\n        Returns:\n            UserActionMessage: the action that has been performed\n        \"\"\"\n        return self.get_item_blocking()\n\n    def get_action_non_blocking(self) -&gt; UserActionMessage:\n        \"\"\"Get the latest action the user has performed.\n\n        This is blocking.\n\n        Returns:\n            UserActionMessage: the action that has been performed\n        \"\"\"\n        return self.get_item_non_blocking()\n</code></pre>"},{"location":"reference/controller/user_action_bridge/#src.controller.user_action_bridge.UserActionBridge.get_action","title":"<code>get_action()</code>","text":"<p>Get the latest action the user has performed.</p> <p>This is blocking.</p> <p>Returns:</p> Name Type Description <code>UserActionMessage</code> <code>UserActionMessage</code> <p>the action that has been performed</p> Source code in <code>src/controller/user_action_bridge.py</code> <pre><code>def get_action(self) -&gt; UserActionMessage:\n    \"\"\"Get the latest action the user has performed.\n\n    This is blocking.\n\n    Returns:\n        UserActionMessage: the action that has been performed\n    \"\"\"\n    return self.get_item_blocking()\n</code></pre>"},{"location":"reference/controller/user_action_bridge/#src.controller.user_action_bridge.UserActionBridge.get_action_non_blocking","title":"<code>get_action_non_blocking()</code>","text":"<p>Get the latest action the user has performed.</p> <p>This is blocking.</p> <p>Returns:</p> Name Type Description <code>UserActionMessage</code> <code>UserActionMessage</code> <p>the action that has been performed</p> Source code in <code>src/controller/user_action_bridge.py</code> <pre><code>def get_action_non_blocking(self) -&gt; UserActionMessage:\n    \"\"\"Get the latest action the user has performed.\n\n    This is blocking.\n\n    Returns:\n        UserActionMessage: the action that has been performed\n    \"\"\"\n    return self.get_item_non_blocking()\n</code></pre>"},{"location":"reference/controller/user_action_bridge/#src.controller.user_action_bridge.UserActionBridge.submit_action","title":"<code>submit_action(action, payload=None)</code>","text":"<p>Submit an action to be processed.</p> <p>Parameters:</p> Name Type Description Default <code>action</code> <code>UserAction</code> <p>the action the user has performed.</p> required <code>payload</code> <code>Any</code> <p>the data to send, defaults to None.</p> <code>None</code> Source code in <code>src/controller/user_action_bridge.py</code> <pre><code>def submit_action(self, action: UserAction, payload: Any = None):\n    \"\"\"Submit an action to be processed.\n\n    Args:\n        action (UserAction): the action the user has performed.\n        payload (Any): the data to send, defaults to None.\n    \"\"\"\n    self.add_item(UserActionMessage(action, payload))\n</code></pre>"},{"location":"reference/controller/user_action_bridge/#src.controller.user_action_bridge.UserActionMessage","title":"<code>UserActionMessage</code>","text":"<p>             Bases: <code>object</code></p> <p>Encapsulates a user action and its data.</p> Source code in <code>src/controller/user_action_bridge.py</code> <pre><code>class UserActionMessage(object):\n    \"\"\"Encapsulates a user action and its data.\"\"\"\n\n    def __init__(self, action: UserAction, payload: Any = None) -&gt; None:\n        \"\"\"Create a user action object.\n\n        Args:\n            action (UserAction): the action to be performed\n            payload (Any): any related data\n        \"\"\"\n        self.action = action\n        self.payload = payload\n</code></pre>"},{"location":"reference/controller/user_action_bridge/#src.controller.user_action_bridge.UserActionMessage.__init__","title":"<code>__init__(action, payload=None)</code>","text":"<p>Create a user action object.</p> <p>Parameters:</p> Name Type Description Default <code>action</code> <code>UserAction</code> <p>the action to be performed</p> required <code>payload</code> <code>Any</code> <p>any related data</p> <code>None</code> Source code in <code>src/controller/user_action_bridge.py</code> <pre><code>def __init__(self, action: UserAction, payload: Any = None) -&gt; None:\n    \"\"\"Create a user action object.\n\n    Args:\n        action (UserAction): the action to be performed\n        payload (Any): any related data\n    \"\"\"\n    self.action = action\n    self.payload = payload\n</code></pre>"},{"location":"reference/model/","title":"Model","text":"<p>This Package contains the model.</p> <p>The model is the reinforcement learning code</p>"},{"location":"reference/model/agents/","title":"Agents","text":"<p>This package contains the agents.</p> <p>the agents should that will learn and generate policies</p>"},{"location":"reference/model/agents/base_agent/","title":"Base Agent","text":""},{"location":"reference/model/agents/base_agent/#src.model.agents.base_agent.BaseAgent","title":"<code>BaseAgent</code>","text":"<p>             Bases: <code>object</code></p> <p>Provides the common base for different learning agents.</p> Source code in <code>src/model/agents/base_agent.py</code> <pre><code>class BaseAgent(object):\n    \"\"\"Provides the common base for different learning agents.\"\"\"\n\n    def __init__(self, config: AgentConfig) -&gt; None:\n        \"\"\"Initialise an agent.\n\n        Args:\n            config (AgentConfig): the configuration for the agent.\n        \"\"\"\n        self.config = config\n\n    def evaluate_policy(self, state: int) -&gt; Action:\n        \"\"\"Decide on the action this agent would take in a given state.\n\n        Args:\n            state (int): the state the agent is performing this action\n\n        Raises:\n            NotImplementedError: If this method has not been overridden by\n                concrete agent.\n\n        Returns:\n            Action: the action to take in this state\n        \"\"\"\n        self.__throw_not_implemented()\n        return Action.down\n\n    def record_transition(\n        self,\n        previous_state: int,\n        previous_action: Action,\n        new_state: int,\n        reward: float,\n    ) -&gt; None:\n        \"\"\"Provide the agent with the information from a transition.\n\n        Args:\n            previous_state (int): the state before the action was taken\n            previous_action (Action): the action that was taken.\n            new_state (int): The resulting state after the action has been taken\n            reward (float): the reward for performing this action\n\n        Raises:\n            NotImplementedError: If this method has not been overridden by\n                concrete agent.\n        \"\"\"\n        self.__throw_not_implemented()\n\n    def get_state_value(self, state: int) -&gt; float:\n        \"\"\"Get the agents interpretation of the value of this state.\n\n        Args:\n            state (int): the state to evaluate\n\n        Raises:\n            NotImplementedError: If this method has not been overridden by\n                concrete agent.\n\n        Returns:\n            float: the agents interpretation of the value of this state\n        \"\"\"\n        self.__throw_not_implemented()\n        return 0\n\n    def get_state_action_value(self, state: int, action: Action) -&gt; float:\n        \"\"\"Get the agents interpretation of an actions value.\n\n        allows for visualisations to be made\n\n        Args:\n            state (int): the state to perform the action in\n            action (Action): the action to evaluate\n\n        Raises:\n            NotImplementedError: If this method has not been overridden by\n                concrete agent.\n\n        Returns:\n            float: the agents interpretation of the value of this state and\n            action\n        \"\"\"\n        self.__throw_not_implemented()\n        return 0\n\n    def __throw_not_implemented(self):\n        raise NotImplementedError(\n            \"This method must be overridden by concrete agent\"\n        )\n</code></pre>"},{"location":"reference/model/agents/base_agent/#src.model.agents.base_agent.BaseAgent.__init__","title":"<code>__init__(config)</code>","text":"<p>Initialise an agent.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>AgentConfig</code> <p>the configuration for the agent.</p> required Source code in <code>src/model/agents/base_agent.py</code> <pre><code>def __init__(self, config: AgentConfig) -&gt; None:\n    \"\"\"Initialise an agent.\n\n    Args:\n        config (AgentConfig): the configuration for the agent.\n    \"\"\"\n    self.config = config\n</code></pre>"},{"location":"reference/model/agents/base_agent/#src.model.agents.base_agent.BaseAgent.evaluate_policy","title":"<code>evaluate_policy(state)</code>","text":"<p>Decide on the action this agent would take in a given state.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>int</code> <p>the state the agent is performing this action</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If this method has not been overridden by concrete agent.</p> <p>Returns:</p> Name Type Description <code>Action</code> <code>Action</code> <p>the action to take in this state</p> Source code in <code>src/model/agents/base_agent.py</code> <pre><code>def evaluate_policy(self, state: int) -&gt; Action:\n    \"\"\"Decide on the action this agent would take in a given state.\n\n    Args:\n        state (int): the state the agent is performing this action\n\n    Raises:\n        NotImplementedError: If this method has not been overridden by\n            concrete agent.\n\n    Returns:\n        Action: the action to take in this state\n    \"\"\"\n    self.__throw_not_implemented()\n    return Action.down\n</code></pre>"},{"location":"reference/model/agents/base_agent/#src.model.agents.base_agent.BaseAgent.get_state_action_value","title":"<code>get_state_action_value(state, action)</code>","text":"<p>Get the agents interpretation of an actions value.</p> <p>allows for visualisations to be made</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>int</code> <p>the state to perform the action in</p> required <code>action</code> <code>Action</code> <p>the action to evaluate</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If this method has not been overridden by concrete agent.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the agents interpretation of the value of this state and</p> <code>float</code> <p>action</p> Source code in <code>src/model/agents/base_agent.py</code> <pre><code>def get_state_action_value(self, state: int, action: Action) -&gt; float:\n    \"\"\"Get the agents interpretation of an actions value.\n\n    allows for visualisations to be made\n\n    Args:\n        state (int): the state to perform the action in\n        action (Action): the action to evaluate\n\n    Raises:\n        NotImplementedError: If this method has not been overridden by\n            concrete agent.\n\n    Returns:\n        float: the agents interpretation of the value of this state and\n        action\n    \"\"\"\n    self.__throw_not_implemented()\n    return 0\n</code></pre>"},{"location":"reference/model/agents/base_agent/#src.model.agents.base_agent.BaseAgent.get_state_value","title":"<code>get_state_value(state)</code>","text":"<p>Get the agents interpretation of the value of this state.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>int</code> <p>the state to evaluate</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If this method has not been overridden by concrete agent.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the agents interpretation of the value of this state</p> Source code in <code>src/model/agents/base_agent.py</code> <pre><code>def get_state_value(self, state: int) -&gt; float:\n    \"\"\"Get the agents interpretation of the value of this state.\n\n    Args:\n        state (int): the state to evaluate\n\n    Raises:\n        NotImplementedError: If this method has not been overridden by\n            concrete agent.\n\n    Returns:\n        float: the agents interpretation of the value of this state\n    \"\"\"\n    self.__throw_not_implemented()\n    return 0\n</code></pre>"},{"location":"reference/model/agents/base_agent/#src.model.agents.base_agent.BaseAgent.record_transition","title":"<code>record_transition(previous_state, previous_action, new_state, reward)</code>","text":"<p>Provide the agent with the information from a transition.</p> <p>Parameters:</p> Name Type Description Default <code>previous_state</code> <code>int</code> <p>the state before the action was taken</p> required <code>previous_action</code> <code>Action</code> <p>the action that was taken.</p> required <code>new_state</code> <code>int</code> <p>The resulting state after the action has been taken</p> required <code>reward</code> <code>float</code> <p>the reward for performing this action</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If this method has not been overridden by concrete agent.</p> Source code in <code>src/model/agents/base_agent.py</code> <pre><code>def record_transition(\n    self,\n    previous_state: int,\n    previous_action: Action,\n    new_state: int,\n    reward: float,\n) -&gt; None:\n    \"\"\"Provide the agent with the information from a transition.\n\n    Args:\n        previous_state (int): the state before the action was taken\n        previous_action (Action): the action that was taken.\n        new_state (int): The resulting state after the action has been taken\n        reward (float): the reward for performing this action\n\n    Raises:\n        NotImplementedError: If this method has not been overridden by\n            concrete agent.\n    \"\"\"\n    self.__throw_not_implemented()\n</code></pre>"},{"location":"reference/model/agents/q_learning/","title":"Q Learning","text":"<p>This package contains the code for a Q-learning agent.</p>"},{"location":"reference/model/agents/q_learning/agent/","title":"Agent","text":""},{"location":"reference/model/agents/q_learning/agent/#src.model.agents.q_learning.agent.QLearningAgent","title":"<code>QLearningAgent</code>","text":"<p>             Bases: <code>BaseAgent</code></p> <p>Agent that learns q-value table to make decisions.</p> Source code in <code>src/model/agents/q_learning/agent.py</code> <pre><code>class QLearningAgent(BaseAgent):\n    \"\"\"Agent that learns q-value table to make decisions.\"\"\"\n\n    replay_queue_length = 10\n\n    def __init__(\n        self, config: AgentConfig, strategy: ExplorationStrategyOptions\n    ) -&gt; None:\n        \"\"\"Initialise the agent.\n\n        Args:\n            config (AgentConfig): the configuration for the agent.\n            strategy (ExplorationStrategyOptions): The strategy the agent should\n                use to select actions.\n        \"\"\"\n        super().__init__(config)\n        self.strategy = self.set_exploration_strategy(strategy)\n        self.table = DynamicQTable(config.learning_rate())\n        self.observation_queue = RewardReplayQueue(\n            self.table, self.replay_queue_length, config.discount_rate()\n        )\n\n    def set_exploration_strategy(\n        self, strategy: ExplorationStrategyOptions\n    ) -&gt; BaseExplorationStrategy:\n        \"\"\"Set the current strategy used by the agent.\n\n        Args:\n            strategy (ExplorationStrategyOptions): specifies the strategy to\n                use.\n\n        Raises:\n            ValueError: if an invalid strategy is provided\n\n        Returns:\n            BaseExplorationStrategy: the new strategy the agent will use.\n        \"\"\"\n        match strategy:\n            case ExplorationStrategyOptions.epsilon_greedy:\n                self.strategy = EpsilonGreedyStrategy(self)\n            case _:\n                raise ValueError(f\"Unknown strategy provided {strategy}\")\n\n        return self.strategy\n\n    def get_state_action_value(self, state: int, action: Action) -&gt; float:\n        \"\"\"Get the agents interpretation value of a given state-action.\n\n        Args:\n            state (int): the state the action is performed in\n            action (Action): the action to get the value of\n\n        Returns:\n            float: the expected value for this state and action\n        \"\"\"\n        return self.table.get_value(state, action)\n\n    def get_state_value(self, state: int) -&gt; float:\n        \"\"\"Get the agents interpretation of the value of this state.\n\n        Args:\n            state (int): the state to evaluate\n\n        Returns:\n            float: the agents interpretation of the value of this state\n        \"\"\"\n        return self.table.calculate_state_value(state)\n\n    def evaluate_policy(self, state: int) -&gt; Action:\n        \"\"\"Decide on the action this agent would take in a given state.\n\n        Args:\n            state (int): the state the agent is performing this action\n\n        Returns:\n            Action: the action to take in this state\n        \"\"\"\n        return self.strategy.select_action(state)\n\n    def record_transition(\n        self,\n        previous_state: int,\n        previous_action: Action,\n        new_state: int,\n        reward: float,\n    ) -&gt; None:\n        \"\"\"Provide the agent with the information from a transition.\n\n        Args:\n            previous_state (int): the state before the action was taken\n            previous_action (Action): the action that was taken.\n            new_state (int): The resulting state after the action has been taken\n            reward (float): the reward for performing this action\n\n        \"\"\"\n        self.observation_queue.add_observation(\n            previous_state, previous_action, new_state, reward\n        )\n</code></pre>"},{"location":"reference/model/agents/q_learning/agent/#src.model.agents.q_learning.agent.QLearningAgent.__init__","title":"<code>__init__(config, strategy)</code>","text":"<p>Initialise the agent.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>AgentConfig</code> <p>the configuration for the agent.</p> required <code>strategy</code> <code>ExplorationStrategyOptions</code> <p>The strategy the agent should use to select actions.</p> required Source code in <code>src/model/agents/q_learning/agent.py</code> <pre><code>def __init__(\n    self, config: AgentConfig, strategy: ExplorationStrategyOptions\n) -&gt; None:\n    \"\"\"Initialise the agent.\n\n    Args:\n        config (AgentConfig): the configuration for the agent.\n        strategy (ExplorationStrategyOptions): The strategy the agent should\n            use to select actions.\n    \"\"\"\n    super().__init__(config)\n    self.strategy = self.set_exploration_strategy(strategy)\n    self.table = DynamicQTable(config.learning_rate())\n    self.observation_queue = RewardReplayQueue(\n        self.table, self.replay_queue_length, config.discount_rate()\n    )\n</code></pre>"},{"location":"reference/model/agents/q_learning/agent/#src.model.agents.q_learning.agent.QLearningAgent.evaluate_policy","title":"<code>evaluate_policy(state)</code>","text":"<p>Decide on the action this agent would take in a given state.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>int</code> <p>the state the agent is performing this action</p> required <p>Returns:</p> Name Type Description <code>Action</code> <code>Action</code> <p>the action to take in this state</p> Source code in <code>src/model/agents/q_learning/agent.py</code> <pre><code>def evaluate_policy(self, state: int) -&gt; Action:\n    \"\"\"Decide on the action this agent would take in a given state.\n\n    Args:\n        state (int): the state the agent is performing this action\n\n    Returns:\n        Action: the action to take in this state\n    \"\"\"\n    return self.strategy.select_action(state)\n</code></pre>"},{"location":"reference/model/agents/q_learning/agent/#src.model.agents.q_learning.agent.QLearningAgent.get_state_action_value","title":"<code>get_state_action_value(state, action)</code>","text":"<p>Get the agents interpretation value of a given state-action.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>int</code> <p>the state the action is performed in</p> required <code>action</code> <code>Action</code> <p>the action to get the value of</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the expected value for this state and action</p> Source code in <code>src/model/agents/q_learning/agent.py</code> <pre><code>def get_state_action_value(self, state: int, action: Action) -&gt; float:\n    \"\"\"Get the agents interpretation value of a given state-action.\n\n    Args:\n        state (int): the state the action is performed in\n        action (Action): the action to get the value of\n\n    Returns:\n        float: the expected value for this state and action\n    \"\"\"\n    return self.table.get_value(state, action)\n</code></pre>"},{"location":"reference/model/agents/q_learning/agent/#src.model.agents.q_learning.agent.QLearningAgent.get_state_value","title":"<code>get_state_value(state)</code>","text":"<p>Get the agents interpretation of the value of this state.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>int</code> <p>the state to evaluate</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the agents interpretation of the value of this state</p> Source code in <code>src/model/agents/q_learning/agent.py</code> <pre><code>def get_state_value(self, state: int) -&gt; float:\n    \"\"\"Get the agents interpretation of the value of this state.\n\n    Args:\n        state (int): the state to evaluate\n\n    Returns:\n        float: the agents interpretation of the value of this state\n    \"\"\"\n    return self.table.calculate_state_value(state)\n</code></pre>"},{"location":"reference/model/agents/q_learning/agent/#src.model.agents.q_learning.agent.QLearningAgent.record_transition","title":"<code>record_transition(previous_state, previous_action, new_state, reward)</code>","text":"<p>Provide the agent with the information from a transition.</p> <p>Parameters:</p> Name Type Description Default <code>previous_state</code> <code>int</code> <p>the state before the action was taken</p> required <code>previous_action</code> <code>Action</code> <p>the action that was taken.</p> required <code>new_state</code> <code>int</code> <p>The resulting state after the action has been taken</p> required <code>reward</code> <code>float</code> <p>the reward for performing this action</p> required Source code in <code>src/model/agents/q_learning/agent.py</code> <pre><code>def record_transition(\n    self,\n    previous_state: int,\n    previous_action: Action,\n    new_state: int,\n    reward: float,\n) -&gt; None:\n    \"\"\"Provide the agent with the information from a transition.\n\n    Args:\n        previous_state (int): the state before the action was taken\n        previous_action (Action): the action that was taken.\n        new_state (int): The resulting state after the action has been taken\n        reward (float): the reward for performing this action\n\n    \"\"\"\n    self.observation_queue.add_observation(\n        previous_state, previous_action, new_state, reward\n    )\n</code></pre>"},{"location":"reference/model/agents/q_learning/agent/#src.model.agents.q_learning.agent.QLearningAgent.set_exploration_strategy","title":"<code>set_exploration_strategy(strategy)</code>","text":"<p>Set the current strategy used by the agent.</p> <p>Parameters:</p> Name Type Description Default <code>strategy</code> <code>ExplorationStrategyOptions</code> <p>specifies the strategy to use.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>if an invalid strategy is provided</p> <p>Returns:</p> Name Type Description <code>BaseExplorationStrategy</code> <code>BaseExplorationStrategy</code> <p>the new strategy the agent will use.</p> Source code in <code>src/model/agents/q_learning/agent.py</code> <pre><code>def set_exploration_strategy(\n    self, strategy: ExplorationStrategyOptions\n) -&gt; BaseExplorationStrategy:\n    \"\"\"Set the current strategy used by the agent.\n\n    Args:\n        strategy (ExplorationStrategyOptions): specifies the strategy to\n            use.\n\n    Raises:\n        ValueError: if an invalid strategy is provided\n\n    Returns:\n        BaseExplorationStrategy: the new strategy the agent will use.\n    \"\"\"\n    match strategy:\n        case ExplorationStrategyOptions.epsilon_greedy:\n            self.strategy = EpsilonGreedyStrategy(self)\n        case _:\n            raise ValueError(f\"Unknown strategy provided {strategy}\")\n\n    return self.strategy\n</code></pre>"},{"location":"reference/model/agents/q_learning/dynamic_q_table/","title":"Dynamic Q Table","text":""},{"location":"reference/model/agents/q_learning/dynamic_q_table/#src.model.agents.q_learning.dynamic_q_table.DynamicQTable","title":"<code>DynamicQTable</code>","text":"<p>             Bases: <code>object</code></p> <p>Class for storing and recalling action-state values.</p> Source code in <code>src/model/agents/q_learning/dynamic_q_table.py</code> <pre><code>class DynamicQTable(object):\n    \"\"\"Class for storing and recalling action-state values.\"\"\"\n\n    def __init__(self, learning_rate: float) -&gt; None:\n        \"\"\"Initialise a new blank Q Table.\n\n        Args:\n            learning_rate (float): the rate at which to change the value with\n                each update.\n        \"\"\"\n        self.table: Dict[Tuple[int, Action], float] = {}\n        self.learning_rate = learning_rate\n\n    def update_value(self, state: int, action: Action, q_value: float):\n        \"\"\"Update the value at state and action based upon some observation.\n\n        the amount the value is changed depends on the magnitude of the learning\n        rate.\n\n        Args:\n            state (int): the state the action is performed in\n            action (Action): the action to update the value for\n            q_value (float): the new observation of the Q value\n        \"\"\"\n        existing_value = self.get_value(state, action)\n        new_value = existing_value + self.learning_rate * (\n            q_value - existing_value\n        )\n        self.set_value(state, action, new_value)\n\n    def set_value(self, state: int, action: Action, q_value: float):\n        \"\"\"Set the value of a given state action pair.\n\n        This will overwrite any existing data.\n\n        Args:\n            state (int): the state the action is performed in\n            action (Action): the action to update the value for\n            q_value (float): the new value of this state action pair.\n        \"\"\"\n        self.table[(state, action)] = q_value\n\n    def get_value(self, state: int, action: Action) -&gt; float:\n        \"\"\"Get the current value of a give state and action.\n\n        if the state and action has no existing value associated with it then a\n          new value in the range 0-1 will be chosen\n\n        Args:\n            state (int): the state the action is performed in\n            action (Action): the action to get the value for\n\n        Returns:\n            float: current stored value at the given state-action pair.\n        \"\"\"\n        key = (state, action)\n        existing_value = self.table.get(key, None)\n        if existing_value is not None:\n            return existing_value\n        new_value = self.__default_value()\n        self.table[key] = new_value\n        return new_value\n\n    def calculate_state_value(self, state: int) -&gt; float:\n        \"\"\"Calculate a state value.\n\n        based upon the current action value table and a policy that picks the\n        most valuable action.\n\n        Args:\n            state (int): the state to get the value for\n\n        Returns:\n            float: the value of the state.\n        \"\"\"\n        best_action_value = float(\"-inf\")\n        for action in Action:\n            action_value = self.get_value(state, action)\n            best_action_value = max(best_action_value, action_value)\n        return best_action_value\n\n    def __default_value(self) -&gt; float:\n        # optimistic value shown to reduce bias\n        return np.random.rand() * self.learning_rate + 1\n</code></pre>"},{"location":"reference/model/agents/q_learning/dynamic_q_table/#src.model.agents.q_learning.dynamic_q_table.DynamicQTable.__init__","title":"<code>__init__(learning_rate)</code>","text":"<p>Initialise a new blank Q Table.</p> <p>Parameters:</p> Name Type Description Default <code>learning_rate</code> <code>float</code> <p>the rate at which to change the value with each update.</p> required Source code in <code>src/model/agents/q_learning/dynamic_q_table.py</code> <pre><code>def __init__(self, learning_rate: float) -&gt; None:\n    \"\"\"Initialise a new blank Q Table.\n\n    Args:\n        learning_rate (float): the rate at which to change the value with\n            each update.\n    \"\"\"\n    self.table: Dict[Tuple[int, Action], float] = {}\n    self.learning_rate = learning_rate\n</code></pre>"},{"location":"reference/model/agents/q_learning/dynamic_q_table/#src.model.agents.q_learning.dynamic_q_table.DynamicQTable.calculate_state_value","title":"<code>calculate_state_value(state)</code>","text":"<p>Calculate a state value.</p> <p>based upon the current action value table and a policy that picks the most valuable action.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>int</code> <p>the state to get the value for</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the value of the state.</p> Source code in <code>src/model/agents/q_learning/dynamic_q_table.py</code> <pre><code>def calculate_state_value(self, state: int) -&gt; float:\n    \"\"\"Calculate a state value.\n\n    based upon the current action value table and a policy that picks the\n    most valuable action.\n\n    Args:\n        state (int): the state to get the value for\n\n    Returns:\n        float: the value of the state.\n    \"\"\"\n    best_action_value = float(\"-inf\")\n    for action in Action:\n        action_value = self.get_value(state, action)\n        best_action_value = max(best_action_value, action_value)\n    return best_action_value\n</code></pre>"},{"location":"reference/model/agents/q_learning/dynamic_q_table/#src.model.agents.q_learning.dynamic_q_table.DynamicQTable.get_value","title":"<code>get_value(state, action)</code>","text":"<p>Get the current value of a give state and action.</p> <p>if the state and action has no existing value associated with it then a   new value in the range 0-1 will be chosen</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>int</code> <p>the state the action is performed in</p> required <code>action</code> <code>Action</code> <p>the action to get the value for</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>current stored value at the given state-action pair.</p> Source code in <code>src/model/agents/q_learning/dynamic_q_table.py</code> <pre><code>def get_value(self, state: int, action: Action) -&gt; float:\n    \"\"\"Get the current value of a give state and action.\n\n    if the state and action has no existing value associated with it then a\n      new value in the range 0-1 will be chosen\n\n    Args:\n        state (int): the state the action is performed in\n        action (Action): the action to get the value for\n\n    Returns:\n        float: current stored value at the given state-action pair.\n    \"\"\"\n    key = (state, action)\n    existing_value = self.table.get(key, None)\n    if existing_value is not None:\n        return existing_value\n    new_value = self.__default_value()\n    self.table[key] = new_value\n    return new_value\n</code></pre>"},{"location":"reference/model/agents/q_learning/dynamic_q_table/#src.model.agents.q_learning.dynamic_q_table.DynamicQTable.set_value","title":"<code>set_value(state, action, q_value)</code>","text":"<p>Set the value of a given state action pair.</p> <p>This will overwrite any existing data.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>int</code> <p>the state the action is performed in</p> required <code>action</code> <code>Action</code> <p>the action to update the value for</p> required <code>q_value</code> <code>float</code> <p>the new value of this state action pair.</p> required Source code in <code>src/model/agents/q_learning/dynamic_q_table.py</code> <pre><code>def set_value(self, state: int, action: Action, q_value: float):\n    \"\"\"Set the value of a given state action pair.\n\n    This will overwrite any existing data.\n\n    Args:\n        state (int): the state the action is performed in\n        action (Action): the action to update the value for\n        q_value (float): the new value of this state action pair.\n    \"\"\"\n    self.table[(state, action)] = q_value\n</code></pre>"},{"location":"reference/model/agents/q_learning/dynamic_q_table/#src.model.agents.q_learning.dynamic_q_table.DynamicQTable.update_value","title":"<code>update_value(state, action, q_value)</code>","text":"<p>Update the value at state and action based upon some observation.</p> <p>the amount the value is changed depends on the magnitude of the learning rate.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>int</code> <p>the state the action is performed in</p> required <code>action</code> <code>Action</code> <p>the action to update the value for</p> required <code>q_value</code> <code>float</code> <p>the new observation of the Q value</p> required Source code in <code>src/model/agents/q_learning/dynamic_q_table.py</code> <pre><code>def update_value(self, state: int, action: Action, q_value: float):\n    \"\"\"Update the value at state and action based upon some observation.\n\n    the amount the value is changed depends on the magnitude of the learning\n    rate.\n\n    Args:\n        state (int): the state the action is performed in\n        action (Action): the action to update the value for\n        q_value (float): the new observation of the Q value\n    \"\"\"\n    existing_value = self.get_value(state, action)\n    new_value = existing_value + self.learning_rate * (\n        q_value - existing_value\n    )\n    self.set_value(state, action, new_value)\n</code></pre>"},{"location":"reference/model/agents/q_learning/reward_replay_queue/","title":"Reward Replay Queue","text":""},{"location":"reference/model/agents/q_learning/reward_replay_queue/#src.model.agents.q_learning.reward_replay_queue.RewardReplayQueue","title":"<code>RewardReplayQueue</code>","text":"<p>             Bases: <code>object</code></p> <p>A Queue for recording previous actions and replaying them.</p> <p>To allow for faster convergence and backwards propagation of value.</p> Source code in <code>src/model/agents/q_learning/reward_replay_queue.py</code> <pre><code>class RewardReplayQueue(object):\n    \"\"\"A Queue for recording previous actions and replaying them.\n\n    To allow for faster convergence and backwards propagation of value.\n    \"\"\"\n\n    def __init__(\n        self, q_table: DynamicQTable, queue_length: int, discount_rate: float\n    ) -&gt; None:\n        \"\"\"Create a new replay queue.\n\n        Args:\n            q_table (DynamicQTable): the q value table to update\n            queue_length (int): the maximum length of the queue.\n            discount_rate (float): the amount to discount future rewards.\n        \"\"\"\n        self.max_queue_length = queue_length\n        self.table = q_table\n        self.queue: List[observation_type] = []\n        self.discount_rate = discount_rate\n\n    def add_observation(\n        self,\n        previous_state: int,\n        previous_action: Action,\n        new_state: int,\n        reward: float,\n    ):\n        \"\"\"Add a new observation to the end of the queue.\n\n        Args:\n            previous_state (int): the state before the action was taken\n            previous_action (Action): the action that was taken.\n            new_state (int): The resulting state after the action has been taken\n            reward (float): the reward for performing this action\n        \"\"\"\n        self.__add_item((previous_state, previous_action, new_state, reward))\n        for observation in reversed(self.queue):\n            self.__update_q_value(observation)\n\n    def __update_q_value(self, observation: observation_type):\n        (previous_state, previous_action, new_state, reward) = observation\n\n        observed_value = (\n            reward\n            + self.discount_rate * self.table.calculate_state_value(new_state)\n        )\n        self.table.update_value(previous_state, previous_action, observed_value)\n\n    def __add_item(self, observation: observation_type):\n        self.queue.append(observation)\n        if len(self.queue) &gt; self.max_queue_length:\n            self.queue.pop(0)\n</code></pre>"},{"location":"reference/model/agents/q_learning/reward_replay_queue/#src.model.agents.q_learning.reward_replay_queue.RewardReplayQueue.__init__","title":"<code>__init__(q_table, queue_length, discount_rate)</code>","text":"<p>Create a new replay queue.</p> <p>Parameters:</p> Name Type Description Default <code>q_table</code> <code>DynamicQTable</code> <p>the q value table to update</p> required <code>queue_length</code> <code>int</code> <p>the maximum length of the queue.</p> required <code>discount_rate</code> <code>float</code> <p>the amount to discount future rewards.</p> required Source code in <code>src/model/agents/q_learning/reward_replay_queue.py</code> <pre><code>def __init__(\n    self, q_table: DynamicQTable, queue_length: int, discount_rate: float\n) -&gt; None:\n    \"\"\"Create a new replay queue.\n\n    Args:\n        q_table (DynamicQTable): the q value table to update\n        queue_length (int): the maximum length of the queue.\n        discount_rate (float): the amount to discount future rewards.\n    \"\"\"\n    self.max_queue_length = queue_length\n    self.table = q_table\n    self.queue: List[observation_type] = []\n    self.discount_rate = discount_rate\n</code></pre>"},{"location":"reference/model/agents/q_learning/reward_replay_queue/#src.model.agents.q_learning.reward_replay_queue.RewardReplayQueue.add_observation","title":"<code>add_observation(previous_state, previous_action, new_state, reward)</code>","text":"<p>Add a new observation to the end of the queue.</p> <p>Parameters:</p> Name Type Description Default <code>previous_state</code> <code>int</code> <p>the state before the action was taken</p> required <code>previous_action</code> <code>Action</code> <p>the action that was taken.</p> required <code>new_state</code> <code>int</code> <p>The resulting state after the action has been taken</p> required <code>reward</code> <code>float</code> <p>the reward for performing this action</p> required Source code in <code>src/model/agents/q_learning/reward_replay_queue.py</code> <pre><code>def add_observation(\n    self,\n    previous_state: int,\n    previous_action: Action,\n    new_state: int,\n    reward: float,\n):\n    \"\"\"Add a new observation to the end of the queue.\n\n    Args:\n        previous_state (int): the state before the action was taken\n        previous_action (Action): the action that was taken.\n        new_state (int): The resulting state after the action has been taken\n        reward (float): the reward for performing this action\n    \"\"\"\n    self.__add_item((previous_state, previous_action, new_state, reward))\n    for observation in reversed(self.queue):\n        self.__update_q_value(observation)\n</code></pre>"},{"location":"reference/model/agents/q_learning/exploration_strategies/","title":"Exploration Strategies","text":"<p>This packages contains all of the different exploration strategies.</p> <p>the exploration strategies pick actions for the agent based upon some metric.</p>"},{"location":"reference/model/agents/q_learning/exploration_strategies/base_strategy/","title":"Base Strategy","text":""},{"location":"reference/model/agents/q_learning/exploration_strategies/base_strategy/#src.model.agents.q_learning.exploration_strategies.base_strategy.BaseExplorationStrategy","title":"<code>BaseExplorationStrategy</code>","text":"<p>             Bases: <code>object</code></p> <p>Provides the common base for different exploration strategies.</p> Source code in <code>src/model/agents/q_learning/exploration_strategies/base_strategy.py</code> <pre><code>class BaseExplorationStrategy(object):\n    \"\"\"Provides the common base for different exploration strategies.\"\"\"\n\n    def __init__(self, agent: BaseAgent) -&gt; None:\n        \"\"\"Initialise the Exploration strategy.\n\n        Args:\n            agent (BaseAgent): The agent that uses this strategy.\n        \"\"\"\n        self.agent = agent\n        self.config = ConfigReader().agent()\n\n    def select_action(self, state: int) -&gt; Action:\n        \"\"\"Select the action based upon this strategy.\n\n        Args:\n            state (int): the state where this action will be performed\n\n        Raises:\n            NotImplementedError: If this method has not been overridden by a\n                concrete strategy.\n\n        Returns:\n            Action: The action the agent should perform\n        \"\"\"\n        self.__throw_not_implemented()\n        return Action.up\n\n    def __throw_not_implemented(self):\n        raise NotImplementedError(\n            \"This method must be overridden by concrete strategy\"\n        )\n</code></pre>"},{"location":"reference/model/agents/q_learning/exploration_strategies/base_strategy/#src.model.agents.q_learning.exploration_strategies.base_strategy.BaseExplorationStrategy.__init__","title":"<code>__init__(agent)</code>","text":"<p>Initialise the Exploration strategy.</p> <p>Parameters:</p> Name Type Description Default <code>agent</code> <code>BaseAgent</code> <p>The agent that uses this strategy.</p> required Source code in <code>src/model/agents/q_learning/exploration_strategies/base_strategy.py</code> <pre><code>def __init__(self, agent: BaseAgent) -&gt; None:\n    \"\"\"Initialise the Exploration strategy.\n\n    Args:\n        agent (BaseAgent): The agent that uses this strategy.\n    \"\"\"\n    self.agent = agent\n    self.config = ConfigReader().agent()\n</code></pre>"},{"location":"reference/model/agents/q_learning/exploration_strategies/base_strategy/#src.model.agents.q_learning.exploration_strategies.base_strategy.BaseExplorationStrategy.select_action","title":"<code>select_action(state)</code>","text":"<p>Select the action based upon this strategy.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>int</code> <p>the state where this action will be performed</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If this method has not been overridden by a concrete strategy.</p> <p>Returns:</p> Name Type Description <code>Action</code> <code>Action</code> <p>The action the agent should perform</p> Source code in <code>src/model/agents/q_learning/exploration_strategies/base_strategy.py</code> <pre><code>def select_action(self, state: int) -&gt; Action:\n    \"\"\"Select the action based upon this strategy.\n\n    Args:\n        state (int): the state where this action will be performed\n\n    Raises:\n        NotImplementedError: If this method has not been overridden by a\n            concrete strategy.\n\n    Returns:\n        Action: The action the agent should perform\n    \"\"\"\n    self.__throw_not_implemented()\n    return Action.up\n</code></pre>"},{"location":"reference/model/agents/q_learning/exploration_strategies/epsilon_greedy_strategy/","title":"Epsilon Greedy Strategy","text":""},{"location":"reference/model/agents/q_learning/exploration_strategies/epsilon_greedy_strategy/#src.model.agents.q_learning.exploration_strategies.epsilon_greedy_strategy.EpsilonGreedyStrategy","title":"<code>EpsilonGreedyStrategy</code>","text":"<p>             Bases: <code>BaseExplorationStrategy</code></p> <p>This class implements the epsilon greedy strategy.</p> <p>Selects the agents current understanding of what the best action is with a fixed probability of exploring. to explore the agent picks any action at random.</p> <p>In the case of ties this strategy selects randomly between the best options.</p> Source code in <code>src/model/agents/q_learning/exploration_strategies/epsilon_greedy_strategy.py</code> <pre><code>class EpsilonGreedyStrategy(BaseExplorationStrategy):\n    \"\"\"This class implements the epsilon greedy strategy.\n\n    Selects the agents current understanding of what the best action is with a\n    fixed probability of exploring. to explore the agent picks any action at\n    random.\n\n    In the case of ties this strategy selects randomly between the best options.\n    \"\"\"\n\n    def select_action(self, state: int) -&gt; Action:\n        \"\"\"Select the action based upon the epsilon greedy strategy.\n\n        this strategy picks the best action based upon the value table with a\n        given chance of selecting any action.\n\n        Args:\n            state (int): the state to select the action for.\n\n        Returns:\n            Action: the action the agent should select.\n        \"\"\"\n        best_action = choice(list(Action))\n        if random() &lt; self.config.exploration_ratio():\n            return best_action\n\n        best_action_value = float(\"-inf\")\n        for action in Action:\n            action_value = self.agent.get_state_action_value(state, action)\n            if action_value &gt; best_action_value:\n                best_action_value = action_value\n                best_action = action\n        return best_action\n</code></pre>"},{"location":"reference/model/agents/q_learning/exploration_strategies/epsilon_greedy_strategy/#src.model.agents.q_learning.exploration_strategies.epsilon_greedy_strategy.EpsilonGreedyStrategy.select_action","title":"<code>select_action(state)</code>","text":"<p>Select the action based upon the epsilon greedy strategy.</p> <p>this strategy picks the best action based upon the value table with a given chance of selecting any action.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>int</code> <p>the state to select the action for.</p> required <p>Returns:</p> Name Type Description <code>Action</code> <code>Action</code> <p>the action the agent should select.</p> Source code in <code>src/model/agents/q_learning/exploration_strategies/epsilon_greedy_strategy.py</code> <pre><code>def select_action(self, state: int) -&gt; Action:\n    \"\"\"Select the action based upon the epsilon greedy strategy.\n\n    this strategy picks the best action based upon the value table with a\n    given chance of selecting any action.\n\n    Args:\n        state (int): the state to select the action for.\n\n    Returns:\n        Action: the action the agent should select.\n    \"\"\"\n    best_action = choice(list(Action))\n    if random() &lt; self.config.exploration_ratio():\n        return best_action\n\n    best_action_value = float(\"-inf\")\n    for action in Action:\n        action_value = self.agent.get_state_action_value(state, action)\n        if action_value &gt; best_action_value:\n            best_action_value = action_value\n            best_action = action\n    return best_action\n</code></pre>"},{"location":"reference/model/agents/q_learning/exploration_strategies/options/","title":"Options","text":""},{"location":"reference/model/agents/q_learning/exploration_strategies/options/#src.model.agents.q_learning.exploration_strategies.options.ExplorationStrategyOptions","title":"<code>ExplorationStrategyOptions</code>","text":"<p>             Bases: <code>Enum</code></p> <p>Enumerates all exploration strategies.</p> Source code in <code>src/model/agents/q_learning/exploration_strategies/options.py</code> <pre><code>class ExplorationStrategyOptions(Enum):\n    \"\"\"Enumerates all exploration strategies.\"\"\"\n\n    not_applicable = 0\n    epsilon_greedy = 1\n</code></pre>"},{"location":"reference/model/agents/value_iteration/","title":"Value Iteration","text":"<p>This package contains the implementation of value iteration.</p> <p>This value iteration is used to drive an optimal agent.</p>"},{"location":"reference/model/agents/value_iteration/agent/","title":"Agent","text":""},{"location":"reference/model/agents/value_iteration/agent/#src.model.agents.value_iteration.agent.ValueIterationAgent","title":"<code>ValueIterationAgent</code>","text":"<p>             Bases: <code>BaseAgent</code></p> <p>Computes the optimal value table for a given dynamics.</p> <p>This agent uses that table with the dynamics to pick optimal actions.</p> Source code in <code>src/model/agents/value_iteration/agent.py</code> <pre><code>class ValueIterationAgent(BaseAgent):\n    \"\"\"Computes the optimal value table for a given dynamics.\n\n    This agent uses that table with the dynamics to pick optimal actions.\n    \"\"\"\n\n    def __init__(\n        self,\n        config: AgentConfig,\n        dynamics: BaseDynamics,\n    ) -&gt; None:\n        \"\"\"Initialise the agent.\n\n        Args:\n            config (AgentConfig): the configuration for the agent.\n            dynamics (BaseDynamics): the dynamics function used to build the\n                value table and pick optimal actions\n        \"\"\"\n        super().__init__(config)\n        self.dynamics = dynamics\n        self.dynamics_distribution = DynamicsDistribution(\n            config.sample_count(), dynamics\n        )\n        self.stopping_epsilon = config.stopping_epsilon()\n        self.discount_rate = config.discount_rate()\n        self.value_table: Optional[value_table_type] = None\n\n    def get_value_table(self) -&gt; value_table_type:\n        \"\"\"Get the value table for the provided dynamics.\n\n        If the value table has already been computed it will provide that. if\n        not it will compute a new value table, this can be quite costly based\n        upon the epsilon, number of states and discount rate.\n\n        Returns:\n            value_table_type: the value table for this mdp\n        \"\"\"\n        if self.value_table is not None:\n            return self.value_table\n\n        if not self.dynamics_distribution.has_compiled():\n            self.dynamics_distribution.compile()\n\n        self.value_table = self.compute_value_table()\n\n        return self.value_table\n\n    def compute_value_table(self) -&gt; value_table_type:\n        \"\"\"Compute the optimal value table with value iteration.\n\n        Returns:\n            value_table_type: the value table for the dynamics\n        \"\"\"\n        state_list = self.dynamics_distribution.list_states()\n        value_table = np.random.rand(len(state_list))\n        stopping_epsilon = self.stopping_epsilon\n        maximum_epsilon: float = 1\n        while maximum_epsilon &gt; stopping_epsilon:\n            maximum_epsilon = float(0)\n            for state in state_list:\n                new_value = self.compute_updated_value(value_table, state)\n                epsilon = abs(float(value_table[state]) - new_value)\n                value_table[state] = new_value\n                maximum_epsilon = max(epsilon, maximum_epsilon)\n        return value_table\n\n    def compute_updated_value(\n        self,\n        value_table: value_table_type,\n        state: int,\n    ) -&gt; float:\n        \"\"\"Compute the new value of the state based upon the latest value table.\n\n        Args:\n            value_table (value_table_type): our current expectation of value in\n                future states to base our estimate.\n            state (int): the state to calculate the value for.\n\n\n        Returns:\n            float: the new value for this state.\n        \"\"\"\n        action_observations = self.dynamics_distribution.observations[state]\n        state_value = float(0)\n        for action in Action:\n            state_value = max(\n                state_value,\n                self.distribution_value(\n                    action_observations[action.value],\n                    value_table,\n                ),\n            )\n        return state_value\n\n    def distribution_value(\n        self,\n        distribution: distribution_result,\n        value_table: value_table_type,\n    ) -&gt; float:\n        \"\"\"Compute the expected action-value from its distribution.\n\n        Args:\n            distribution (distribution_result): the distribution of\n                results to weight the rewards\n            value_table (value_table_type): our current expectation of value in\n                future states to base our estimate.\n\n        Returns:\n            float: the expected value for this state and action\n        \"\"\"\n        expected_value = 0\n        discount_rate = self.discount_rate\n        for next_state, (reward, frequency) in distribution.items():\n            expected_value += frequency * (\n                reward + discount_rate * value_table[next_state]\n            )\n        return expected_value\n\n    def get_state_action_value(self, state: int, action: Action) -&gt; float:\n        \"\"\"Compute the expected action-value of a given state.\n\n        Args:\n            state (int): the state the action is performed in\n            action (Action): the action to get the value of\n\n        Returns:\n            float: the expected value for this state and action\n        \"\"\"\n        value_table = self.get_value_table()\n        return self.distribution_value(\n            self.dynamics_distribution.observations[state][action.value],\n            value_table,\n        )\n\n    def get_state_value(self, state: int) -&gt; float:\n        \"\"\"Get the agents interpretation of the value of this state.\n\n        Args:\n            state (int): the state to evaluate\n\n        Returns:\n            float: the agents interpretation of the value of this state\n        \"\"\"\n        return self.get_value_table()[state]\n\n    def evaluate_policy(self, state: int) -&gt; Action:\n        \"\"\"Decide on the action this agent would take in a given state.\n\n        picks the best action based upon the value table.\n\n        Args:\n            state (int): the state the agent is performing this action\n\n\n        Returns:\n            Action: the action to take in this state\n        \"\"\"\n        best_action = random.choice(list(Action))\n        best_value = self.get_state_action_value(state, best_action)\n        # random default action to help break ties evenly\n        for action in Action:\n            if action is best_action:\n                continue\n            action_value = self.get_state_action_value(state, action)\n            if action_value &gt; best_value:\n                best_value = action_value\n                best_action = action\n\n        return best_action\n\n    def record_transition(\n        self,\n        previous_state: int,\n        previous_action: Action,\n        new_state: int,\n        reward: float,\n    ) -&gt; None:\n        \"\"\"Provide the agent with the information from a transition.\n\n        (not used by this agent)\n\n        Args:\n            previous_state (int): the state before the action was taken\n            previous_action (Action): the action that was taken.\n            new_state (int): The resulting state after the action has been taken\n            reward (float): the reward for performing this action\n\n        \"\"\"\n</code></pre>"},{"location":"reference/model/agents/value_iteration/agent/#src.model.agents.value_iteration.agent.ValueIterationAgent.__init__","title":"<code>__init__(config, dynamics)</code>","text":"<p>Initialise the agent.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>AgentConfig</code> <p>the configuration for the agent.</p> required <code>dynamics</code> <code>BaseDynamics</code> <p>the dynamics function used to build the value table and pick optimal actions</p> required Source code in <code>src/model/agents/value_iteration/agent.py</code> <pre><code>def __init__(\n    self,\n    config: AgentConfig,\n    dynamics: BaseDynamics,\n) -&gt; None:\n    \"\"\"Initialise the agent.\n\n    Args:\n        config (AgentConfig): the configuration for the agent.\n        dynamics (BaseDynamics): the dynamics function used to build the\n            value table and pick optimal actions\n    \"\"\"\n    super().__init__(config)\n    self.dynamics = dynamics\n    self.dynamics_distribution = DynamicsDistribution(\n        config.sample_count(), dynamics\n    )\n    self.stopping_epsilon = config.stopping_epsilon()\n    self.discount_rate = config.discount_rate()\n    self.value_table: Optional[value_table_type] = None\n</code></pre>"},{"location":"reference/model/agents/value_iteration/agent/#src.model.agents.value_iteration.agent.ValueIterationAgent.compute_updated_value","title":"<code>compute_updated_value(value_table, state)</code>","text":"<p>Compute the new value of the state based upon the latest value table.</p> <p>Parameters:</p> Name Type Description Default <code>value_table</code> <code>value_table_type</code> <p>our current expectation of value in future states to base our estimate.</p> required <code>state</code> <code>int</code> <p>the state to calculate the value for.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the new value for this state.</p> Source code in <code>src/model/agents/value_iteration/agent.py</code> <pre><code>def compute_updated_value(\n    self,\n    value_table: value_table_type,\n    state: int,\n) -&gt; float:\n    \"\"\"Compute the new value of the state based upon the latest value table.\n\n    Args:\n        value_table (value_table_type): our current expectation of value in\n            future states to base our estimate.\n        state (int): the state to calculate the value for.\n\n\n    Returns:\n        float: the new value for this state.\n    \"\"\"\n    action_observations = self.dynamics_distribution.observations[state]\n    state_value = float(0)\n    for action in Action:\n        state_value = max(\n            state_value,\n            self.distribution_value(\n                action_observations[action.value],\n                value_table,\n            ),\n        )\n    return state_value\n</code></pre>"},{"location":"reference/model/agents/value_iteration/agent/#src.model.agents.value_iteration.agent.ValueIterationAgent.compute_value_table","title":"<code>compute_value_table()</code>","text":"<p>Compute the optimal value table with value iteration.</p> <p>Returns:</p> Name Type Description <code>value_table_type</code> <code>value_table_type</code> <p>the value table for the dynamics</p> Source code in <code>src/model/agents/value_iteration/agent.py</code> <pre><code>def compute_value_table(self) -&gt; value_table_type:\n    \"\"\"Compute the optimal value table with value iteration.\n\n    Returns:\n        value_table_type: the value table for the dynamics\n    \"\"\"\n    state_list = self.dynamics_distribution.list_states()\n    value_table = np.random.rand(len(state_list))\n    stopping_epsilon = self.stopping_epsilon\n    maximum_epsilon: float = 1\n    while maximum_epsilon &gt; stopping_epsilon:\n        maximum_epsilon = float(0)\n        for state in state_list:\n            new_value = self.compute_updated_value(value_table, state)\n            epsilon = abs(float(value_table[state]) - new_value)\n            value_table[state] = new_value\n            maximum_epsilon = max(epsilon, maximum_epsilon)\n    return value_table\n</code></pre>"},{"location":"reference/model/agents/value_iteration/agent/#src.model.agents.value_iteration.agent.ValueIterationAgent.distribution_value","title":"<code>distribution_value(distribution, value_table)</code>","text":"<p>Compute the expected action-value from its distribution.</p> <p>Parameters:</p> Name Type Description Default <code>distribution</code> <code>distribution_result</code> <p>the distribution of results to weight the rewards</p> required <code>value_table</code> <code>value_table_type</code> <p>our current expectation of value in future states to base our estimate.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the expected value for this state and action</p> Source code in <code>src/model/agents/value_iteration/agent.py</code> <pre><code>def distribution_value(\n    self,\n    distribution: distribution_result,\n    value_table: value_table_type,\n) -&gt; float:\n    \"\"\"Compute the expected action-value from its distribution.\n\n    Args:\n        distribution (distribution_result): the distribution of\n            results to weight the rewards\n        value_table (value_table_type): our current expectation of value in\n            future states to base our estimate.\n\n    Returns:\n        float: the expected value for this state and action\n    \"\"\"\n    expected_value = 0\n    discount_rate = self.discount_rate\n    for next_state, (reward, frequency) in distribution.items():\n        expected_value += frequency * (\n            reward + discount_rate * value_table[next_state]\n        )\n    return expected_value\n</code></pre>"},{"location":"reference/model/agents/value_iteration/agent/#src.model.agents.value_iteration.agent.ValueIterationAgent.evaluate_policy","title":"<code>evaluate_policy(state)</code>","text":"<p>Decide on the action this agent would take in a given state.</p> <p>picks the best action based upon the value table.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>int</code> <p>the state the agent is performing this action</p> required <p>Returns:</p> Name Type Description <code>Action</code> <code>Action</code> <p>the action to take in this state</p> Source code in <code>src/model/agents/value_iteration/agent.py</code> <pre><code>def evaluate_policy(self, state: int) -&gt; Action:\n    \"\"\"Decide on the action this agent would take in a given state.\n\n    picks the best action based upon the value table.\n\n    Args:\n        state (int): the state the agent is performing this action\n\n\n    Returns:\n        Action: the action to take in this state\n    \"\"\"\n    best_action = random.choice(list(Action))\n    best_value = self.get_state_action_value(state, best_action)\n    # random default action to help break ties evenly\n    for action in Action:\n        if action is best_action:\n            continue\n        action_value = self.get_state_action_value(state, action)\n        if action_value &gt; best_value:\n            best_value = action_value\n            best_action = action\n\n    return best_action\n</code></pre>"},{"location":"reference/model/agents/value_iteration/agent/#src.model.agents.value_iteration.agent.ValueIterationAgent.get_state_action_value","title":"<code>get_state_action_value(state, action)</code>","text":"<p>Compute the expected action-value of a given state.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>int</code> <p>the state the action is performed in</p> required <code>action</code> <code>Action</code> <p>the action to get the value of</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the expected value for this state and action</p> Source code in <code>src/model/agents/value_iteration/agent.py</code> <pre><code>def get_state_action_value(self, state: int, action: Action) -&gt; float:\n    \"\"\"Compute the expected action-value of a given state.\n\n    Args:\n        state (int): the state the action is performed in\n        action (Action): the action to get the value of\n\n    Returns:\n        float: the expected value for this state and action\n    \"\"\"\n    value_table = self.get_value_table()\n    return self.distribution_value(\n        self.dynamics_distribution.observations[state][action.value],\n        value_table,\n    )\n</code></pre>"},{"location":"reference/model/agents/value_iteration/agent/#src.model.agents.value_iteration.agent.ValueIterationAgent.get_state_value","title":"<code>get_state_value(state)</code>","text":"<p>Get the agents interpretation of the value of this state.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>int</code> <p>the state to evaluate</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the agents interpretation of the value of this state</p> Source code in <code>src/model/agents/value_iteration/agent.py</code> <pre><code>def get_state_value(self, state: int) -&gt; float:\n    \"\"\"Get the agents interpretation of the value of this state.\n\n    Args:\n        state (int): the state to evaluate\n\n    Returns:\n        float: the agents interpretation of the value of this state\n    \"\"\"\n    return self.get_value_table()[state]\n</code></pre>"},{"location":"reference/model/agents/value_iteration/agent/#src.model.agents.value_iteration.agent.ValueIterationAgent.get_value_table","title":"<code>get_value_table()</code>","text":"<p>Get the value table for the provided dynamics.</p> <p>If the value table has already been computed it will provide that. if not it will compute a new value table, this can be quite costly based upon the epsilon, number of states and discount rate.</p> <p>Returns:</p> Name Type Description <code>value_table_type</code> <code>value_table_type</code> <p>the value table for this mdp</p> Source code in <code>src/model/agents/value_iteration/agent.py</code> <pre><code>def get_value_table(self) -&gt; value_table_type:\n    \"\"\"Get the value table for the provided dynamics.\n\n    If the value table has already been computed it will provide that. if\n    not it will compute a new value table, this can be quite costly based\n    upon the epsilon, number of states and discount rate.\n\n    Returns:\n        value_table_type: the value table for this mdp\n    \"\"\"\n    if self.value_table is not None:\n        return self.value_table\n\n    if not self.dynamics_distribution.has_compiled():\n        self.dynamics_distribution.compile()\n\n    self.value_table = self.compute_value_table()\n\n    return self.value_table\n</code></pre>"},{"location":"reference/model/agents/value_iteration/agent/#src.model.agents.value_iteration.agent.ValueIterationAgent.record_transition","title":"<code>record_transition(previous_state, previous_action, new_state, reward)</code>","text":"<p>Provide the agent with the information from a transition.</p> <p>(not used by this agent)</p> <p>Parameters:</p> Name Type Description Default <code>previous_state</code> <code>int</code> <p>the state before the action was taken</p> required <code>previous_action</code> <code>Action</code> <p>the action that was taken.</p> required <code>new_state</code> <code>int</code> <p>The resulting state after the action has been taken</p> required <code>reward</code> <code>float</code> <p>the reward for performing this action</p> required Source code in <code>src/model/agents/value_iteration/agent.py</code> <pre><code>def record_transition(\n    self,\n    previous_state: int,\n    previous_action: Action,\n    new_state: int,\n    reward: float,\n) -&gt; None:\n    \"\"\"Provide the agent with the information from a transition.\n\n    (not used by this agent)\n\n    Args:\n        previous_state (int): the state before the action was taken\n        previous_action (Action): the action that was taken.\n        new_state (int): The resulting state after the action has been taken\n        reward (float): the reward for performing this action\n\n    \"\"\"\n</code></pre>"},{"location":"reference/model/agents/value_iteration/agent_optimised/","title":"Agent Optimised","text":""},{"location":"reference/model/agents/value_iteration/agent_optimised/#src.model.agents.value_iteration.agent_optimised.ValueIterationAgentOptimised","title":"<code>ValueIterationAgentOptimised</code>","text":"<p>             Bases: <code>ValueIterationAgent</code></p> <p>Computes the optimal value table for a given dynamics.</p> <p>This agent uses that table with the dynamics to pick optimal actions.</p> Source code in <code>src/model/agents/value_iteration/agent_optimised.py</code> <pre><code>class ValueIterationAgentOptimised(ValueIterationAgent):\n    \"\"\"Computes the optimal value table for a given dynamics.\n\n    This agent uses that table with the dynamics to pick optimal actions.\n    \"\"\"\n\n    def compute_value_table(self) -&gt; value_table_type:\n        \"\"\"Compute the optimal value table with value iteration.\n\n        Uses numba to improve performance\n\n        Returns:\n            value_table_type: the value table for the dynamics\n        \"\"\"\n        (\n            lookup_table,\n            next_state,\n            expected_reward,\n            frequency,\n        ) = self.dynamics_distribution.get_array_representation()\n        return compute_value_table(\n            self.discount_rate,\n            self.stopping_epsilon,\n            lookup_table,\n            next_state,\n            expected_reward,\n            frequency,\n        )\n</code></pre>"},{"location":"reference/model/agents/value_iteration/agent_optimised/#src.model.agents.value_iteration.agent_optimised.ValueIterationAgentOptimised.compute_value_table","title":"<code>compute_value_table()</code>","text":"<p>Compute the optimal value table with value iteration.</p> <p>Uses numba to improve performance</p> <p>Returns:</p> Name Type Description <code>value_table_type</code> <code>value_table_type</code> <p>the value table for the dynamics</p> Source code in <code>src/model/agents/value_iteration/agent_optimised.py</code> <pre><code>def compute_value_table(self) -&gt; value_table_type:\n    \"\"\"Compute the optimal value table with value iteration.\n\n    Uses numba to improve performance\n\n    Returns:\n        value_table_type: the value table for the dynamics\n    \"\"\"\n    (\n        lookup_table,\n        next_state,\n        expected_reward,\n        frequency,\n    ) = self.dynamics_distribution.get_array_representation()\n    return compute_value_table(\n        self.discount_rate,\n        self.stopping_epsilon,\n        lookup_table,\n        next_state,\n        expected_reward,\n        frequency,\n    )\n</code></pre>"},{"location":"reference/model/agents/value_iteration/agent_optimised/#src.model.agents.value_iteration.agent_optimised.compute_updated_value","title":"<code>compute_updated_value(value_table, state, discount_rate, lookup_table, next_state, expected_reward, frequency)</code>","text":"<p>Compute the new value of the state based upon the latest value table.</p> <p>Parameters:</p> Name Type Description Default <code>value_table</code> <code>value_table_type</code> <p>our current expectation of value in future states to base our estimate.</p> required <code>state</code> <code>int</code> <p>the state to calculate the value for.</p> required <code>discount_rate</code> <code>float</code> <p>The rate to discount future rewards</p> required <code>lookup_table</code> <code>numpy_int</code> <p>maps state and actions to observed transitions</p> required <code>next_state</code> <code>numpy_int</code> <p>the following state after some state and action</p> required <code>expected_reward</code> <code>numpy_float</code> <p>the average reward after completing some action.</p> required <code>frequency</code> <code>numpy_float</code> <p>The relative frequency of this transition compared to others under the same initial state and action.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the new value for this state.</p> Source code in <code>src/model/agents/value_iteration/agent_optimised.py</code> <pre><code>@jit(nopython=True, cache=True, fastmath=True)\ndef compute_updated_value(  # noqa: WPS211\n    value_table: value_table_type,\n    state: int,\n    discount_rate: float,\n    lookup_table: numpy_int,\n    next_state: numpy_int,\n    expected_reward: numpy_float,\n    frequency: numpy_float,\n) -&gt; float:\n    \"\"\"Compute the new value of the state based upon the latest value table.\n\n    Args:\n        value_table (value_table_type): our current expectation of value in\n            future states to base our estimate.\n        state (int): the state to calculate the value for.\n        discount_rate (float): The rate to discount future rewards\n        lookup_table (numpy_int): maps state and actions to observed transitions\n        next_state (numpy_int): the following state after some state and action\n        expected_reward (numpy_float): the average reward after completing some\n            action.\n        frequency (numpy_float): The relative frequency of this transition\n            compared to others under the same initial state and action.\n\n\n    Returns:\n        float: the new value for this state.\n    \"\"\"\n    state_value = -math.inf\n    for observation_range in lookup_table[state]:\n        start = observation_range[0]\n        end = observation_range[1]\n\n        subsequent_values = discount_rate * value_table[next_state[start:end]]\n        weighted_rewards = frequency[start:end] * (\n            expected_reward[start:end] + subsequent_values\n        )\n\n        state_value = max(state_value, weighted_rewards.mean())\n    return state_value\n</code></pre>"},{"location":"reference/model/agents/value_iteration/agent_optimised/#src.model.agents.value_iteration.agent_optimised.compute_value_table","title":"<code>compute_value_table(discount_rate, stopping_epsilon, lookup_table, next_state, expected_reward, frequency)</code>","text":"<p>Compute the optimal value table with value iteration.</p> <p>Parameters:</p> Name Type Description Default <code>discount_rate</code> <code>float</code> <p>The rate to discount future rewards</p> required <code>stopping_epsilon</code> <code>float</code> <p>The error amount that is acceptable.</p> required <code>lookup_table</code> <code>numpy_int</code> <p>maps state and actions to observed transitions</p> required <code>next_state</code> <code>numpy_int</code> <p>the following state after some state and action</p> required <code>expected_reward</code> <code>numpy_float</code> <p>the average reward after completing some action.</p> required <code>frequency</code> <code>numpy_float</code> <p>The relative frequency of this transition compared to others under the same initial state and action.</p> required <p>Returns:</p> Name Type Description <code>value_table_type</code> <code>value_table_type</code> <p>the value table for the dynamics</p> Source code in <code>src/model/agents/value_iteration/agent_optimised.py</code> <pre><code>@jit(nopython=True, cache=True, fastmath=True)\ndef compute_value_table(  # noqa: WPS211\n    discount_rate: float,\n    stopping_epsilon: float,\n    lookup_table: numpy_int,\n    next_state: numpy_int,\n    expected_reward: numpy_float,\n    frequency: numpy_float,\n) -&gt; value_table_type:\n    \"\"\"Compute the optimal value table with value iteration.\n\n    Args:\n        discount_rate (float): The rate to discount future rewards\n        stopping_epsilon (float): The error amount that is acceptable.\n        lookup_table (numpy_int): maps state and actions to observed transitions\n        next_state (numpy_int): the following state after some state and action\n        expected_reward (numpy_float): the average reward after completing some\n            action.\n        frequency (numpy_float): The relative frequency of this transition\n            compared to others under the same initial state and action.\n\n    Returns:\n        value_table_type: the value table for the dynamics\n    \"\"\"\n    number_of_states = lookup_table.shape[0]\n    value_table = np.random.rand(number_of_states)\n    maximum_epsilon: float = 1\n    while maximum_epsilon &gt; stopping_epsilon:\n        maximum_epsilon = 0\n        for state in range(number_of_states):\n            new_value = compute_updated_value(\n                value_table,\n                state,\n                discount_rate,\n                lookup_table,\n                next_state,\n                expected_reward,\n                frequency,\n            )\n            epsilon = abs(value_table[state] - new_value)\n            value_table[state] = new_value\n            maximum_epsilon = max(epsilon, maximum_epsilon)\n    return value_table\n</code></pre>"},{"location":"reference/model/agents/value_iteration/dynamics_distribution/","title":"Dynamics Distribution","text":""},{"location":"reference/model/agents/value_iteration/dynamics_distribution/#src.model.agents.value_iteration.dynamics_distribution.DynamicsDistribution","title":"<code>DynamicsDistribution</code>","text":"<p>             Bases: <code>object</code></p> <p>Calculates a dynamics distribution.</p> Source code in <code>src/model/agents/value_iteration/dynamics_distribution.py</code> <pre><code>class DynamicsDistribution(object):\n    \"\"\"Calculates a dynamics distribution.\"\"\"\n\n    def __init__(\n        self, per_state_sample_count: int, dynamics: BaseDynamics\n    ) -&gt; None:\n        \"\"\"Initialise the dynamics distribution.\n\n        Args:\n            per_state_sample_count (int): the number of samples to collect from\n                each state, for deterministic dynamics only one is needed.\n            dynamics (BaseDynamics): the dynamics to get the distribution for.\n        \"\"\"\n        self.sample_count = (\n            per_state_sample_count if dynamics.is_stochastic() else 1\n        )\n        self.dynamics = dynamics\n\n        # state, action, new_state -&gt; reward, freq\n        self.observations: observations_type = {}\n\n    def compute_state_action_distribution(\n        self, state: int, action: Action\n    ) -&gt; distribution_result:\n        \"\"\"Compute the subsequent distribution for a given action and state.\n\n        Args:\n            state (int): the state to to get the distribution for.\n            action (Action): the action to get the distribution for.\n\n        Returns:\n            distribution_result: the distribution of states and their\n            expected immediate rewards.\n        \"\"\"\n        observed_states: DefaultDict[int, List[float]] = defaultdict(list)\n\n        for _iteration in range(self.sample_count):  # noqa: WPS122\n            next_id, reward = self.dynamics.next_state_id(state, action)\n            observed_states[next_id].append(reward)\n\n        reduced_output: distribution_result = {}\n        for new_state, observations in observed_states.items():\n            frequency = len(observations) / self.sample_count\n            average_reward = np.array(observations).mean()\n            reduced_output[new_state] = (average_reward, frequency)\n        return reduced_output\n\n    def compile(self):\n        \"\"\"Compile the dynamics state distribution for analysis.\n\n        for some dynamics certain states are not reachable from the initial\n        state. if the initial state was changed to be one of these unreachable\n        states the distribution would need to be recalculated, and thus the\n        value table. The existing value table and distributions could be reused\n        but this is not within scope.\n        \"\"\"\n        frontier: List[int] = [self.dynamics.initial_state_id()]\n        seen_states: Set[int] = set(frontier)\n\n        seen_add = seen_states.add  # performance tweak\n        frontier_add = frontier.append\n\n        def add_states(states: Iterable[int]):\n            for state in states:\n                if state not in seen_states:\n                    seen_add(state)\n                    frontier_add(state)\n\n        while frontier:\n            current_state = frontier.pop(0)\n            current_state_observations = {}\n            self.observations[current_state] = current_state_observations\n            for action in Action:\n                distribution = self.compute_state_action_distribution(\n                    current_state, action\n                )\n                current_state_observations[action.value] = distribution\n                add_states(distribution.keys())\n\n    def has_compiled(self) -&gt; bool:\n        \"\"\"Check weather the observations have been compiled yet.\n\n        Returns:\n            bool: true when the distribution has been compiled.\n        \"\"\"\n        return bool(self.observations)\n\n    def check_compiled(self) -&gt; None:\n        \"\"\"Throw error if not compiled yet.\n\n        Raises:\n            RuntimeError: Thrown if the class has not compiled the observations.\n        \"\"\"\n        if not self.has_compiled():\n            raise RuntimeError(\"not yet compiled\")\n\n    def get_state_count(self) -&gt; int:\n        \"\"\"Get the number of states in the MDP.\n\n        Returns:\n            int: the number of states\n        \"\"\"\n        self.check_compiled()\n        return len(self.observations)\n\n    def list_states(self) -&gt; np.ndarray[Any, np.dtype[np.integer]]:\n        \"\"\"Get array of all the states.\n\n        Returns:\n            np.ndarray[Any, np.dtype[np.integer]]: all possible states as an\n            array.\n        \"\"\"\n        return np.array(list(self.observations.keys()))\n\n    def get_array_representation(\n        self,\n    ) -&gt; numpy_distribution_information_type:\n        \"\"\"Convert the observations data to an array representation.\n\n        lookup table -&gt; maps a state and action to a range of observations\n\n        the lookup table provides the start and end of a range of observed\n        subsequent states.\n\n        next state -&gt; the observed next state\n        expected_reward -&gt; the expected reward for transitioning to this state\n        frequency -&gt; how often under these state and action do we perform this\n        transition\n\n        Returns:\n            numpy_distribution_information_type: lookup_table, next_state,\n            expected_reward, frequency\n        \"\"\"\n        # 3d array state action to index the start and end of the observations\n        # states index to ranges in the corresponding arrays\n\n        empty_list_item = [None]\n\n        lookup_table: List[Any] = empty_list_item * len(self.observations)\n\n        next_state: List[Any] = []\n        expected_reward: List[Any] = []\n        frequency: List[Any] = []\n\n        for state, actions in self.observations.items():\n            state_lookup_table: List[Any] = empty_list_item * len(actions)\n            for action, observations in actions.items():\n                start = len(next_state)\n                end = start + len(observations)\n                state_lookup_table[action - 1] = [start, end]\n\n                next_state.extend(empty_list_item * len(observations))\n                expected_reward.extend(empty_list_item * len(observations))\n                frequency.extend(empty_list_item * len(observations))\n\n                for raw_index, observation in enumerate(observations.items()):\n                    (\n                        next_state_observation,\n                        (reward_observation, frequency_observation),\n                    ) = observation\n                    index = start + raw_index\n                    next_state[index] = next_state_observation\n                    expected_reward[index] = reward_observation\n                    frequency[index] = frequency_observation\n            lookup_table[state] = state_lookup_table\n\n        return (\n            np.array(lookup_table, dtype=np.int64),\n            np.array(next_state, dtype=np.int64),\n            np.array(expected_reward, dtype=np.float64),\n            np.array(frequency, dtype=np.float64),\n        )\n</code></pre>"},{"location":"reference/model/agents/value_iteration/dynamics_distribution/#src.model.agents.value_iteration.dynamics_distribution.DynamicsDistribution.__init__","title":"<code>__init__(per_state_sample_count, dynamics)</code>","text":"<p>Initialise the dynamics distribution.</p> <p>Parameters:</p> Name Type Description Default <code>per_state_sample_count</code> <code>int</code> <p>the number of samples to collect from each state, for deterministic dynamics only one is needed.</p> required <code>dynamics</code> <code>BaseDynamics</code> <p>the dynamics to get the distribution for.</p> required Source code in <code>src/model/agents/value_iteration/dynamics_distribution.py</code> <pre><code>def __init__(\n    self, per_state_sample_count: int, dynamics: BaseDynamics\n) -&gt; None:\n    \"\"\"Initialise the dynamics distribution.\n\n    Args:\n        per_state_sample_count (int): the number of samples to collect from\n            each state, for deterministic dynamics only one is needed.\n        dynamics (BaseDynamics): the dynamics to get the distribution for.\n    \"\"\"\n    self.sample_count = (\n        per_state_sample_count if dynamics.is_stochastic() else 1\n    )\n    self.dynamics = dynamics\n\n    # state, action, new_state -&gt; reward, freq\n    self.observations: observations_type = {}\n</code></pre>"},{"location":"reference/model/agents/value_iteration/dynamics_distribution/#src.model.agents.value_iteration.dynamics_distribution.DynamicsDistribution.check_compiled","title":"<code>check_compiled()</code>","text":"<p>Throw error if not compiled yet.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>Thrown if the class has not compiled the observations.</p> Source code in <code>src/model/agents/value_iteration/dynamics_distribution.py</code> <pre><code>def check_compiled(self) -&gt; None:\n    \"\"\"Throw error if not compiled yet.\n\n    Raises:\n        RuntimeError: Thrown if the class has not compiled the observations.\n    \"\"\"\n    if not self.has_compiled():\n        raise RuntimeError(\"not yet compiled\")\n</code></pre>"},{"location":"reference/model/agents/value_iteration/dynamics_distribution/#src.model.agents.value_iteration.dynamics_distribution.DynamicsDistribution.compile","title":"<code>compile()</code>","text":"<p>Compile the dynamics state distribution for analysis.</p> <p>for some dynamics certain states are not reachable from the initial state. if the initial state was changed to be one of these unreachable states the distribution would need to be recalculated, and thus the value table. The existing value table and distributions could be reused but this is not within scope.</p> Source code in <code>src/model/agents/value_iteration/dynamics_distribution.py</code> <pre><code>def compile(self):\n    \"\"\"Compile the dynamics state distribution for analysis.\n\n    for some dynamics certain states are not reachable from the initial\n    state. if the initial state was changed to be one of these unreachable\n    states the distribution would need to be recalculated, and thus the\n    value table. The existing value table and distributions could be reused\n    but this is not within scope.\n    \"\"\"\n    frontier: List[int] = [self.dynamics.initial_state_id()]\n    seen_states: Set[int] = set(frontier)\n\n    seen_add = seen_states.add  # performance tweak\n    frontier_add = frontier.append\n\n    def add_states(states: Iterable[int]):\n        for state in states:\n            if state not in seen_states:\n                seen_add(state)\n                frontier_add(state)\n\n    while frontier:\n        current_state = frontier.pop(0)\n        current_state_observations = {}\n        self.observations[current_state] = current_state_observations\n        for action in Action:\n            distribution = self.compute_state_action_distribution(\n                current_state, action\n            )\n            current_state_observations[action.value] = distribution\n            add_states(distribution.keys())\n</code></pre>"},{"location":"reference/model/agents/value_iteration/dynamics_distribution/#src.model.agents.value_iteration.dynamics_distribution.DynamicsDistribution.compute_state_action_distribution","title":"<code>compute_state_action_distribution(state, action)</code>","text":"<p>Compute the subsequent distribution for a given action and state.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>int</code> <p>the state to to get the distribution for.</p> required <code>action</code> <code>Action</code> <p>the action to get the distribution for.</p> required <p>Returns:</p> Name Type Description <code>distribution_result</code> <code>distribution_result</code> <p>the distribution of states and their</p> <code>distribution_result</code> <p>expected immediate rewards.</p> Source code in <code>src/model/agents/value_iteration/dynamics_distribution.py</code> <pre><code>def compute_state_action_distribution(\n    self, state: int, action: Action\n) -&gt; distribution_result:\n    \"\"\"Compute the subsequent distribution for a given action and state.\n\n    Args:\n        state (int): the state to to get the distribution for.\n        action (Action): the action to get the distribution for.\n\n    Returns:\n        distribution_result: the distribution of states and their\n        expected immediate rewards.\n    \"\"\"\n    observed_states: DefaultDict[int, List[float]] = defaultdict(list)\n\n    for _iteration in range(self.sample_count):  # noqa: WPS122\n        next_id, reward = self.dynamics.next_state_id(state, action)\n        observed_states[next_id].append(reward)\n\n    reduced_output: distribution_result = {}\n    for new_state, observations in observed_states.items():\n        frequency = len(observations) / self.sample_count\n        average_reward = np.array(observations).mean()\n        reduced_output[new_state] = (average_reward, frequency)\n    return reduced_output\n</code></pre>"},{"location":"reference/model/agents/value_iteration/dynamics_distribution/#src.model.agents.value_iteration.dynamics_distribution.DynamicsDistribution.get_array_representation","title":"<code>get_array_representation()</code>","text":"<p>Convert the observations data to an array representation.</p> <p>lookup table -&gt; maps a state and action to a range of observations</p> <p>the lookup table provides the start and end of a range of observed subsequent states.</p> <p>next state -&gt; the observed next state expected_reward -&gt; the expected reward for transitioning to this state frequency -&gt; how often under these state and action do we perform this transition</p> <p>Returns:</p> Name Type Description <code>numpy_distribution_information_type</code> <code>numpy_distribution_information_type</code> <p>lookup_table, next_state,</p> <code>numpy_distribution_information_type</code> <p>expected_reward, frequency</p> Source code in <code>src/model/agents/value_iteration/dynamics_distribution.py</code> <pre><code>def get_array_representation(\n    self,\n) -&gt; numpy_distribution_information_type:\n    \"\"\"Convert the observations data to an array representation.\n\n    lookup table -&gt; maps a state and action to a range of observations\n\n    the lookup table provides the start and end of a range of observed\n    subsequent states.\n\n    next state -&gt; the observed next state\n    expected_reward -&gt; the expected reward for transitioning to this state\n    frequency -&gt; how often under these state and action do we perform this\n    transition\n\n    Returns:\n        numpy_distribution_information_type: lookup_table, next_state,\n        expected_reward, frequency\n    \"\"\"\n    # 3d array state action to index the start and end of the observations\n    # states index to ranges in the corresponding arrays\n\n    empty_list_item = [None]\n\n    lookup_table: List[Any] = empty_list_item * len(self.observations)\n\n    next_state: List[Any] = []\n    expected_reward: List[Any] = []\n    frequency: List[Any] = []\n\n    for state, actions in self.observations.items():\n        state_lookup_table: List[Any] = empty_list_item * len(actions)\n        for action, observations in actions.items():\n            start = len(next_state)\n            end = start + len(observations)\n            state_lookup_table[action - 1] = [start, end]\n\n            next_state.extend(empty_list_item * len(observations))\n            expected_reward.extend(empty_list_item * len(observations))\n            frequency.extend(empty_list_item * len(observations))\n\n            for raw_index, observation in enumerate(observations.items()):\n                (\n                    next_state_observation,\n                    (reward_observation, frequency_observation),\n                ) = observation\n                index = start + raw_index\n                next_state[index] = next_state_observation\n                expected_reward[index] = reward_observation\n                frequency[index] = frequency_observation\n        lookup_table[state] = state_lookup_table\n\n    return (\n        np.array(lookup_table, dtype=np.int64),\n        np.array(next_state, dtype=np.int64),\n        np.array(expected_reward, dtype=np.float64),\n        np.array(frequency, dtype=np.float64),\n    )\n</code></pre>"},{"location":"reference/model/agents/value_iteration/dynamics_distribution/#src.model.agents.value_iteration.dynamics_distribution.DynamicsDistribution.get_state_count","title":"<code>get_state_count()</code>","text":"<p>Get the number of states in the MDP.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>the number of states</p> Source code in <code>src/model/agents/value_iteration/dynamics_distribution.py</code> <pre><code>def get_state_count(self) -&gt; int:\n    \"\"\"Get the number of states in the MDP.\n\n    Returns:\n        int: the number of states\n    \"\"\"\n    self.check_compiled()\n    return len(self.observations)\n</code></pre>"},{"location":"reference/model/agents/value_iteration/dynamics_distribution/#src.model.agents.value_iteration.dynamics_distribution.DynamicsDistribution.has_compiled","title":"<code>has_compiled()</code>","text":"<p>Check weather the observations have been compiled yet.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>true when the distribution has been compiled.</p> Source code in <code>src/model/agents/value_iteration/dynamics_distribution.py</code> <pre><code>def has_compiled(self) -&gt; bool:\n    \"\"\"Check weather the observations have been compiled yet.\n\n    Returns:\n        bool: true when the distribution has been compiled.\n    \"\"\"\n    return bool(self.observations)\n</code></pre>"},{"location":"reference/model/agents/value_iteration/dynamics_distribution/#src.model.agents.value_iteration.dynamics_distribution.DynamicsDistribution.list_states","title":"<code>list_states()</code>","text":"<p>Get array of all the states.</p> <p>Returns:</p> Type Description <code>ndarray[Any, dtype[integer]]</code> <p>np.ndarray[Any, np.dtype[np.integer]]: all possible states as an</p> <code>ndarray[Any, dtype[integer]]</code> <p>array.</p> Source code in <code>src/model/agents/value_iteration/dynamics_distribution.py</code> <pre><code>def list_states(self) -&gt; np.ndarray[Any, np.dtype[np.integer]]:\n    \"\"\"Get array of all the states.\n\n    Returns:\n        np.ndarray[Any, np.dtype[np.integer]]: all possible states as an\n        array.\n    \"\"\"\n    return np.array(list(self.observations.keys()))\n</code></pre>"},{"location":"reference/model/agents/value_iteration/types/","title":"Types","text":""},{"location":"reference/model/config/","title":"Config","text":"<p>Configuration Reader.</p> <p>This package contains the functionality for reading and validating the configuration.</p>"},{"location":"reference/model/config/agent_section/","title":"Agent Section","text":""},{"location":"reference/model/config/agent_section/#src.model.config.agent_section.AgentConfig","title":"<code>AgentConfig</code>","text":"<p>             Bases: <code>BaseConfigSection</code></p> <p>Gets configuration related to the GUI.</p> Source code in <code>src/model/config/agent_section.py</code> <pre><code>class AgentConfig(BaseConfigSection):\n    \"\"\"Gets configuration related to the GUI.\"\"\"\n\n    discount_rate_property = \"discount_rate\"\n    stopping_epsilon_property = \"stopping_epsilon\"\n    learning_rate_property = \"learning_rate\"\n    sample_count_property = \"sample_count\"\n    exploration_ratio_property = \"exploration_ratio\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Instantiate Grid world section config.\"\"\"\n        data_schema = Schema(\n            {\n                self.discount_rate_property: float,\n                self.stopping_epsilon_property: float,\n                self.learning_rate_property: float,\n                self.sample_count_property: int,\n                self.exploration_ratio_property: float,\n            }\n        )\n        super().__init__(\"agent\", data_schema)\n\n    def discount_rate(self) -&gt; float:\n        \"\"\"Get the discount rate.\n\n        Returns:\n            float: the amount to discount future reward\n        \"\"\"\n        return self.configuration[self.discount_rate_property]\n\n    def stopping_epsilon(self) -&gt; float:\n        \"\"\"Get the stopping epsilon.\n\n        Returns:\n            float: the maximum error allowable in a value table\n        \"\"\"\n        return self.configuration[self.stopping_epsilon_property]\n\n    def learning_rate(self) -&gt; float:\n        \"\"\"Get the learning rate.\n\n        Returns:\n            float: the amount to update the value table with each observation\n        \"\"\"\n        return self.configuration[self.learning_rate_property]\n\n    def sample_count(self) -&gt; int:\n        \"\"\"Get the sample count.\n\n        Returns:\n            int: the number of samples to use for distribution analysis.\n        \"\"\"\n        return self.configuration[self.sample_count_property]\n\n    def exploration_ratio(self) -&gt; float:\n        \"\"\"Get the ratio the agent should explore vs exploit.\n\n        also known as epsilon in epsilon greedy and soft strategies\n\n        Returns:\n            float: the ratio for exploring, 1 represents always exploring. 0\n            never exploring.\n        \"\"\"\n        return self.configuration[self.exploration_ratio_property]\n</code></pre>"},{"location":"reference/model/config/agent_section/#src.model.config.agent_section.AgentConfig.__init__","title":"<code>__init__()</code>","text":"<p>Instantiate Grid world section config.</p> Source code in <code>src/model/config/agent_section.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Instantiate Grid world section config.\"\"\"\n    data_schema = Schema(\n        {\n            self.discount_rate_property: float,\n            self.stopping_epsilon_property: float,\n            self.learning_rate_property: float,\n            self.sample_count_property: int,\n            self.exploration_ratio_property: float,\n        }\n    )\n    super().__init__(\"agent\", data_schema)\n</code></pre>"},{"location":"reference/model/config/agent_section/#src.model.config.agent_section.AgentConfig.discount_rate","title":"<code>discount_rate()</code>","text":"<p>Get the discount rate.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the amount to discount future reward</p> Source code in <code>src/model/config/agent_section.py</code> <pre><code>def discount_rate(self) -&gt; float:\n    \"\"\"Get the discount rate.\n\n    Returns:\n        float: the amount to discount future reward\n    \"\"\"\n    return self.configuration[self.discount_rate_property]\n</code></pre>"},{"location":"reference/model/config/agent_section/#src.model.config.agent_section.AgentConfig.exploration_ratio","title":"<code>exploration_ratio()</code>","text":"<p>Get the ratio the agent should explore vs exploit.</p> <p>also known as epsilon in epsilon greedy and soft strategies</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the ratio for exploring, 1 represents always exploring. 0</p> <code>float</code> <p>never exploring.</p> Source code in <code>src/model/config/agent_section.py</code> <pre><code>def exploration_ratio(self) -&gt; float:\n    \"\"\"Get the ratio the agent should explore vs exploit.\n\n    also known as epsilon in epsilon greedy and soft strategies\n\n    Returns:\n        float: the ratio for exploring, 1 represents always exploring. 0\n        never exploring.\n    \"\"\"\n    return self.configuration[self.exploration_ratio_property]\n</code></pre>"},{"location":"reference/model/config/agent_section/#src.model.config.agent_section.AgentConfig.learning_rate","title":"<code>learning_rate()</code>","text":"<p>Get the learning rate.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the amount to update the value table with each observation</p> Source code in <code>src/model/config/agent_section.py</code> <pre><code>def learning_rate(self) -&gt; float:\n    \"\"\"Get the learning rate.\n\n    Returns:\n        float: the amount to update the value table with each observation\n    \"\"\"\n    return self.configuration[self.learning_rate_property]\n</code></pre>"},{"location":"reference/model/config/agent_section/#src.model.config.agent_section.AgentConfig.sample_count","title":"<code>sample_count()</code>","text":"<p>Get the sample count.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>the number of samples to use for distribution analysis.</p> Source code in <code>src/model/config/agent_section.py</code> <pre><code>def sample_count(self) -&gt; int:\n    \"\"\"Get the sample count.\n\n    Returns:\n        int: the number of samples to use for distribution analysis.\n    \"\"\"\n    return self.configuration[self.sample_count_property]\n</code></pre>"},{"location":"reference/model/config/agent_section/#src.model.config.agent_section.AgentConfig.stopping_epsilon","title":"<code>stopping_epsilon()</code>","text":"<p>Get the stopping epsilon.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the maximum error allowable in a value table</p> Source code in <code>src/model/config/agent_section.py</code> <pre><code>def stopping_epsilon(self) -&gt; float:\n    \"\"\"Get the stopping epsilon.\n\n    Returns:\n        float: the maximum error allowable in a value table\n    \"\"\"\n    return self.configuration[self.stopping_epsilon_property]\n</code></pre>"},{"location":"reference/model/config/base_section/","title":"Base Section","text":""},{"location":"reference/model/config/base_section/#src.model.config.base_section.BaseConfigSection","title":"<code>BaseConfigSection</code>","text":"<p>             Bases: <code>object</code></p> <p>Base class for all config section views.</p> Source code in <code>src/model/config/base_section.py</code> <pre><code>class BaseConfigSection(object):\n    \"\"\"Base class for all config section views.\"\"\"\n\n    def __init__(\n        self,\n        section_name: str,\n        schema: Schema,\n    ) -&gt; None:\n        \"\"\"Instantiate the basic data required for a config section.\n\n        Args:\n            section_name (str): the name of the section as it should appear in\n                the config file\n            schema (Schema): the schema to validate the data within this\n                section.\n        \"\"\"\n        self.schema = schema\n        self.section_name = section_name\n\n    def initialise(self, configuration: Any) -&gt; None:\n        \"\"\"Populate section with data.\n\n        This method lets the configuration reader to populate the view with\n        data, it also performs validation at this stage, it will through an\n        error if the data is not valid for this section\n\n        Raises:\n            Exception: thrown when the configuration file data is incorrect\n\n        Args:\n            configuration (Any): the raw configuration data to be used thought\n                the application\n        \"\"\"\n        self.configuration = self.schema.validate(configuration)\n</code></pre>"},{"location":"reference/model/config/base_section/#src.model.config.base_section.BaseConfigSection.__init__","title":"<code>__init__(section_name, schema)</code>","text":"<p>Instantiate the basic data required for a config section.</p> <p>Parameters:</p> Name Type Description Default <code>section_name</code> <code>str</code> <p>the name of the section as it should appear in the config file</p> required <code>schema</code> <code>Schema</code> <p>the schema to validate the data within this section.</p> required Source code in <code>src/model/config/base_section.py</code> <pre><code>def __init__(\n    self,\n    section_name: str,\n    schema: Schema,\n) -&gt; None:\n    \"\"\"Instantiate the basic data required for a config section.\n\n    Args:\n        section_name (str): the name of the section as it should appear in\n            the config file\n        schema (Schema): the schema to validate the data within this\n            section.\n    \"\"\"\n    self.schema = schema\n    self.section_name = section_name\n</code></pre>"},{"location":"reference/model/config/base_section/#src.model.config.base_section.BaseConfigSection.initialise","title":"<code>initialise(configuration)</code>","text":"<p>Populate section with data.</p> <p>This method lets the configuration reader to populate the view with data, it also performs validation at this stage, it will through an error if the data is not valid for this section</p> <p>Raises:</p> Type Description <code>Exception</code> <p>thrown when the configuration file data is incorrect</p> <p>Parameters:</p> Name Type Description Default <code>configuration</code> <code>Any</code> <p>the raw configuration data to be used thought the application</p> required Source code in <code>src/model/config/base_section.py</code> <pre><code>def initialise(self, configuration: Any) -&gt; None:\n    \"\"\"Populate section with data.\n\n    This method lets the configuration reader to populate the view with\n    data, it also performs validation at this stage, it will through an\n    error if the data is not valid for this section\n\n    Raises:\n        Exception: thrown when the configuration file data is incorrect\n\n    Args:\n        configuration (Any): the raw configuration data to be used thought\n            the application\n    \"\"\"\n    self.configuration = self.schema.validate(configuration)\n</code></pre>"},{"location":"reference/model/config/grid_world_section/","title":"Grid World Section","text":""},{"location":"reference/model/config/grid_world_section/#src.model.config.grid_world_section.GridWorldConfig","title":"<code>GridWorldConfig</code>","text":"<p>             Bases: <code>BaseConfigSection</code></p> <p>Gets configuration related to the environment.</p> Source code in <code>src/model/config/grid_world_section.py</code> <pre><code>class GridWorldConfig(BaseConfigSection):\n    \"\"\"Gets configuration related to the environment.\"\"\"\n\n    width_property = \"width\"\n    height_property = \"height\"\n    entity_count_property = \"entity_count\"\n    energy_section = \"energy\"\n    energy_capacity_property = \"energy_capacity\"\n    initial_energy_property = \"initial_energy\"\n    location_section = \"agent_location\"\n    location_x_property = \"x\"\n    location_y_property = \"y\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Instantiate Grid world section config.\"\"\"\n        data_schema = Schema(\n            {\n                self.width_property: int,\n                self.height_property: int,\n                self.entity_count_property: int,\n                self.energy_section: {\n                    self.energy_capacity_property: int,\n                    self.initial_energy_property: int,\n                },\n                self.location_section: {\n                    self.location_x_property: int,\n                    self.location_y_property: int,\n                },\n            }\n        )\n        super().__init__(\"grid_world\", data_schema)\n\n    def width(self) -&gt; int:\n        \"\"\"Get the default width of the grid world.\n\n        Returns:\n            int: the requested width\n        \"\"\"\n        return self.configuration[self.width_property]\n\n    def height(self) -&gt; int:\n        \"\"\"Get the default height of the grid world.\n\n        Returns:\n            int: the requested height\n        \"\"\"\n        return self.configuration[self.height_property]\n\n    def agent_location(self) -&gt; tuple[int, int]:\n        \"\"\"Get the default agent location.\n\n        Returns:\n            tuple[int, int]: the agents location x,y\n        \"\"\"\n        pos_x = self.configuration[self.location_section][\n            self.location_x_property\n        ]\n        pos_y = self.configuration[self.location_section][\n            self.location_y_property\n        ]\n        return pos_x, pos_y\n\n    def entity_count(self) -&gt; int:\n        \"\"\"Get the number of entities to be spawned on the grid.\n\n        Returns:\n            int: The default number of entities to be spawned\n        \"\"\"\n        return self.configuration[self.entity_count_property]\n\n    def energy_capacity(self) -&gt; int:\n        \"\"\"Get the energy capacity.\n\n        Returns:\n            int: the default energy capacity\n        \"\"\"\n        return self.configuration[self.energy_section][\n            self.energy_capacity_property\n        ]\n\n    def initial_energy(self) -&gt; int:\n        \"\"\"Get the initial energy for the agent.\n\n        Returns:\n            int: the default initial energy\n        \"\"\"\n        return self.configuration[self.energy_section][\n            self.initial_energy_property\n        ]\n</code></pre>"},{"location":"reference/model/config/grid_world_section/#src.model.config.grid_world_section.GridWorldConfig.__init__","title":"<code>__init__()</code>","text":"<p>Instantiate Grid world section config.</p> Source code in <code>src/model/config/grid_world_section.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Instantiate Grid world section config.\"\"\"\n    data_schema = Schema(\n        {\n            self.width_property: int,\n            self.height_property: int,\n            self.entity_count_property: int,\n            self.energy_section: {\n                self.energy_capacity_property: int,\n                self.initial_energy_property: int,\n            },\n            self.location_section: {\n                self.location_x_property: int,\n                self.location_y_property: int,\n            },\n        }\n    )\n    super().__init__(\"grid_world\", data_schema)\n</code></pre>"},{"location":"reference/model/config/grid_world_section/#src.model.config.grid_world_section.GridWorldConfig.agent_location","title":"<code>agent_location()</code>","text":"<p>Get the default agent location.</p> <p>Returns:</p> Type Description <code>tuple[int, int]</code> <p>tuple[int, int]: the agents location x,y</p> Source code in <code>src/model/config/grid_world_section.py</code> <pre><code>def agent_location(self) -&gt; tuple[int, int]:\n    \"\"\"Get the default agent location.\n\n    Returns:\n        tuple[int, int]: the agents location x,y\n    \"\"\"\n    pos_x = self.configuration[self.location_section][\n        self.location_x_property\n    ]\n    pos_y = self.configuration[self.location_section][\n        self.location_y_property\n    ]\n    return pos_x, pos_y\n</code></pre>"},{"location":"reference/model/config/grid_world_section/#src.model.config.grid_world_section.GridWorldConfig.energy_capacity","title":"<code>energy_capacity()</code>","text":"<p>Get the energy capacity.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>the default energy capacity</p> Source code in <code>src/model/config/grid_world_section.py</code> <pre><code>def energy_capacity(self) -&gt; int:\n    \"\"\"Get the energy capacity.\n\n    Returns:\n        int: the default energy capacity\n    \"\"\"\n    return self.configuration[self.energy_section][\n        self.energy_capacity_property\n    ]\n</code></pre>"},{"location":"reference/model/config/grid_world_section/#src.model.config.grid_world_section.GridWorldConfig.entity_count","title":"<code>entity_count()</code>","text":"<p>Get the number of entities to be spawned on the grid.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The default number of entities to be spawned</p> Source code in <code>src/model/config/grid_world_section.py</code> <pre><code>def entity_count(self) -&gt; int:\n    \"\"\"Get the number of entities to be spawned on the grid.\n\n    Returns:\n        int: The default number of entities to be spawned\n    \"\"\"\n    return self.configuration[self.entity_count_property]\n</code></pre>"},{"location":"reference/model/config/grid_world_section/#src.model.config.grid_world_section.GridWorldConfig.height","title":"<code>height()</code>","text":"<p>Get the default height of the grid world.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>the requested height</p> Source code in <code>src/model/config/grid_world_section.py</code> <pre><code>def height(self) -&gt; int:\n    \"\"\"Get the default height of the grid world.\n\n    Returns:\n        int: the requested height\n    \"\"\"\n    return self.configuration[self.height_property]\n</code></pre>"},{"location":"reference/model/config/grid_world_section/#src.model.config.grid_world_section.GridWorldConfig.initial_energy","title":"<code>initial_energy()</code>","text":"<p>Get the initial energy for the agent.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>the default initial energy</p> Source code in <code>src/model/config/grid_world_section.py</code> <pre><code>def initial_energy(self) -&gt; int:\n    \"\"\"Get the initial energy for the agent.\n\n    Returns:\n        int: the default initial energy\n    \"\"\"\n    return self.configuration[self.energy_section][\n        self.initial_energy_property\n    ]\n</code></pre>"},{"location":"reference/model/config/grid_world_section/#src.model.config.grid_world_section.GridWorldConfig.width","title":"<code>width()</code>","text":"<p>Get the default width of the grid world.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>the requested width</p> Source code in <code>src/model/config/grid_world_section.py</code> <pre><code>def width(self) -&gt; int:\n    \"\"\"Get the default width of the grid world.\n\n    Returns:\n        int: the requested width\n    \"\"\"\n    return self.configuration[self.width_property]\n</code></pre>"},{"location":"reference/model/config/gui_section/","title":"Gui Section","text":""},{"location":"reference/model/config/gui_section/#src.model.config.gui_section.GUIConfig","title":"<code>GUIConfig</code>","text":"<p>             Bases: <code>BaseConfigSection</code></p> <p>Gets configuration related to the GUI.</p> Source code in <code>src/model/config/gui_section.py</code> <pre><code>class GUIConfig(BaseConfigSection):\n    \"\"\"Gets configuration related to the GUI.\"\"\"\n\n    appearance_mode_property = \"appearance_mode\"\n    color_theme_property = \"color_theme\"\n    initial_size_property = \"initial_size\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Instantiate Grid world section config.\"\"\"\n        data_schema = Schema(\n            {\n                self.appearance_mode_property: str,\n                self.color_theme_property: str,\n                self.initial_size_property: str,\n            }\n        )\n        super().__init__(\"gui\", data_schema)\n\n    def appearance_mode(self) -&gt; str:\n        \"\"\"Get the theme style, e.g. light or dark.\n\n        Returns:\n            str: The theme style.\n        \"\"\"\n        return self.configuration[self.appearance_mode_property]\n\n    def color_theme(self) -&gt; str:\n        \"\"\"Get the theme color.\n\n        e.g \"blue\" (standard), \"green\", \"dark-blue\"\n\n\n        Returns:\n            str: The palate color.\n        \"\"\"\n        return self.configuration[self.color_theme_property]\n\n    def initial_size(self) -&gt; str:\n        \"\"\"Get the initial size of the window.\n\n        Returns:\n            str: the width and hight formatted as \"100x100\"\n        \"\"\"\n        return self.configuration[self.initial_size_property]\n</code></pre>"},{"location":"reference/model/config/gui_section/#src.model.config.gui_section.GUIConfig.__init__","title":"<code>__init__()</code>","text":"<p>Instantiate Grid world section config.</p> Source code in <code>src/model/config/gui_section.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Instantiate Grid world section config.\"\"\"\n    data_schema = Schema(\n        {\n            self.appearance_mode_property: str,\n            self.color_theme_property: str,\n            self.initial_size_property: str,\n        }\n    )\n    super().__init__(\"gui\", data_schema)\n</code></pre>"},{"location":"reference/model/config/gui_section/#src.model.config.gui_section.GUIConfig.appearance_mode","title":"<code>appearance_mode()</code>","text":"<p>Get the theme style, e.g. light or dark.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The theme style.</p> Source code in <code>src/model/config/gui_section.py</code> <pre><code>def appearance_mode(self) -&gt; str:\n    \"\"\"Get the theme style, e.g. light or dark.\n\n    Returns:\n        str: The theme style.\n    \"\"\"\n    return self.configuration[self.appearance_mode_property]\n</code></pre>"},{"location":"reference/model/config/gui_section/#src.model.config.gui_section.GUIConfig.color_theme","title":"<code>color_theme()</code>","text":"<p>Get the theme color.</p> <p>e.g \"blue\" (standard), \"green\", \"dark-blue\"</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The palate color.</p> Source code in <code>src/model/config/gui_section.py</code> <pre><code>def color_theme(self) -&gt; str:\n    \"\"\"Get the theme color.\n\n    e.g \"blue\" (standard), \"green\", \"dark-blue\"\n\n\n    Returns:\n        str: The palate color.\n    \"\"\"\n    return self.configuration[self.color_theme_property]\n</code></pre>"},{"location":"reference/model/config/gui_section/#src.model.config.gui_section.GUIConfig.initial_size","title":"<code>initial_size()</code>","text":"<p>Get the initial size of the window.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>the width and hight formatted as \"100x100\"</p> Source code in <code>src/model/config/gui_section.py</code> <pre><code>def initial_size(self) -&gt; str:\n    \"\"\"Get the initial size of the window.\n\n    Returns:\n        str: the width and hight formatted as \"100x100\"\n    \"\"\"\n    return self.configuration[self.initial_size_property]\n</code></pre>"},{"location":"reference/model/config/reader/","title":"Reader","text":""},{"location":"reference/model/config/reader/#src.model.config.reader.ConfigReader","title":"<code>ConfigReader</code>","text":"<p>             Bases: <code>object</code></p> <p>Configuration Reader.</p> <p>loads the program's configuration into memory and provides access to the sections of variables within. This class is a singleton to avoid redundant loading</p> Source code in <code>src/model/config/reader.py</code> <pre><code>class ConfigReader(object):\n    \"\"\"\n    Configuration Reader.\n\n    loads the program's configuration into memory and provides access to the\n    sections of variables within. This class is a singleton to avoid redundant\n    loading\n    \"\"\"\n\n    config_file_name = \"config.toml\"\n    _instance = None\n\n    def __new__(cls) -&gt; Self:\n        \"\"\"Create a config object.\n\n        Overridden to provide the singleton patten, there must only be one\n        config object. to avoid redundant loading\n\n        Returns:\n            Self: The config object with the loaded data\n        \"\"\"\n        # https://python-patterns.guide/gang-of-four/singleton/\n        if cls._instance is None:\n            cls._instance = super().__new__(cls)\n            cls._instance.load_config()\n        return cls._instance\n\n    def load_config(self):\n        \"\"\"Load or reload the configuration from the disk.\"\"\"\n        config_file_path = path.abspath(\n            path.join(path.dirname(__file__), \"..\", \"..\", self.config_file_name)\n        )\n\n        with open(config_file_path, \"r\") as config_file:\n            self.__raw_config = toml.load(config_file)\n\n    def grid_world(self) -&gt; GridWorldConfig:\n        \"\"\"Get the configuration for the environment.\n\n        Returns:\n            GridWorldConfig: an object that describes the environment\n            configuration\n        \"\"\"\n        return self.__initialise_section(GridWorldConfig())\n\n    def gui(self) -&gt; GUIConfig:\n        \"\"\"Get the configuration for the GUI.\n\n        Returns:\n            GUIConfig: an object that describes the gui\n            configuration\n        \"\"\"\n        return self.__initialise_section(GUIConfig())\n\n    def agent(self) -&gt; AgentConfig:\n        \"\"\"Get the configuration for agents.\n\n        Returns:\n            AgentConfig: an object that describes the agent\n            configuration\n        \"\"\"\n        return self.__initialise_section(AgentConfig())\n\n    def __initialise_section(self, section: BaseConfigSection) -&gt; Any:\n        \"\"\"Populate a section object with data.\n\n        This is an internal method\n\n        Args:\n            section (BaseConfigSection): the section to populate\n\n        Returns:\n            Any: the section object that has been populated\n        \"\"\"\n        section_raw_data = self.__raw_config[section.section_name]\n        section.initialise(section_raw_data)\n        return section\n</code></pre>"},{"location":"reference/model/config/reader/#src.model.config.reader.ConfigReader.__initialise_section","title":"<code>__initialise_section(section)</code>","text":"<p>Populate a section object with data.</p> <p>This is an internal method</p> <p>Parameters:</p> Name Type Description Default <code>section</code> <code>BaseConfigSection</code> <p>the section to populate</p> required <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>the section object that has been populated</p> Source code in <code>src/model/config/reader.py</code> <pre><code>def __initialise_section(self, section: BaseConfigSection) -&gt; Any:\n    \"\"\"Populate a section object with data.\n\n    This is an internal method\n\n    Args:\n        section (BaseConfigSection): the section to populate\n\n    Returns:\n        Any: the section object that has been populated\n    \"\"\"\n    section_raw_data = self.__raw_config[section.section_name]\n    section.initialise(section_raw_data)\n    return section\n</code></pre>"},{"location":"reference/model/config/reader/#src.model.config.reader.ConfigReader.__new__","title":"<code>__new__()</code>","text":"<p>Create a config object.</p> <p>Overridden to provide the singleton patten, there must only be one config object. to avoid redundant loading</p> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The config object with the loaded data</p> Source code in <code>src/model/config/reader.py</code> <pre><code>def __new__(cls) -&gt; Self:\n    \"\"\"Create a config object.\n\n    Overridden to provide the singleton patten, there must only be one\n    config object. to avoid redundant loading\n\n    Returns:\n        Self: The config object with the loaded data\n    \"\"\"\n    # https://python-patterns.guide/gang-of-four/singleton/\n    if cls._instance is None:\n        cls._instance = super().__new__(cls)\n        cls._instance.load_config()\n    return cls._instance\n</code></pre>"},{"location":"reference/model/config/reader/#src.model.config.reader.ConfigReader.agent","title":"<code>agent()</code>","text":"<p>Get the configuration for agents.</p> <p>Returns:</p> Name Type Description <code>AgentConfig</code> <code>AgentConfig</code> <p>an object that describes the agent</p> <code>AgentConfig</code> <p>configuration</p> Source code in <code>src/model/config/reader.py</code> <pre><code>def agent(self) -&gt; AgentConfig:\n    \"\"\"Get the configuration for agents.\n\n    Returns:\n        AgentConfig: an object that describes the agent\n        configuration\n    \"\"\"\n    return self.__initialise_section(AgentConfig())\n</code></pre>"},{"location":"reference/model/config/reader/#src.model.config.reader.ConfigReader.grid_world","title":"<code>grid_world()</code>","text":"<p>Get the configuration for the environment.</p> <p>Returns:</p> Name Type Description <code>GridWorldConfig</code> <code>GridWorldConfig</code> <p>an object that describes the environment</p> <code>GridWorldConfig</code> <p>configuration</p> Source code in <code>src/model/config/reader.py</code> <pre><code>def grid_world(self) -&gt; GridWorldConfig:\n    \"\"\"Get the configuration for the environment.\n\n    Returns:\n        GridWorldConfig: an object that describes the environment\n        configuration\n    \"\"\"\n    return self.__initialise_section(GridWorldConfig())\n</code></pre>"},{"location":"reference/model/config/reader/#src.model.config.reader.ConfigReader.gui","title":"<code>gui()</code>","text":"<p>Get the configuration for the GUI.</p> <p>Returns:</p> Name Type Description <code>GUIConfig</code> <code>GUIConfig</code> <p>an object that describes the gui</p> <code>GUIConfig</code> <p>configuration</p> Source code in <code>src/model/config/reader.py</code> <pre><code>def gui(self) -&gt; GUIConfig:\n    \"\"\"Get the configuration for the GUI.\n\n    Returns:\n        GUIConfig: an object that describes the gui\n        configuration\n    \"\"\"\n    return self.__initialise_section(GUIConfig())\n</code></pre>"},{"location":"reference/model/config/reader/#src.model.config.reader.ConfigReader.load_config","title":"<code>load_config()</code>","text":"<p>Load or reload the configuration from the disk.</p> Source code in <code>src/model/config/reader.py</code> <pre><code>def load_config(self):\n    \"\"\"Load or reload the configuration from the disk.\"\"\"\n    config_file_path = path.abspath(\n        path.join(path.dirname(__file__), \"..\", \"..\", self.config_file_name)\n    )\n\n    with open(config_file_path, \"r\") as config_file:\n        self.__raw_config = toml.load(config_file)\n</code></pre>"},{"location":"reference/model/dynamics/","title":"Dynamics","text":"<p>This package provides different dynamics models.</p>"},{"location":"reference/model/dynamics/actions/","title":"Actions","text":""},{"location":"reference/model/dynamics/actions/#src.model.dynamics.actions.Action","title":"<code>Action</code>","text":"<p>             Bases: <code>Enum</code></p> <p>Enumerates all possible actions.</p> Source code in <code>src/model/dynamics/actions.py</code> <pre><code>class Action(Enum):\n    \"\"\"Enumerates all possible actions.\"\"\"\n\n    up = 1\n    down = 2\n    left = 3\n    right = 4\n</code></pre>"},{"location":"reference/model/dynamics/base_dynamics/","title":"Base Dynamics","text":""},{"location":"reference/model/dynamics/base_dynamics/#src.model.dynamics.base_dynamics.BaseDynamics","title":"<code>BaseDynamics</code>","text":"<p>             Bases: <code>object</code></p> <p>The abstract base class for dynamics classes.</p> <p>This class provides the basic methods a dynamics class is expected to implement and some common functionality</p> Source code in <code>src/model/dynamics/base_dynamics.py</code> <pre><code>class BaseDynamics(object):\n    \"\"\"The abstract base class for dynamics classes.\n\n    This class provides the basic methods a dynamics class is expected to\n    implement and some common functionality\n    \"\"\"\n\n    def __init__(self, config: GridWorldConfig) -&gt; None:\n        \"\"\"Instantiate a dynamics, provides the minimal required properties.\n\n        Args:\n            config (GridWorldConfig): the config used by this dynamics such as\n                the size of the grid world.\n        \"\"\"\n        self.state_pool = StatePool()\n        self.config = config\n        self.grid_world = GridWorld(config.width(), config.height())\n\n    def is_stochastic(self) -&gt; bool:\n        \"\"\"Determine weather the dynamics behave stochastically.\n\n        If stochastic then there is random variability in the output of `next`.\n        However variability distribution must still be markovian.\n\n        Raises:\n            NotImplementedError: If this method has not been overridden\n\n        Should Return:\n            bool: weather this dynamics behaves stochastically.\n\n        \"\"\"\n        raise NotImplementedError(\n            \"This method must be overridden by concrete dynamics classes\"\n        )\n\n    def initial_state(self) -&gt; StateInstance:\n        \"\"\"Provide the initial state of this environment.\n\n        Raises:\n            NotImplementedError: If this method has not been overridden\n\n        Should Return:\n            StateInstance: the starting state.\n        \"\"\"\n        raise NotImplementedError(\n            \"This method must be overridden by concrete dynamics classes\"\n        )\n\n    def next(\n        self, current_state: StateInstance, action: Action\n    ) -&gt; tuple[StateInstance, float]:\n        \"\"\"Compute the next state and reward.\n\n        Must only compute the next reward and state based on only the provided\n        current state and reward to obey the markov property.\n\n        Args:\n            current_state (StateInstance): the state that the action is\n                performed in\n            action (Action): the action the agent has chosen\n\n\n        Raises:\n            NotImplementedError: If this method has not been overridden\n\n        Should Return:\n            tuple[StateInstance, float]: the resulting state after the action\n            has been performed and the reward from this action\n        \"\"\"\n        raise NotImplementedError(\n            \"This method must be overridden by concrete dynamics classes\"\n        )\n\n    def initial_state_id(self) -&gt; int:\n        \"\"\"Provide the initial state id of this environment.\n\n        Raises:\n            NotImplementedError: If this method has not been overridden\n\n        Returns:\n            int: the starting state id.\n        \"\"\"\n        return self.state_pool.get_state_id(self.initial_state())\n\n    def next_state_id(\n        self, current_state_id: int, action: Action\n    ) -&gt; tuple[int, float]:\n        \"\"\"Compute the next state and reward.\n\n        Must only compute the next reward and state based on only the provided\n        current state and reward to obey the markov property.\n\n        Args:\n            current_state_id (int): the state that the action is\n                performed in\n            action (Action): the action the agent has chosen\n\n\n        Raises:\n            NotImplementedError: If this method has not been overridden\n\n        Returns:\n            tuple[int, float]: the resulting state after the action has been\n            performed and the reward from this action\n        \"\"\"\n        current_state = self.state_pool.get_state_from_id(current_state_id)\n        next_state, reward = self.next(current_state, action)\n        return self.state_pool.get_state_id(next_state), reward\n</code></pre>"},{"location":"reference/model/dynamics/base_dynamics/#src.model.dynamics.base_dynamics.BaseDynamics.__init__","title":"<code>__init__(config)</code>","text":"<p>Instantiate a dynamics, provides the minimal required properties.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>GridWorldConfig</code> <p>the config used by this dynamics such as the size of the grid world.</p> required Source code in <code>src/model/dynamics/base_dynamics.py</code> <pre><code>def __init__(self, config: GridWorldConfig) -&gt; None:\n    \"\"\"Instantiate a dynamics, provides the minimal required properties.\n\n    Args:\n        config (GridWorldConfig): the config used by this dynamics such as\n            the size of the grid world.\n    \"\"\"\n    self.state_pool = StatePool()\n    self.config = config\n    self.grid_world = GridWorld(config.width(), config.height())\n</code></pre>"},{"location":"reference/model/dynamics/base_dynamics/#src.model.dynamics.base_dynamics.BaseDynamics.initial_state","title":"<code>initial_state()</code>","text":"<p>Provide the initial state of this environment.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If this method has not been overridden</p> Should Return <p>StateInstance: the starting state.</p> Source code in <code>src/model/dynamics/base_dynamics.py</code> <pre><code>def initial_state(self) -&gt; StateInstance:\n    \"\"\"Provide the initial state of this environment.\n\n    Raises:\n        NotImplementedError: If this method has not been overridden\n\n    Should Return:\n        StateInstance: the starting state.\n    \"\"\"\n    raise NotImplementedError(\n        \"This method must be overridden by concrete dynamics classes\"\n    )\n</code></pre>"},{"location":"reference/model/dynamics/base_dynamics/#src.model.dynamics.base_dynamics.BaseDynamics.initial_state_id","title":"<code>initial_state_id()</code>","text":"<p>Provide the initial state id of this environment.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If this method has not been overridden</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>the starting state id.</p> Source code in <code>src/model/dynamics/base_dynamics.py</code> <pre><code>def initial_state_id(self) -&gt; int:\n    \"\"\"Provide the initial state id of this environment.\n\n    Raises:\n        NotImplementedError: If this method has not been overridden\n\n    Returns:\n        int: the starting state id.\n    \"\"\"\n    return self.state_pool.get_state_id(self.initial_state())\n</code></pre>"},{"location":"reference/model/dynamics/base_dynamics/#src.model.dynamics.base_dynamics.BaseDynamics.is_stochastic","title":"<code>is_stochastic()</code>","text":"<p>Determine weather the dynamics behave stochastically.</p> <p>If stochastic then there is random variability in the output of <code>next</code>. However variability distribution must still be markovian.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If this method has not been overridden</p> Should Return <p>bool: weather this dynamics behaves stochastically.</p> Source code in <code>src/model/dynamics/base_dynamics.py</code> <pre><code>def is_stochastic(self) -&gt; bool:\n    \"\"\"Determine weather the dynamics behave stochastically.\n\n    If stochastic then there is random variability in the output of `next`.\n    However variability distribution must still be markovian.\n\n    Raises:\n        NotImplementedError: If this method has not been overridden\n\n    Should Return:\n        bool: weather this dynamics behaves stochastically.\n\n    \"\"\"\n    raise NotImplementedError(\n        \"This method must be overridden by concrete dynamics classes\"\n    )\n</code></pre>"},{"location":"reference/model/dynamics/base_dynamics/#src.model.dynamics.base_dynamics.BaseDynamics.next","title":"<code>next(current_state, action)</code>","text":"<p>Compute the next state and reward.</p> <p>Must only compute the next reward and state based on only the provided current state and reward to obey the markov property.</p> <p>Parameters:</p> Name Type Description Default <code>current_state</code> <code>StateInstance</code> <p>the state that the action is performed in</p> required <code>action</code> <code>Action</code> <p>the action the agent has chosen</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If this method has not been overridden</p> Should Return <p>tuple[StateInstance, float]: the resulting state after the action has been performed and the reward from this action</p> Source code in <code>src/model/dynamics/base_dynamics.py</code> <pre><code>def next(\n    self, current_state: StateInstance, action: Action\n) -&gt; tuple[StateInstance, float]:\n    \"\"\"Compute the next state and reward.\n\n    Must only compute the next reward and state based on only the provided\n    current state and reward to obey the markov property.\n\n    Args:\n        current_state (StateInstance): the state that the action is\n            performed in\n        action (Action): the action the agent has chosen\n\n\n    Raises:\n        NotImplementedError: If this method has not been overridden\n\n    Should Return:\n        tuple[StateInstance, float]: the resulting state after the action\n        has been performed and the reward from this action\n    \"\"\"\n    raise NotImplementedError(\n        \"This method must be overridden by concrete dynamics classes\"\n    )\n</code></pre>"},{"location":"reference/model/dynamics/base_dynamics/#src.model.dynamics.base_dynamics.BaseDynamics.next_state_id","title":"<code>next_state_id(current_state_id, action)</code>","text":"<p>Compute the next state and reward.</p> <p>Must only compute the next reward and state based on only the provided current state and reward to obey the markov property.</p> <p>Parameters:</p> Name Type Description Default <code>current_state_id</code> <code>int</code> <p>the state that the action is performed in</p> required <code>action</code> <code>Action</code> <p>the action the agent has chosen</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If this method has not been overridden</p> <p>Returns:</p> Type Description <code>int</code> <p>tuple[int, float]: the resulting state after the action has been</p> <code>float</code> <p>performed and the reward from this action</p> Source code in <code>src/model/dynamics/base_dynamics.py</code> <pre><code>def next_state_id(\n    self, current_state_id: int, action: Action\n) -&gt; tuple[int, float]:\n    \"\"\"Compute the next state and reward.\n\n    Must only compute the next reward and state based on only the provided\n    current state and reward to obey the markov property.\n\n    Args:\n        current_state_id (int): the state that the action is\n            performed in\n        action (Action): the action the agent has chosen\n\n\n    Raises:\n        NotImplementedError: If this method has not been overridden\n\n    Returns:\n        tuple[int, float]: the resulting state after the action has been\n        performed and the reward from this action\n    \"\"\"\n    current_state = self.state_pool.get_state_from_id(current_state_id)\n    next_state, reward = self.next(current_state, action)\n    return self.state_pool.get_state_id(next_state), reward\n</code></pre>"},{"location":"reference/model/dynamics/collection_dynamics/","title":"Collection Dynamics","text":""},{"location":"reference/model/dynamics/collection_dynamics/#src.model.dynamics.collection_dynamics.CollectionDynamics","title":"<code>CollectionDynamics</code>","text":"<p>             Bases: <code>BaseDynamics</code></p> <p>Simple Dynamics where the agent can move to cells to collect goals.</p> Source code in <code>src/model/dynamics/collection_dynamics.py</code> <pre><code>class CollectionDynamics(BaseDynamics):\n    \"\"\"Simple Dynamics where the agent can move to cells to collect goals.\"\"\"\n\n    def __init__(self, config: GridWorldConfig) -&gt; None:\n        \"\"\"Initialise collection dynamics.\n\n        Args:\n            config (GridWorldConfig): the configuration used by this dynamics.\n        \"\"\"\n        super().__init__(config)\n        self.spawn_positions: Optional[spawn_positions_type] = None\n\n    def is_stochastic(self) -&gt; bool:\n        \"\"\"Determine weather the dynamics behave stochastically.\n\n        Returns:\n            bool: false, this dynamics is deterministic\n        \"\"\"\n        return False\n\n    def get_spawn_positions(self) -&gt; spawn_positions_type:\n        \"\"\"Get the positions where flags can be spawned.\n\n        these will be a number of unique positions in the grid world bounds.\n        Initially chosen at random but then fixed for subsequent calls\n\n        Returns:\n            spawn_positions_type: the set of positions where goals can be\n            spawned.\n        \"\"\"\n        if self.spawn_positions is not None:\n            return self.spawn_positions\n        agent_location = self.config.agent_location()\n        self.spawn_positions = set()\n        while len(self.spawn_positions) &lt; self.config.entity_count():\n            location = self.grid_world.random_in_bounds_cell()\n            if location != agent_location:\n                self.spawn_positions.add(location)\n        return self.spawn_positions\n\n    def initial_state(self) -&gt; StateInstance:\n        \"\"\"Provide the initial state of this environment.\n\n        Raises:\n            ValueError: if the config specifies an invalid state. such as the\n                agent location being outside the bounds of the grid.\n\n        Returns:\n            StateInstance: the starting state.\n\n        \"\"\"\n        if not self.grid_world.is_in_bounds(self.config.agent_location()):\n            raise ValueError(\"config agent location outside of map bounds\")\n\n        initial_state_builder = (\n            StateBuilder()\n            .set_agent_location(self.config.agent_location())\n            .set_energy(self.config.initial_energy())\n        )\n\n        for goal in self.get_spawn_positions():\n            initial_state_builder.set_entity(goal, CellEntity.goal)\n\n        return initial_state_builder.build()\n\n    def next(\n        self, current_state: StateInstance, action: Action\n    ) -&gt; tuple[StateInstance, float]:\n        \"\"\"Compute the next state and reward.\n\n        Must only compute the next reward and state based on only the provided\n        current state and reward to obey the markov property.\n\n        Args:\n            current_state (StateInstance): the state that the action is\n                performed in\n            action (Action): the action the agent has chosen\n\n\n        Returns:\n            tuple[StateInstance, float]: the resulting state after the action\n            has been performed and the reward from this action\n        \"\"\"\n        next_state_builder = StateBuilder(current_state)\n        next_agent_location = self.grid_world.movement_action(\n            current_state.agent_location, action\n        )\n        if not self.grid_world.is_in_bounds(next_agent_location):\n            return current_state, 0\n\n        next_state_builder.set_agent_location(next_agent_location)\n\n        if next_agent_location not in current_state.entities:\n            return next_state_builder.build(), 0\n\n        next_state_builder.remove_entity(next_agent_location)\n\n        if not next_state_builder.entities:\n            # Terminal state all goals have been collected, loop to beginning to\n            # make task continuous\n            return self.initial_state(), 1\n        return next_state_builder.build(), 1\n</code></pre>"},{"location":"reference/model/dynamics/collection_dynamics/#src.model.dynamics.collection_dynamics.CollectionDynamics.__init__","title":"<code>__init__(config)</code>","text":"<p>Initialise collection dynamics.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>GridWorldConfig</code> <p>the configuration used by this dynamics.</p> required Source code in <code>src/model/dynamics/collection_dynamics.py</code> <pre><code>def __init__(self, config: GridWorldConfig) -&gt; None:\n    \"\"\"Initialise collection dynamics.\n\n    Args:\n        config (GridWorldConfig): the configuration used by this dynamics.\n    \"\"\"\n    super().__init__(config)\n    self.spawn_positions: Optional[spawn_positions_type] = None\n</code></pre>"},{"location":"reference/model/dynamics/collection_dynamics/#src.model.dynamics.collection_dynamics.CollectionDynamics.get_spawn_positions","title":"<code>get_spawn_positions()</code>","text":"<p>Get the positions where flags can be spawned.</p> <p>these will be a number of unique positions in the grid world bounds. Initially chosen at random but then fixed for subsequent calls</p> <p>Returns:</p> Name Type Description <code>spawn_positions_type</code> <code>spawn_positions_type</code> <p>the set of positions where goals can be</p> <code>spawn_positions_type</code> <p>spawned.</p> Source code in <code>src/model/dynamics/collection_dynamics.py</code> <pre><code>def get_spawn_positions(self) -&gt; spawn_positions_type:\n    \"\"\"Get the positions where flags can be spawned.\n\n    these will be a number of unique positions in the grid world bounds.\n    Initially chosen at random but then fixed for subsequent calls\n\n    Returns:\n        spawn_positions_type: the set of positions where goals can be\n        spawned.\n    \"\"\"\n    if self.spawn_positions is not None:\n        return self.spawn_positions\n    agent_location = self.config.agent_location()\n    self.spawn_positions = set()\n    while len(self.spawn_positions) &lt; self.config.entity_count():\n        location = self.grid_world.random_in_bounds_cell()\n        if location != agent_location:\n            self.spawn_positions.add(location)\n    return self.spawn_positions\n</code></pre>"},{"location":"reference/model/dynamics/collection_dynamics/#src.model.dynamics.collection_dynamics.CollectionDynamics.initial_state","title":"<code>initial_state()</code>","text":"<p>Provide the initial state of this environment.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if the config specifies an invalid state. such as the agent location being outside the bounds of the grid.</p> <p>Returns:</p> Name Type Description <code>StateInstance</code> <code>StateInstance</code> <p>the starting state.</p> Source code in <code>src/model/dynamics/collection_dynamics.py</code> <pre><code>def initial_state(self) -&gt; StateInstance:\n    \"\"\"Provide the initial state of this environment.\n\n    Raises:\n        ValueError: if the config specifies an invalid state. such as the\n            agent location being outside the bounds of the grid.\n\n    Returns:\n        StateInstance: the starting state.\n\n    \"\"\"\n    if not self.grid_world.is_in_bounds(self.config.agent_location()):\n        raise ValueError(\"config agent location outside of map bounds\")\n\n    initial_state_builder = (\n        StateBuilder()\n        .set_agent_location(self.config.agent_location())\n        .set_energy(self.config.initial_energy())\n    )\n\n    for goal in self.get_spawn_positions():\n        initial_state_builder.set_entity(goal, CellEntity.goal)\n\n    return initial_state_builder.build()\n</code></pre>"},{"location":"reference/model/dynamics/collection_dynamics/#src.model.dynamics.collection_dynamics.CollectionDynamics.is_stochastic","title":"<code>is_stochastic()</code>","text":"<p>Determine weather the dynamics behave stochastically.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>false, this dynamics is deterministic</p> Source code in <code>src/model/dynamics/collection_dynamics.py</code> <pre><code>def is_stochastic(self) -&gt; bool:\n    \"\"\"Determine weather the dynamics behave stochastically.\n\n    Returns:\n        bool: false, this dynamics is deterministic\n    \"\"\"\n    return False\n</code></pre>"},{"location":"reference/model/dynamics/collection_dynamics/#src.model.dynamics.collection_dynamics.CollectionDynamics.next","title":"<code>next(current_state, action)</code>","text":"<p>Compute the next state and reward.</p> <p>Must only compute the next reward and state based on only the provided current state and reward to obey the markov property.</p> <p>Parameters:</p> Name Type Description Default <code>current_state</code> <code>StateInstance</code> <p>the state that the action is performed in</p> required <code>action</code> <code>Action</code> <p>the action the agent has chosen</p> required <p>Returns:</p> Type Description <code>StateInstance</code> <p>tuple[StateInstance, float]: the resulting state after the action</p> <code>float</code> <p>has been performed and the reward from this action</p> Source code in <code>src/model/dynamics/collection_dynamics.py</code> <pre><code>def next(\n    self, current_state: StateInstance, action: Action\n) -&gt; tuple[StateInstance, float]:\n    \"\"\"Compute the next state and reward.\n\n    Must only compute the next reward and state based on only the provided\n    current state and reward to obey the markov property.\n\n    Args:\n        current_state (StateInstance): the state that the action is\n            performed in\n        action (Action): the action the agent has chosen\n\n\n    Returns:\n        tuple[StateInstance, float]: the resulting state after the action\n        has been performed and the reward from this action\n    \"\"\"\n    next_state_builder = StateBuilder(current_state)\n    next_agent_location = self.grid_world.movement_action(\n        current_state.agent_location, action\n    )\n    if not self.grid_world.is_in_bounds(next_agent_location):\n        return current_state, 0\n\n    next_state_builder.set_agent_location(next_agent_location)\n\n    if next_agent_location not in current_state.entities:\n        return next_state_builder.build(), 0\n\n    next_state_builder.remove_entity(next_agent_location)\n\n    if not next_state_builder.entities:\n        # Terminal state all goals have been collected, loop to beginning to\n        # make task continuous\n        return self.initial_state(), 1\n    return next_state_builder.build(), 1\n</code></pre>"},{"location":"reference/model/dynamics/grid_world/","title":"Grid World","text":""},{"location":"reference/model/dynamics/grid_world/#src.model.dynamics.grid_world.GridWorld","title":"<code>GridWorld</code>","text":"<p>             Bases: <code>object</code></p> <p>Provide common functionality for working with a grid world.</p> Source code in <code>src/model/dynamics/grid_world.py</code> <pre><code>class GridWorld(object):\n    \"\"\"Provide common functionality for working with a grid world.\"\"\"\n\n    def __init__(self, width: int, height: int) -&gt; None:\n        \"\"\"Initialise a grid world with a given size.\n\n        Raises:\n            TypeError: If the width or height are not integers\n            ValueError: if the width or height are not positive integer\n\n        Args:\n            width (int): The width of the grid world.\n            height (int): The height of the gird world.\n        \"\"\"\n        if not isinstance(width, int) or not isinstance(height, int):\n            raise TypeError(\"width and height must be valid integers\")\n        elif width &lt; 1 or height &lt; 1:\n            raise ValueError(\"width and height must be positive integers\")\n\n        self.width = width\n        self.height = height\n\n    def is_in_bounds(self, position: tuple[int, int]) -&gt; bool:\n        \"\"\"Detect either a position is within the bounds of the grid.\n\n        Args:\n            position (tuple[int, int]): the position to test\n\n        Returns:\n            bool: true where the position is within the bounds of the grid\n            world.\n        \"\"\"\n        x_pos, y_pos = position\n        return 0 &lt;= x_pos &lt; self.width and 0 &lt;= y_pos &lt; self.height\n\n    def random_in_bounds_cell(self) -&gt; tuple[int, int]:\n        \"\"\"Generate a random cell position that is within bounds.\n\n        Returns:\n            tuple[int, int]: the cell position within the grid.\n        \"\"\"\n        dimensions = np.array([self.width, self.height])\n        position_float = np.random.rand(2) * dimensions\n        position_integer = np.floor(position_float).astype(int)\n        return (position_integer[0], position_integer[1])\n\n    action_direction: Dict[Action, Tuple[int, int]] = {\n        Action.up: (0, -1),\n        Action.down: (0, 1),\n        Action.right: (1, 0),\n        Action.left: (-1, 0),\n    }\n\n    def movement_action(\n        self,\n        current_position: integer_position,\n        action: Action,\n        distance: int = 1,\n    ) -&gt; integer_position:\n        \"\"\"Calculate the adjacent cell in a given direction.\n\n        The direction is provided from the up,down,left and right actions. This\n        method calculates the next position assuming the origin is at the top\n        left of the grid.\n\n        note this may compute a cell that is out of bounds, to check and handel\n        this please use `is_in_bounds` method.\n\n        Args:\n            current_position (integer_position): the position to start from.\n            action (Action): provides the direction to move in.\n            distance (int): the amount of cells to move. Defaults to 1.\n\n        Raises:\n            ValueError: If the action provided is not a known movement action.\n\n        Returns:\n            integer_position: The position after moving.\n        \"\"\"\n        if action not in self.action_direction:\n            raise ValueError(\n                f\"Action {action.name} is not a known movement action\"\n            )\n        x_pos, y_pos = current_position\n        dir_x, dir_y = self.action_direction[action]\n        return (x_pos + dir_x * distance, y_pos + dir_y * distance)\n\n    def list_cells(self) -&gt; Generator[integer_position, None, None]:\n        \"\"\"Generate all cells in the grid world.\n\n        Yields:\n            Generator[integer_position, None, None]: each cell location\n        \"\"\"\n        for y_pos in range(self.height):\n            yield from ((x_pos, y_pos) for x_pos in range(self.width))\n\n    def get_cell_sizing(\n        self, width: int, height: int, relative_margins: float\n    ) -&gt; Tuple[int, int]:\n        \"\"\"Get the sizing of a cell in the given rectangle and margins.\n\n        Args:\n            width (int): the width of the containing rectangle\n            height (int): the hight of the containing rectangle\n            relative_margins (float): how large should the gap between cells be.\n                relative to the size of a cell with no margins\n\n        Returns:\n            Tuple[int, int]: the cell size and the margin size\n        \"\"\"\n        rows = self.height\n        columns = self.width\n\n        content_ratio = rows / columns\n        container_ratio = height / width\n\n        cell_spacing = int(\n            width / columns\n            if container_ratio &gt; content_ratio\n            else height / rows\n        )\n        margins = int(max(cell_spacing * relative_margins, 1))\n        return cell_spacing, margins\n\n    def list_cell_positions(\n        self, width: int, height: int, relative_margins: float\n    ) -&gt; location_generator:\n        \"\"\"Generate the cell locations in a given rectangle.\n\n        the cells will be centred if there is the aspect ratio's are not aligned\n\n        returns the cell position in gird world coordinates, the location of\n        corner that is closest to the origin then the corner that is the\n        furthest.\n\n        assumes cells should be square.\n\n        Args:\n            width (int): the width of the containing rectangle\n            height (int): the hight of the containing rectangle\n            relative_margins (float): how large should the gap between cells be.\n                relative to the size of a cell with no margins\n\n        Yields:\n            Iterator[location_generator]: the coordinates\n        \"\"\"\n        rows = self.height\n        columns = self.width\n\n        cell_spacing, margins = self.get_cell_sizing(\n            width, height, relative_margins\n        )\n\n        offset_min_x = int((width - columns * cell_spacing) / 2)\n        offset_min_y = int((height - rows * cell_spacing) / 2)\n\n        offset_min_x += margins // 2\n        offset_min_y += margins // 2\n\n        offset_max_x = offset_min_x + cell_spacing - margins\n        offset_max_y = offset_min_y + cell_spacing - margins\n\n        for pos in self.list_cells():\n            bounding_box = (\n                offset_min_x + cell_spacing * pos[0],\n                offset_min_y + cell_spacing * pos[1],\n                offset_max_x + cell_spacing * pos[0],\n                offset_max_y + cell_spacing * pos[1],\n            )\n            yield pos, bounding_box\n</code></pre>"},{"location":"reference/model/dynamics/grid_world/#src.model.dynamics.grid_world.GridWorld.__init__","title":"<code>__init__(width, height)</code>","text":"<p>Initialise a grid world with a given size.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If the width or height are not integers</p> <code>ValueError</code> <p>if the width or height are not positive integer</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>The width of the grid world.</p> required <code>height</code> <code>int</code> <p>The height of the gird world.</p> required Source code in <code>src/model/dynamics/grid_world.py</code> <pre><code>def __init__(self, width: int, height: int) -&gt; None:\n    \"\"\"Initialise a grid world with a given size.\n\n    Raises:\n        TypeError: If the width or height are not integers\n        ValueError: if the width or height are not positive integer\n\n    Args:\n        width (int): The width of the grid world.\n        height (int): The height of the gird world.\n    \"\"\"\n    if not isinstance(width, int) or not isinstance(height, int):\n        raise TypeError(\"width and height must be valid integers\")\n    elif width &lt; 1 or height &lt; 1:\n        raise ValueError(\"width and height must be positive integers\")\n\n    self.width = width\n    self.height = height\n</code></pre>"},{"location":"reference/model/dynamics/grid_world/#src.model.dynamics.grid_world.GridWorld.get_cell_sizing","title":"<code>get_cell_sizing(width, height, relative_margins)</code>","text":"<p>Get the sizing of a cell in the given rectangle and margins.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>the width of the containing rectangle</p> required <code>height</code> <code>int</code> <p>the hight of the containing rectangle</p> required <code>relative_margins</code> <code>float</code> <p>how large should the gap between cells be. relative to the size of a cell with no margins</p> required <p>Returns:</p> Type Description <code>Tuple[int, int]</code> <p>Tuple[int, int]: the cell size and the margin size</p> Source code in <code>src/model/dynamics/grid_world.py</code> <pre><code>def get_cell_sizing(\n    self, width: int, height: int, relative_margins: float\n) -&gt; Tuple[int, int]:\n    \"\"\"Get the sizing of a cell in the given rectangle and margins.\n\n    Args:\n        width (int): the width of the containing rectangle\n        height (int): the hight of the containing rectangle\n        relative_margins (float): how large should the gap between cells be.\n            relative to the size of a cell with no margins\n\n    Returns:\n        Tuple[int, int]: the cell size and the margin size\n    \"\"\"\n    rows = self.height\n    columns = self.width\n\n    content_ratio = rows / columns\n    container_ratio = height / width\n\n    cell_spacing = int(\n        width / columns\n        if container_ratio &gt; content_ratio\n        else height / rows\n    )\n    margins = int(max(cell_spacing * relative_margins, 1))\n    return cell_spacing, margins\n</code></pre>"},{"location":"reference/model/dynamics/grid_world/#src.model.dynamics.grid_world.GridWorld.is_in_bounds","title":"<code>is_in_bounds(position)</code>","text":"<p>Detect either a position is within the bounds of the grid.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>tuple[int, int]</code> <p>the position to test</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>true where the position is within the bounds of the grid</p> <code>bool</code> <p>world.</p> Source code in <code>src/model/dynamics/grid_world.py</code> <pre><code>def is_in_bounds(self, position: tuple[int, int]) -&gt; bool:\n    \"\"\"Detect either a position is within the bounds of the grid.\n\n    Args:\n        position (tuple[int, int]): the position to test\n\n    Returns:\n        bool: true where the position is within the bounds of the grid\n        world.\n    \"\"\"\n    x_pos, y_pos = position\n    return 0 &lt;= x_pos &lt; self.width and 0 &lt;= y_pos &lt; self.height\n</code></pre>"},{"location":"reference/model/dynamics/grid_world/#src.model.dynamics.grid_world.GridWorld.list_cell_positions","title":"<code>list_cell_positions(width, height, relative_margins)</code>","text":"<p>Generate the cell locations in a given rectangle.</p> <p>the cells will be centred if there is the aspect ratio's are not aligned</p> <p>returns the cell position in gird world coordinates, the location of corner that is closest to the origin then the corner that is the furthest.</p> <p>assumes cells should be square.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>the width of the containing rectangle</p> required <code>height</code> <code>int</code> <p>the hight of the containing rectangle</p> required <code>relative_margins</code> <code>float</code> <p>how large should the gap between cells be. relative to the size of a cell with no margins</p> required <p>Yields:</p> Type Description <code>location_generator</code> <p>Iterator[location_generator]: the coordinates</p> Source code in <code>src/model/dynamics/grid_world.py</code> <pre><code>def list_cell_positions(\n    self, width: int, height: int, relative_margins: float\n) -&gt; location_generator:\n    \"\"\"Generate the cell locations in a given rectangle.\n\n    the cells will be centred if there is the aspect ratio's are not aligned\n\n    returns the cell position in gird world coordinates, the location of\n    corner that is closest to the origin then the corner that is the\n    furthest.\n\n    assumes cells should be square.\n\n    Args:\n        width (int): the width of the containing rectangle\n        height (int): the hight of the containing rectangle\n        relative_margins (float): how large should the gap between cells be.\n            relative to the size of a cell with no margins\n\n    Yields:\n        Iterator[location_generator]: the coordinates\n    \"\"\"\n    rows = self.height\n    columns = self.width\n\n    cell_spacing, margins = self.get_cell_sizing(\n        width, height, relative_margins\n    )\n\n    offset_min_x = int((width - columns * cell_spacing) / 2)\n    offset_min_y = int((height - rows * cell_spacing) / 2)\n\n    offset_min_x += margins // 2\n    offset_min_y += margins // 2\n\n    offset_max_x = offset_min_x + cell_spacing - margins\n    offset_max_y = offset_min_y + cell_spacing - margins\n\n    for pos in self.list_cells():\n        bounding_box = (\n            offset_min_x + cell_spacing * pos[0],\n            offset_min_y + cell_spacing * pos[1],\n            offset_max_x + cell_spacing * pos[0],\n            offset_max_y + cell_spacing * pos[1],\n        )\n        yield pos, bounding_box\n</code></pre>"},{"location":"reference/model/dynamics/grid_world/#src.model.dynamics.grid_world.GridWorld.list_cells","title":"<code>list_cells()</code>","text":"<p>Generate all cells in the grid world.</p> <p>Yields:</p> Type Description <code>integer_position</code> <p>Generator[integer_position, None, None]: each cell location</p> Source code in <code>src/model/dynamics/grid_world.py</code> <pre><code>def list_cells(self) -&gt; Generator[integer_position, None, None]:\n    \"\"\"Generate all cells in the grid world.\n\n    Yields:\n        Generator[integer_position, None, None]: each cell location\n    \"\"\"\n    for y_pos in range(self.height):\n        yield from ((x_pos, y_pos) for x_pos in range(self.width))\n</code></pre>"},{"location":"reference/model/dynamics/grid_world/#src.model.dynamics.grid_world.GridWorld.movement_action","title":"<code>movement_action(current_position, action, distance=1)</code>","text":"<p>Calculate the adjacent cell in a given direction.</p> <p>The direction is provided from the up,down,left and right actions. This method calculates the next position assuming the origin is at the top left of the grid.</p> <p>note this may compute a cell that is out of bounds, to check and handel this please use <code>is_in_bounds</code> method.</p> <p>Parameters:</p> Name Type Description Default <code>current_position</code> <code>integer_position</code> <p>the position to start from.</p> required <code>action</code> <code>Action</code> <p>provides the direction to move in.</p> required <code>distance</code> <code>int</code> <p>the amount of cells to move. Defaults to 1.</p> <code>1</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the action provided is not a known movement action.</p> <p>Returns:</p> Name Type Description <code>integer_position</code> <code>integer_position</code> <p>The position after moving.</p> Source code in <code>src/model/dynamics/grid_world.py</code> <pre><code>def movement_action(\n    self,\n    current_position: integer_position,\n    action: Action,\n    distance: int = 1,\n) -&gt; integer_position:\n    \"\"\"Calculate the adjacent cell in a given direction.\n\n    The direction is provided from the up,down,left and right actions. This\n    method calculates the next position assuming the origin is at the top\n    left of the grid.\n\n    note this may compute a cell that is out of bounds, to check and handel\n    this please use `is_in_bounds` method.\n\n    Args:\n        current_position (integer_position): the position to start from.\n        action (Action): provides the direction to move in.\n        distance (int): the amount of cells to move. Defaults to 1.\n\n    Raises:\n        ValueError: If the action provided is not a known movement action.\n\n    Returns:\n        integer_position: The position after moving.\n    \"\"\"\n    if action not in self.action_direction:\n        raise ValueError(\n            f\"Action {action.name} is not a known movement action\"\n        )\n    x_pos, y_pos = current_position\n    dir_x, dir_y = self.action_direction[action]\n    return (x_pos + dir_x * distance, y_pos + dir_y * distance)\n</code></pre>"},{"location":"reference/model/dynamics/grid_world/#src.model.dynamics.grid_world.GridWorld.random_in_bounds_cell","title":"<code>random_in_bounds_cell()</code>","text":"<p>Generate a random cell position that is within bounds.</p> <p>Returns:</p> Type Description <code>tuple[int, int]</code> <p>tuple[int, int]: the cell position within the grid.</p> Source code in <code>src/model/dynamics/grid_world.py</code> <pre><code>def random_in_bounds_cell(self) -&gt; tuple[int, int]:\n    \"\"\"Generate a random cell position that is within bounds.\n\n    Returns:\n        tuple[int, int]: the cell position within the grid.\n    \"\"\"\n    dimensions = np.array([self.width, self.height])\n    position_float = np.random.rand(2) * dimensions\n    position_integer = np.floor(position_float).astype(int)\n    return (position_integer[0], position_integer[1])\n</code></pre>"},{"location":"reference/model/learning_system/","title":"Learning System","text":"<p>This package connects agents and dynamics.</p> <p>It provides methods for progressing the current state and visualising it.</p>"},{"location":"reference/model/learning_system/base_entity_decorator/","title":"Base Entity Decorator","text":""},{"location":"reference/model/learning_system/base_entity_decorator/#src.model.learning_system.base_entity_decorator.BaseEntityDecorator","title":"<code>BaseEntityDecorator</code>","text":"<p>             Bases: <code>object</code></p> <p>Base class for Wrapper classes of the top level entities.</p> Source code in <code>src/model/learning_system/base_entity_decorator.py</code> <pre><code>class BaseEntityDecorator(object):\n    \"\"\"Base class for Wrapper classes of the top level entities.\"\"\"\n\n    def __init__(self, entities: TopLevelEntities) -&gt; None:\n        \"\"\"Initialise the decorator.\n\n        Args:\n            entities (TopLevelEntities): The entities the cell configuration is\n                based upon.\n        \"\"\"\n        self.entities = entities\n\n    def update_entities(self, entities: TopLevelEntities) -&gt; None:\n        \"\"\"Update the entities this wrapper uses internally.\n\n        Args:\n            entities (TopLevelEntities): The new entities used internally\n        \"\"\"\n        self.entities = entities\n\n    @property\n    def grid_world(self) -&gt; GridWorld:\n        \"\"\"Access the grid world.\n\n        Returns:\n            GridWorld: the grid world for these entities.\n        \"\"\"\n        return self.entities.dynamics.grid_world\n\n    @property\n    def state_pool(self) -&gt; StatePool:\n        \"\"\"Access the state pool.\n\n        Returns:\n            StatePool: the state pool uses by these entities.\n        \"\"\"\n        return self.entities.dynamics.state_pool\n\n    @property\n    def agent(self) -&gt; BaseAgent:\n        \"\"\"Access the agent of these entities.\n\n        Returns:\n            BaseAgent: the agent used by these entities\n        \"\"\"\n        return self.entities.agent\n\n    @property\n    def dynamics(self) -&gt; BaseDynamics:\n        \"\"\"Access the dynamics of these entities.\n\n        Returns:\n            BaseDynamics: the dynamics part of these entities\n        \"\"\"\n        return self.entities.dynamics\n\n    @property\n    def options(self) -&gt; GlobalOptions:\n        \"\"\"Access the options of these entities.\n\n        Returns:\n            GlobalOptions: the options part of these entities\n        \"\"\"\n        return self.entities.options\n</code></pre>"},{"location":"reference/model/learning_system/base_entity_decorator/#src.model.learning_system.base_entity_decorator.BaseEntityDecorator.agent","title":"<code>agent: BaseAgent</code>  <code>property</code>","text":"<p>Access the agent of these entities.</p> <p>Returns:</p> Name Type Description <code>BaseAgent</code> <code>BaseAgent</code> <p>the agent used by these entities</p>"},{"location":"reference/model/learning_system/base_entity_decorator/#src.model.learning_system.base_entity_decorator.BaseEntityDecorator.dynamics","title":"<code>dynamics: BaseDynamics</code>  <code>property</code>","text":"<p>Access the dynamics of these entities.</p> <p>Returns:</p> Name Type Description <code>BaseDynamics</code> <code>BaseDynamics</code> <p>the dynamics part of these entities</p>"},{"location":"reference/model/learning_system/base_entity_decorator/#src.model.learning_system.base_entity_decorator.BaseEntityDecorator.grid_world","title":"<code>grid_world: GridWorld</code>  <code>property</code>","text":"<p>Access the grid world.</p> <p>Returns:</p> Name Type Description <code>GridWorld</code> <code>GridWorld</code> <p>the grid world for these entities.</p>"},{"location":"reference/model/learning_system/base_entity_decorator/#src.model.learning_system.base_entity_decorator.BaseEntityDecorator.options","title":"<code>options: GlobalOptions</code>  <code>property</code>","text":"<p>Access the options of these entities.</p> <p>Returns:</p> Name Type Description <code>GlobalOptions</code> <code>GlobalOptions</code> <p>the options part of these entities</p>"},{"location":"reference/model/learning_system/base_entity_decorator/#src.model.learning_system.base_entity_decorator.BaseEntityDecorator.state_pool","title":"<code>state_pool: StatePool</code>  <code>property</code>","text":"<p>Access the state pool.</p> <p>Returns:</p> Name Type Description <code>StatePool</code> <code>StatePool</code> <p>the state pool uses by these entities.</p>"},{"location":"reference/model/learning_system/base_entity_decorator/#src.model.learning_system.base_entity_decorator.BaseEntityDecorator.__init__","title":"<code>__init__(entities)</code>","text":"<p>Initialise the decorator.</p> <p>Parameters:</p> Name Type Description Default <code>entities</code> <code>TopLevelEntities</code> <p>The entities the cell configuration is based upon.</p> required Source code in <code>src/model/learning_system/base_entity_decorator.py</code> <pre><code>def __init__(self, entities: TopLevelEntities) -&gt; None:\n    \"\"\"Initialise the decorator.\n\n    Args:\n        entities (TopLevelEntities): The entities the cell configuration is\n            based upon.\n    \"\"\"\n    self.entities = entities\n</code></pre>"},{"location":"reference/model/learning_system/base_entity_decorator/#src.model.learning_system.base_entity_decorator.BaseEntityDecorator.update_entities","title":"<code>update_entities(entities)</code>","text":"<p>Update the entities this wrapper uses internally.</p> <p>Parameters:</p> Name Type Description Default <code>entities</code> <code>TopLevelEntities</code> <p>The new entities used internally</p> required Source code in <code>src/model/learning_system/base_entity_decorator.py</code> <pre><code>def update_entities(self, entities: TopLevelEntities) -&gt; None:\n    \"\"\"Update the entities this wrapper uses internally.\n\n    Args:\n        entities (TopLevelEntities): The new entities used internally\n    \"\"\"\n    self.entities = entities\n</code></pre>"},{"location":"reference/model/learning_system/global_options/","title":"Global Options","text":""},{"location":"reference/model/learning_system/global_options/#src.model.learning_system.global_options.GlobalOptions","title":"<code>GlobalOptions</code>  <code>dataclass</code>","text":"<p>             Bases: <code>object</code></p> <p>Class represents the current options.</p> Source code in <code>src/model/learning_system/global_options.py</code> <pre><code>@dataclass(frozen=True)\nclass GlobalOptions(object):\n    \"\"\"Class represents the current options.\"\"\"\n\n    agent: AgentOptions\n    dynamics: DynamicsOptions\n    exploration_strategy: ExplorationStrategyOptions\n    display_mode: DisplayMode\n\n    def create_agent(self, dynamics: BaseDynamics) -&gt; BaseAgent:\n        \"\"\"Create the agent based upon these options.\n\n        Args:\n            dynamics (BaseDynamics): the dynamics that are used by the value\n                iteration agent.\n\n        Raises:\n            ValueError: if the agent specified is not known\n\n        Returns:\n            BaseAgent: the agent to instance. this agent is to be used with the\n            dynamics provided to avoid inconsistencies.\n        \"\"\"\n        agent_config = ConfigReader().agent()\n        match self.agent:\n            case AgentOptions.value_iteration:\n                return ValueIterationAgent(agent_config, dynamics)\n            case AgentOptions.value_iteration_optimised:\n                return ValueIterationAgentOptimised(agent_config, dynamics)\n            case AgentOptions.q_learning:\n                return QLearningAgent(\n                    agent_config,\n                    self.exploration_strategy,\n                )\n            case _:\n                raise ValueError(f\"unknown agent {self._agent_option.name}\")\n\n    def create_dynamics(self) -&gt; BaseDynamics:\n        \"\"\"Create the dynamics appropriate for these options.\n\n        Raises:\n            ValueError: if the dynamics option specified is unknown.\n\n        Returns:\n            BaseDynamics: the dynamics instance, the returned class will be a\n            concrete instance that extends `BaseDynamics`\n        \"\"\"\n        dynamic_config = ConfigReader().grid_world()\n        match self.dynamics:\n            case DynamicsOptions.collection:\n                return CollectionDynamics(dynamic_config)\n            case _:\n                raise ValueError(f\"unknown dynamics {self.dynamics.name}\")\n</code></pre>"},{"location":"reference/model/learning_system/global_options/#src.model.learning_system.global_options.GlobalOptions.create_agent","title":"<code>create_agent(dynamics)</code>","text":"<p>Create the agent based upon these options.</p> <p>Parameters:</p> Name Type Description Default <code>dynamics</code> <code>BaseDynamics</code> <p>the dynamics that are used by the value iteration agent.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>if the agent specified is not known</p> <p>Returns:</p> Name Type Description <code>BaseAgent</code> <code>BaseAgent</code> <p>the agent to instance. this agent is to be used with the</p> <code>BaseAgent</code> <p>dynamics provided to avoid inconsistencies.</p> Source code in <code>src/model/learning_system/global_options.py</code> <pre><code>def create_agent(self, dynamics: BaseDynamics) -&gt; BaseAgent:\n    \"\"\"Create the agent based upon these options.\n\n    Args:\n        dynamics (BaseDynamics): the dynamics that are used by the value\n            iteration agent.\n\n    Raises:\n        ValueError: if the agent specified is not known\n\n    Returns:\n        BaseAgent: the agent to instance. this agent is to be used with the\n        dynamics provided to avoid inconsistencies.\n    \"\"\"\n    agent_config = ConfigReader().agent()\n    match self.agent:\n        case AgentOptions.value_iteration:\n            return ValueIterationAgent(agent_config, dynamics)\n        case AgentOptions.value_iteration_optimised:\n            return ValueIterationAgentOptimised(agent_config, dynamics)\n        case AgentOptions.q_learning:\n            return QLearningAgent(\n                agent_config,\n                self.exploration_strategy,\n            )\n        case _:\n            raise ValueError(f\"unknown agent {self._agent_option.name}\")\n</code></pre>"},{"location":"reference/model/learning_system/global_options/#src.model.learning_system.global_options.GlobalOptions.create_dynamics","title":"<code>create_dynamics()</code>","text":"<p>Create the dynamics appropriate for these options.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if the dynamics option specified is unknown.</p> <p>Returns:</p> Name Type Description <code>BaseDynamics</code> <code>BaseDynamics</code> <p>the dynamics instance, the returned class will be a</p> <code>BaseDynamics</code> <p>concrete instance that extends <code>BaseDynamics</code></p> Source code in <code>src/model/learning_system/global_options.py</code> <pre><code>def create_dynamics(self) -&gt; BaseDynamics:\n    \"\"\"Create the dynamics appropriate for these options.\n\n    Raises:\n        ValueError: if the dynamics option specified is unknown.\n\n    Returns:\n        BaseDynamics: the dynamics instance, the returned class will be a\n        concrete instance that extends `BaseDynamics`\n    \"\"\"\n    dynamic_config = ConfigReader().grid_world()\n    match self.dynamics:\n        case DynamicsOptions.collection:\n            return CollectionDynamics(dynamic_config)\n        case _:\n            raise ValueError(f\"unknown dynamics {self.dynamics.name}\")\n</code></pre>"},{"location":"reference/model/learning_system/learning_instance/","title":"Learning Instance","text":""},{"location":"reference/model/learning_system/learning_instance/#src.model.learning_system.learning_instance.LearningInstance","title":"<code>LearningInstance</code>","text":"<p>             Bases: <code>BaseEntityDecorator</code></p> <p>An instance of an agent interacting with the environment.</p> Source code in <code>src/model/learning_system/learning_instance.py</code> <pre><code>class LearningInstance(BaseEntityDecorator):\n    \"\"\"An instance of an agent interacting with the environment.\"\"\"\n\n    def __init__(self, entities: TopLevelEntities) -&gt; None:\n        \"\"\"Create the learning instance.\n\n        Args:\n            entities (TopLevelEntities): the top level entities used in this\n                learning instance.\n        \"\"\"\n        super().__init__(entities)\n        self.update_entities(entities)\n\n    @override\n    def update_entities(self, entities: TopLevelEntities) -&gt; None:\n        \"\"\"Update the entities used by this decorator.\n\n        Args:\n            entities (TopLevelEntities): the new entities to use.\n        \"\"\"\n        super().update_entities(entities)\n        self._current_state: Optional[int] = None\n\n    def get_current_state(self) -&gt; int:\n        \"\"\"Get the current state ID.\n\n        Returns:\n            int: the current state ID\n        \"\"\"\n        if self._current_state is not None:\n            return self._current_state\n        self._current_state = self.dynamics.initial_state_id()\n        return self._current_state\n\n    def reset_state(self) -&gt; int:\n        \"\"\"Reset the current state to the initial state.\n\n        Returns:\n            int: the initial state id\n        \"\"\"\n        self._current_state = self.dynamics.initial_state_id()\n        return self._current_state\n\n    def perform_action(\n        self,\n    ) -&gt; Tuple[int, Action, int, float]:\n        \"\"\"Perform one action chosen by the agent.\n\n        Returns:\n            Tuple[int, Action, int, float]: the transition information, the last\n            state, the action chosen, the next state, the reward received for\n            this action.\n        \"\"\"\n        last_state = self.get_current_state()\n\n        action = self.agent.evaluate_policy(last_state)\n        next_state, reward = self.dynamics.next_state_id(last_state, action)\n        self.agent.record_transition(last_state, action, next_state, reward)\n        self._current_state = next_state\n        return (\n            last_state,\n            action,\n            next_state,\n            reward,\n        )\n</code></pre>"},{"location":"reference/model/learning_system/learning_instance/#src.model.learning_system.learning_instance.LearningInstance.__init__","title":"<code>__init__(entities)</code>","text":"<p>Create the learning instance.</p> <p>Parameters:</p> Name Type Description Default <code>entities</code> <code>TopLevelEntities</code> <p>the top level entities used in this learning instance.</p> required Source code in <code>src/model/learning_system/learning_instance.py</code> <pre><code>def __init__(self, entities: TopLevelEntities) -&gt; None:\n    \"\"\"Create the learning instance.\n\n    Args:\n        entities (TopLevelEntities): the top level entities used in this\n            learning instance.\n    \"\"\"\n    super().__init__(entities)\n    self.update_entities(entities)\n</code></pre>"},{"location":"reference/model/learning_system/learning_instance/#src.model.learning_system.learning_instance.LearningInstance.get_current_state","title":"<code>get_current_state()</code>","text":"<p>Get the current state ID.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>the current state ID</p> Source code in <code>src/model/learning_system/learning_instance.py</code> <pre><code>def get_current_state(self) -&gt; int:\n    \"\"\"Get the current state ID.\n\n    Returns:\n        int: the current state ID\n    \"\"\"\n    if self._current_state is not None:\n        return self._current_state\n    self._current_state = self.dynamics.initial_state_id()\n    return self._current_state\n</code></pre>"},{"location":"reference/model/learning_system/learning_instance/#src.model.learning_system.learning_instance.LearningInstance.perform_action","title":"<code>perform_action()</code>","text":"<p>Perform one action chosen by the agent.</p> <p>Returns:</p> Type Description <code>int</code> <p>Tuple[int, Action, int, float]: the transition information, the last</p> <code>Action</code> <p>state, the action chosen, the next state, the reward received for</p> <code>int</code> <p>this action.</p> Source code in <code>src/model/learning_system/learning_instance.py</code> <pre><code>def perform_action(\n    self,\n) -&gt; Tuple[int, Action, int, float]:\n    \"\"\"Perform one action chosen by the agent.\n\n    Returns:\n        Tuple[int, Action, int, float]: the transition information, the last\n        state, the action chosen, the next state, the reward received for\n        this action.\n    \"\"\"\n    last_state = self.get_current_state()\n\n    action = self.agent.evaluate_policy(last_state)\n    next_state, reward = self.dynamics.next_state_id(last_state, action)\n    self.agent.record_transition(last_state, action, next_state, reward)\n    self._current_state = next_state\n    return (\n        last_state,\n        action,\n        next_state,\n        reward,\n    )\n</code></pre>"},{"location":"reference/model/learning_system/learning_instance/#src.model.learning_system.learning_instance.LearningInstance.reset_state","title":"<code>reset_state()</code>","text":"<p>Reset the current state to the initial state.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>the initial state id</p> Source code in <code>src/model/learning_system/learning_instance.py</code> <pre><code>def reset_state(self) -&gt; int:\n    \"\"\"Reset the current state to the initial state.\n\n    Returns:\n        int: the initial state id\n    \"\"\"\n    self._current_state = self.dynamics.initial_state_id()\n    return self._current_state\n</code></pre>"},{"location":"reference/model/learning_system/learning_instance/#src.model.learning_system.learning_instance.LearningInstance.update_entities","title":"<code>update_entities(entities)</code>","text":"<p>Update the entities used by this decorator.</p> <p>Parameters:</p> Name Type Description Default <code>entities</code> <code>TopLevelEntities</code> <p>the new entities to use.</p> required Source code in <code>src/model/learning_system/learning_instance.py</code> <pre><code>@override\ndef update_entities(self, entities: TopLevelEntities) -&gt; None:\n    \"\"\"Update the entities used by this decorator.\n\n    Args:\n        entities (TopLevelEntities): the new entities to use.\n    \"\"\"\n    super().update_entities(entities)\n    self._current_state: Optional[int] = None\n</code></pre>"},{"location":"reference/model/learning_system/learning_system/","title":"Learning System","text":""},{"location":"reference/model/learning_system/learning_system/#src.model.learning_system.learning_system.LearningSystem","title":"<code>LearningSystem</code>","text":"<p>             Bases: <code>object</code></p> <p>Controller for managing one pair of agent and dynamics.</p> Source code in <code>src/model/learning_system/learning_system.py</code> <pre><code>class LearningSystem(object):\n    \"\"\"Controller for managing one pair of agent and dynamics.\"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Class for managing a complete learning system.\"\"\"\n        self.options = GlobalOptions(\n            AgentOptions.value_iteration_optimised,\n            DynamicsOptions.collection,\n            ExplorationStrategyOptions.not_applicable,\n            DisplayMode.default,\n        )\n        self.entities = TopLevelEntities.create_new_entities(self.options)\n        self.learning_instance = LearningInstance(self.entities)\n        self.state_description_factory = StateDescriptionFactory(self.entities)\n\n    def get_current_state(self) -&gt; StateDescription:\n        \"\"\"Get the current state of the learning instance.\n\n        Returns:\n            StateDescription: the current configuration for this state.\n        \"\"\"\n        state_id = self.learning_instance.get_current_state()\n        return self.state_description_factory.create_state_description(state_id)\n\n    def update_options(self, options: GlobalOptions):\n        \"\"\"Set the global options used by this system.\n\n        Args:\n            options (GlobalOptions): how to display the learning instance\n        \"\"\"\n        self.options = options\n        self.entities = self.entities.update_options(options)\n        self.learning_instance.update_entities(self.entities)\n        self.state_description_factory.update_entities(self.entities)\n\n    def reset_top_level(self):\n        \"\"\"Reset the toplevel entities. wipes all learning information.\"\"\"\n        self.entities = TopLevelEntities.create_new_entities(self.options)\n        self.learning_instance.update_entities(self.entities)\n        self.state_description_factory.update_entities(self.entities)\n</code></pre>"},{"location":"reference/model/learning_system/learning_system/#src.model.learning_system.learning_system.LearningSystem.__init__","title":"<code>__init__()</code>","text":"<p>Class for managing a complete learning system.</p> Source code in <code>src/model/learning_system/learning_system.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Class for managing a complete learning system.\"\"\"\n    self.options = GlobalOptions(\n        AgentOptions.value_iteration_optimised,\n        DynamicsOptions.collection,\n        ExplorationStrategyOptions.not_applicable,\n        DisplayMode.default,\n    )\n    self.entities = TopLevelEntities.create_new_entities(self.options)\n    self.learning_instance = LearningInstance(self.entities)\n    self.state_description_factory = StateDescriptionFactory(self.entities)\n</code></pre>"},{"location":"reference/model/learning_system/learning_system/#src.model.learning_system.learning_system.LearningSystem.get_current_state","title":"<code>get_current_state()</code>","text":"<p>Get the current state of the learning instance.</p> <p>Returns:</p> Name Type Description <code>StateDescription</code> <code>StateDescription</code> <p>the current configuration for this state.</p> Source code in <code>src/model/learning_system/learning_system.py</code> <pre><code>def get_current_state(self) -&gt; StateDescription:\n    \"\"\"Get the current state of the learning instance.\n\n    Returns:\n        StateDescription: the current configuration for this state.\n    \"\"\"\n    state_id = self.learning_instance.get_current_state()\n    return self.state_description_factory.create_state_description(state_id)\n</code></pre>"},{"location":"reference/model/learning_system/learning_system/#src.model.learning_system.learning_system.LearningSystem.reset_top_level","title":"<code>reset_top_level()</code>","text":"<p>Reset the toplevel entities. wipes all learning information.</p> Source code in <code>src/model/learning_system/learning_system.py</code> <pre><code>def reset_top_level(self):\n    \"\"\"Reset the toplevel entities. wipes all learning information.\"\"\"\n    self.entities = TopLevelEntities.create_new_entities(self.options)\n    self.learning_instance.update_entities(self.entities)\n    self.state_description_factory.update_entities(self.entities)\n</code></pre>"},{"location":"reference/model/learning_system/learning_system/#src.model.learning_system.learning_system.LearningSystem.update_options","title":"<code>update_options(options)</code>","text":"<p>Set the global options used by this system.</p> <p>Parameters:</p> Name Type Description Default <code>options</code> <code>GlobalOptions</code> <p>how to display the learning instance</p> required Source code in <code>src/model/learning_system/learning_system.py</code> <pre><code>def update_options(self, options: GlobalOptions):\n    \"\"\"Set the global options used by this system.\n\n    Args:\n        options (GlobalOptions): how to display the learning instance\n    \"\"\"\n    self.options = options\n    self.entities = self.entities.update_options(options)\n    self.learning_instance.update_entities(self.entities)\n    self.state_description_factory.update_entities(self.entities)\n</code></pre>"},{"location":"reference/model/learning_system/options/","title":"Options","text":""},{"location":"reference/model/learning_system/options/#src.model.learning_system.options.AgentOptions","title":"<code>AgentOptions</code>","text":"<p>             Bases: <code>Enum</code></p> <p>Enumerates the possible agents.</p> Source code in <code>src/model/learning_system/options.py</code> <pre><code>class AgentOptions(Enum):\n    \"\"\"Enumerates the possible agents.\"\"\"\n\n    value_iteration_optimised = 1\n    value_iteration = 2\n    q_learning = 3\n</code></pre>"},{"location":"reference/model/learning_system/options/#src.model.learning_system.options.DynamicsOptions","title":"<code>DynamicsOptions</code>","text":"<p>             Bases: <code>Enum</code></p> <p>Enumerates the possible agents.</p> Source code in <code>src/model/learning_system/options.py</code> <pre><code>class DynamicsOptions(Enum):\n    \"\"\"Enumerates the possible agents.\"\"\"\n\n    collection = 1\n</code></pre>"},{"location":"reference/model/learning_system/top_entities/","title":"Top Entities","text":""},{"location":"reference/model/learning_system/top_entities/#src.model.learning_system.top_entities.TopLevelEntities","title":"<code>TopLevelEntities</code>  <code>dataclass</code>","text":"<p>             Bases: <code>object</code></p> <p>Class that encompasses the top level entities of the learning system.</p> Source code in <code>src/model/learning_system/top_entities.py</code> <pre><code>@dataclass(frozen=True)\nclass TopLevelEntities(object):\n    \"\"\"Class that encompasses the top level entities of the learning system.\"\"\"\n\n    agent: BaseAgent\n    dynamics: BaseDynamics\n    options: GlobalOptions\n\n    @classmethod\n    def create_new_entities(cls, options: GlobalOptions) -&gt; Self:\n        \"\"\"Construct new top level entities from specified options.\n\n        Args:\n            options (GlobalOptions): the options that specify how the top level\n                entities should be.\n\n        Returns:\n            Self: the new top level entities\n        \"\"\"\n        dynamics = options.create_dynamics()\n        agent = options.create_agent(dynamics)\n        return cls(agent, dynamics, options)\n\n    def update_options(self, options: GlobalOptions) -&gt; \"TopLevelEntities\":\n        \"\"\"Construct new top level entities from specified options.\n\n        unlike create new entities, this method will reuse where possible.\n\n        Args:\n            options (GlobalOptions): the options that specify how the top level\n                entities should be.\n\n        Returns:\n            Self: the new top level entities.\n        \"\"\"\n        if options == self.options:\n            return self\n\n        if self.options.dynamics is not options.dynamics:\n            return self.create_new_entities(options)\n\n        if self.options.agent is not options.agent:\n            agent = options.create_agent(self.dynamics)\n            return TopLevelEntities(agent, self.dynamics, options)\n\n        return replace(self, options=options)\n</code></pre>"},{"location":"reference/model/learning_system/top_entities/#src.model.learning_system.top_entities.TopLevelEntities.create_new_entities","title":"<code>create_new_entities(options)</code>  <code>classmethod</code>","text":"<p>Construct new top level entities from specified options.</p> <p>Parameters:</p> Name Type Description Default <code>options</code> <code>GlobalOptions</code> <p>the options that specify how the top level entities should be.</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>the new top level entities</p> Source code in <code>src/model/learning_system/top_entities.py</code> <pre><code>@classmethod\ndef create_new_entities(cls, options: GlobalOptions) -&gt; Self:\n    \"\"\"Construct new top level entities from specified options.\n\n    Args:\n        options (GlobalOptions): the options that specify how the top level\n            entities should be.\n\n    Returns:\n        Self: the new top level entities\n    \"\"\"\n    dynamics = options.create_dynamics()\n    agent = options.create_agent(dynamics)\n    return cls(agent, dynamics, options)\n</code></pre>"},{"location":"reference/model/learning_system/top_entities/#src.model.learning_system.top_entities.TopLevelEntities.update_options","title":"<code>update_options(options)</code>","text":"<p>Construct new top level entities from specified options.</p> <p>unlike create new entities, this method will reuse where possible.</p> <p>Parameters:</p> Name Type Description Default <code>options</code> <code>GlobalOptions</code> <p>the options that specify how the top level entities should be.</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>TopLevelEntities</code> <p>the new top level entities.</p> Source code in <code>src/model/learning_system/top_entities.py</code> <pre><code>def update_options(self, options: GlobalOptions) -&gt; \"TopLevelEntities\":\n    \"\"\"Construct new top level entities from specified options.\n\n    unlike create new entities, this method will reuse where possible.\n\n    Args:\n        options (GlobalOptions): the options that specify how the top level\n            entities should be.\n\n    Returns:\n        Self: the new top level entities.\n    \"\"\"\n    if options == self.options:\n        return self\n\n    if self.options.dynamics is not options.dynamics:\n        return self.create_new_entities(options)\n\n    if self.options.agent is not options.agent:\n        agent = options.create_agent(self.dynamics)\n        return TopLevelEntities(agent, self.dynamics, options)\n\n    return replace(self, options=options)\n</code></pre>"},{"location":"reference/model/learning_system/cell_configuration/","title":"Cell Configuration","text":"<p>This package encapsulates all information about a state in one place.</p>"},{"location":"reference/model/learning_system/cell_configuration/cell_configuration/","title":"Cell Configuration","text":""},{"location":"reference/model/learning_system/cell_configuration/cell_configuration/#src.model.learning_system.cell_configuration.cell_configuration.CellConfiguration","title":"<code>CellConfiguration</code>  <code>dataclass</code>","text":"<p>             Bases: <code>object</code></p> <p>Class to represent the configuration of a cell in a given state.</p> Source code in <code>src/model/learning_system/cell_configuration/cell_configuration.py</code> <pre><code>@dataclass(frozen=True)\nclass CellConfiguration(object):\n    \"\"\"Class to represent the configuration of a cell in a given state.\"\"\"\n\n    action_values_normalised: action_value_description\n    action_values_raw: action_value_description\n    location: Tuple[int, int]\n    cell_entity: CellEntity\n    cell_value_normalised: Optional[float] = None\n    cell_value_raw: Optional[float] = None\n\n    @property\n    def tooltip_text(self) -&gt; str:\n        \"\"\"Gets the text for a tooltip on hovering over the cell.\n\n        Returns:\n            str: the text to display to the user for extra information\n        \"\"\"\n        text = f\"cell={self.location}\"\n        if self.cell_value_raw is not None:\n            text += f\"\\ncell value={self.cell_value_raw:.4f}\"\n\n        for action in Action:\n            action_value = self.action_values_raw[action]\n            if action_value is not None:\n                text += f\"\\n{action.name} value = {action_value:.4f}\"\n        return text\n</code></pre>"},{"location":"reference/model/learning_system/cell_configuration/cell_configuration/#src.model.learning_system.cell_configuration.cell_configuration.CellConfiguration.tooltip_text","title":"<code>tooltip_text: str</code>  <code>property</code>","text":"<p>Gets the text for a tooltip on hovering over the cell.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>the text to display to the user for extra information</p>"},{"location":"reference/model/learning_system/cell_configuration/cell_configuration/#src.model.learning_system.cell_configuration.cell_configuration.DisplayMode","title":"<code>DisplayMode</code>","text":"<p>             Bases: <code>Enum</code></p> <p>Enumerates the different possible display styles.</p> Source code in <code>src/model/learning_system/cell_configuration/cell_configuration.py</code> <pre><code>class DisplayMode(Enum):\n    \"\"\"Enumerates the different possible display styles.\"\"\"\n\n    default = 0\n    state_value = 1\n    action_value_global = 2\n    action_value_local = 3\n    best_action = 4\n</code></pre>"},{"location":"reference/model/learning_system/cell_configuration/cell_configuration_factory/","title":"Cell Configuration Factory","text":""},{"location":"reference/model/learning_system/cell_configuration/cell_configuration_factory/#src.model.learning_system.cell_configuration.cell_configuration_factory.CellConfigurationFactory","title":"<code>CellConfigurationFactory</code>","text":"<p>             Bases: <code>BaseEntityDecorator</code></p> <p>Factory for creating cell configurations.</p> Source code in <code>src/model/learning_system/cell_configuration/cell_configuration_factory.py</code> <pre><code>class CellConfigurationFactory(BaseEntityDecorator):\n    \"\"\"Factory for creating cell configurations.\"\"\"\n\n    def __init__(self, entities: TopLevelEntities) -&gt; None:\n        \"\"\"Initialise the state Description factory.\n\n        Args:\n            entities (TopLevelEntities): The entities the cell configuration is\n                based upon.\n        \"\"\"\n        super().__init__(entities)\n        self.update_entities(entities)\n\n    @override\n    def update_entities(self, entities: TopLevelEntities) -&gt; None:\n        \"\"\"Update the entities used by this decorator.\n\n        Args:\n            entities (TopLevelEntities): the new entities to use.\n        \"\"\"\n        super().update_entities(entities)\n        self.cell_state_lookup = CellStateLookup(entities.dynamics)\n        self.value_normalisation_factory = NormaliserFactory(\n            entities.agent,\n            entities.dynamics,\n            enable_cache=False,\n        )\n\n    def get_cell_configuration(\n        self, state_id: int\n    ) -&gt; Dict[integer_position, CellConfiguration]:\n        \"\"\"Get a state description for this state ID.\n\n        Args:\n            state_id (int): the state to represent in the view\n\n        Returns:\n            StateDescription: the state description\n        \"\"\"\n        normaliser = self.value_normalisation_factory.create_normaliser(\n            state_id\n        )\n        state = self.state_pool.get_state_from_id(state_id)\n        return {\n            cell: self.__cell_configuration(state, normaliser, cell)\n            for cell in self.entities.dynamics.grid_world.list_cells()\n        }\n\n    def __cell_configuration(\n        self,\n        reference_state: StateInstance,\n        normaliser: StateValueNormaliser,\n        cell: Tuple[int, int],\n    ) -&gt; CellConfiguration:\n        \"\"\"Get the configuration of a cell in a given state.\n\n        Args:\n            reference_state (StateInstance): the state that this cell is\n                compared against.\n            normaliser (StateValueNormaliser): normaliser to get value\n            cell (tuple[int, int]): the cell to check.\n\n        Returns:\n            CellConfiguration: the cell's configuration\n        \"\"\"\n        action_values_normalised: action_value_description = {}\n        action_values_raw: action_value_description = {}\n\n        cell_state = self.cell_state_lookup.get_state(reference_state, cell)\n\n        if cell_state is None:\n            for action in Action:\n                action_values_normalised[action] = None\n                action_values_raw[action] = None\n\n            return CellConfiguration(\n                action_values_normalised,\n                action_values_raw,\n                cell,\n                self.__cell_entity(reference_state, cell),\n            )\n\n        cell_state_id = self.state_pool.get_state_id(cell_state)\n        for action in Action:\n            action_values_normalised[\n                action\n            ] = normaliser.get_state_action_value_normalised(cell_state, action)\n            action_values_raw[action] = self.agent.get_state_action_value(\n                cell_state_id, action\n            )\n\n        return CellConfiguration(\n            action_values_normalised,\n            action_values_raw,\n            cell,\n            self.__cell_entity(reference_state, cell),\n            normaliser.get_state_value_normalised(cell_state),\n            self.agent.get_state_value(cell_state_id),\n        )\n\n    def __cell_entity(\n        self, state: StateInstance, cell: tuple[int, int]\n    ) -&gt; CellEntity:\n        \"\"\"Get the cell entity at a given location.\n\n        Args:\n            state (StateInstance): the state the cell is in.\n            cell (tuple[int, int]): the location of the cell to check.\n\n        Raises:\n            ValueError: if the cell is not a valid location\n\n        Returns:\n            CellEntity: the cell entity at this location\n        \"\"\"\n        if not self.grid_world.is_in_bounds(cell):\n            raise ValueError(f\"location {cell} is not in bounds\")\n\n        if cell == state.agent_location:\n            return CellEntity.agent\n\n        return state.entities.get(cell, CellEntity.empty)\n</code></pre>"},{"location":"reference/model/learning_system/cell_configuration/cell_configuration_factory/#src.model.learning_system.cell_configuration.cell_configuration_factory.CellConfigurationFactory.__cell_configuration","title":"<code>__cell_configuration(reference_state, normaliser, cell)</code>","text":"<p>Get the configuration of a cell in a given state.</p> <p>Parameters:</p> Name Type Description Default <code>reference_state</code> <code>StateInstance</code> <p>the state that this cell is compared against.</p> required <code>normaliser</code> <code>StateValueNormaliser</code> <p>normaliser to get value</p> required <code>cell</code> <code>tuple[int, int]</code> <p>the cell to check.</p> required <p>Returns:</p> Name Type Description <code>CellConfiguration</code> <code>CellConfiguration</code> <p>the cell's configuration</p> Source code in <code>src/model/learning_system/cell_configuration/cell_configuration_factory.py</code> <pre><code>def __cell_configuration(\n    self,\n    reference_state: StateInstance,\n    normaliser: StateValueNormaliser,\n    cell: Tuple[int, int],\n) -&gt; CellConfiguration:\n    \"\"\"Get the configuration of a cell in a given state.\n\n    Args:\n        reference_state (StateInstance): the state that this cell is\n            compared against.\n        normaliser (StateValueNormaliser): normaliser to get value\n        cell (tuple[int, int]): the cell to check.\n\n    Returns:\n        CellConfiguration: the cell's configuration\n    \"\"\"\n    action_values_normalised: action_value_description = {}\n    action_values_raw: action_value_description = {}\n\n    cell_state = self.cell_state_lookup.get_state(reference_state, cell)\n\n    if cell_state is None:\n        for action in Action:\n            action_values_normalised[action] = None\n            action_values_raw[action] = None\n\n        return CellConfiguration(\n            action_values_normalised,\n            action_values_raw,\n            cell,\n            self.__cell_entity(reference_state, cell),\n        )\n\n    cell_state_id = self.state_pool.get_state_id(cell_state)\n    for action in Action:\n        action_values_normalised[\n            action\n        ] = normaliser.get_state_action_value_normalised(cell_state, action)\n        action_values_raw[action] = self.agent.get_state_action_value(\n            cell_state_id, action\n        )\n\n    return CellConfiguration(\n        action_values_normalised,\n        action_values_raw,\n        cell,\n        self.__cell_entity(reference_state, cell),\n        normaliser.get_state_value_normalised(cell_state),\n        self.agent.get_state_value(cell_state_id),\n    )\n</code></pre>"},{"location":"reference/model/learning_system/cell_configuration/cell_configuration_factory/#src.model.learning_system.cell_configuration.cell_configuration_factory.CellConfigurationFactory.__cell_entity","title":"<code>__cell_entity(state, cell)</code>","text":"<p>Get the cell entity at a given location.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>StateInstance</code> <p>the state the cell is in.</p> required <code>cell</code> <code>tuple[int, int]</code> <p>the location of the cell to check.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>if the cell is not a valid location</p> <p>Returns:</p> Name Type Description <code>CellEntity</code> <code>CellEntity</code> <p>the cell entity at this location</p> Source code in <code>src/model/learning_system/cell_configuration/cell_configuration_factory.py</code> <pre><code>def __cell_entity(\n    self, state: StateInstance, cell: tuple[int, int]\n) -&gt; CellEntity:\n    \"\"\"Get the cell entity at a given location.\n\n    Args:\n        state (StateInstance): the state the cell is in.\n        cell (tuple[int, int]): the location of the cell to check.\n\n    Raises:\n        ValueError: if the cell is not a valid location\n\n    Returns:\n        CellEntity: the cell entity at this location\n    \"\"\"\n    if not self.grid_world.is_in_bounds(cell):\n        raise ValueError(f\"location {cell} is not in bounds\")\n\n    if cell == state.agent_location:\n        return CellEntity.agent\n\n    return state.entities.get(cell, CellEntity.empty)\n</code></pre>"},{"location":"reference/model/learning_system/cell_configuration/cell_configuration_factory/#src.model.learning_system.cell_configuration.cell_configuration_factory.CellConfigurationFactory.__init__","title":"<code>__init__(entities)</code>","text":"<p>Initialise the state Description factory.</p> <p>Parameters:</p> Name Type Description Default <code>entities</code> <code>TopLevelEntities</code> <p>The entities the cell configuration is based upon.</p> required Source code in <code>src/model/learning_system/cell_configuration/cell_configuration_factory.py</code> <pre><code>def __init__(self, entities: TopLevelEntities) -&gt; None:\n    \"\"\"Initialise the state Description factory.\n\n    Args:\n        entities (TopLevelEntities): The entities the cell configuration is\n            based upon.\n    \"\"\"\n    super().__init__(entities)\n    self.update_entities(entities)\n</code></pre>"},{"location":"reference/model/learning_system/cell_configuration/cell_configuration_factory/#src.model.learning_system.cell_configuration.cell_configuration_factory.CellConfigurationFactory.get_cell_configuration","title":"<code>get_cell_configuration(state_id)</code>","text":"<p>Get a state description for this state ID.</p> <p>Parameters:</p> Name Type Description Default <code>state_id</code> <code>int</code> <p>the state to represent in the view</p> required <p>Returns:</p> Name Type Description <code>StateDescription</code> <code>Dict[integer_position, CellConfiguration]</code> <p>the state description</p> Source code in <code>src/model/learning_system/cell_configuration/cell_configuration_factory.py</code> <pre><code>def get_cell_configuration(\n    self, state_id: int\n) -&gt; Dict[integer_position, CellConfiguration]:\n    \"\"\"Get a state description for this state ID.\n\n    Args:\n        state_id (int): the state to represent in the view\n\n    Returns:\n        StateDescription: the state description\n    \"\"\"\n    normaliser = self.value_normalisation_factory.create_normaliser(\n        state_id\n    )\n    state = self.state_pool.get_state_from_id(state_id)\n    return {\n        cell: self.__cell_configuration(state, normaliser, cell)\n        for cell in self.entities.dynamics.grid_world.list_cells()\n    }\n</code></pre>"},{"location":"reference/model/learning_system/cell_configuration/cell_configuration_factory/#src.model.learning_system.cell_configuration.cell_configuration_factory.CellConfigurationFactory.update_entities","title":"<code>update_entities(entities)</code>","text":"<p>Update the entities used by this decorator.</p> <p>Parameters:</p> Name Type Description Default <code>entities</code> <code>TopLevelEntities</code> <p>the new entities to use.</p> required Source code in <code>src/model/learning_system/cell_configuration/cell_configuration_factory.py</code> <pre><code>@override\ndef update_entities(self, entities: TopLevelEntities) -&gt; None:\n    \"\"\"Update the entities used by this decorator.\n\n    Args:\n        entities (TopLevelEntities): the new entities to use.\n    \"\"\"\n    super().update_entities(entities)\n    self.cell_state_lookup = CellStateLookup(entities.dynamics)\n    self.value_normalisation_factory = NormaliserFactory(\n        entities.agent,\n        entities.dynamics,\n        enable_cache=False,\n    )\n</code></pre>"},{"location":"reference/model/learning_system/cell_configuration/cell_state_lookup/","title":"Cell State Lookup","text":""},{"location":"reference/model/learning_system/cell_configuration/cell_state_lookup/#src.model.learning_system.cell_configuration.cell_state_lookup.CellStateLookup","title":"<code>CellStateLookup</code>","text":"<p>             Bases: <code>object</code></p> <p>This class represents lookup tables for mapping cells to states.</p> Source code in <code>src/model/learning_system/cell_configuration/cell_state_lookup.py</code> <pre><code>class CellStateLookup(object):\n    \"\"\"This class represents lookup tables for mapping cells to states.\"\"\"\n\n    def __init__(self, dynamics: BaseDynamics) -&gt; None:\n        \"\"\"Initialise the class.\n\n        Args:\n            dynamics (BaseDynamics): the dynamics this lookup is based upon.\n        \"\"\"\n        self.dynamics = dynamics\n        self.cell_lookup_table: Optional[lookup_table_type] = None\n\n    def get_state(\n        self, reference_state: StateInstance, cell: Tuple[int, int]\n    ) -&gt; Optional[StateInstance]:\n        \"\"\"Get a state with an agent in a given cell based on the reference.\n\n        Args:\n            reference_state (StateInstance): the base state to compare with\n            cell (Tuple[int, int]): the cell the agent should be in.\n\n        Returns:\n            Optional[StateInstance]: returns the relevant state if one exists.\n        \"\"\"\n        if self.cell_lookup_table is None:\n            self.cell_lookup_table = self.build_lookup_table()\n\n        cell_x, cell_y = cell\n        key = (cell_x, cell_y, reference_state.entities)\n        return self.cell_lookup_table.get(key, None)\n\n    def build_lookup_table(self) -&gt; lookup_table_type:\n        \"\"\"Populate the lookup table.\n\n        Returns:\n            lookup_table_type: the populated lookup table.\n        \"\"\"\n        self.cell_lookup_table = {}\n        for state in self.dynamics.state_pool.id_to_state.values():\n            location_x, location_y = state.agent_location\n            key = (location_x, location_y, state.entities)\n            existing = self.cell_lookup_table.get(key, None)\n            if existing is None or existing.agent_energy &lt; state.agent_energy:\n                self.cell_lookup_table[key] = state\n\n        return self.cell_lookup_table\n</code></pre>"},{"location":"reference/model/learning_system/cell_configuration/cell_state_lookup/#src.model.learning_system.cell_configuration.cell_state_lookup.CellStateLookup.__init__","title":"<code>__init__(dynamics)</code>","text":"<p>Initialise the class.</p> <p>Parameters:</p> Name Type Description Default <code>dynamics</code> <code>BaseDynamics</code> <p>the dynamics this lookup is based upon.</p> required Source code in <code>src/model/learning_system/cell_configuration/cell_state_lookup.py</code> <pre><code>def __init__(self, dynamics: BaseDynamics) -&gt; None:\n    \"\"\"Initialise the class.\n\n    Args:\n        dynamics (BaseDynamics): the dynamics this lookup is based upon.\n    \"\"\"\n    self.dynamics = dynamics\n    self.cell_lookup_table: Optional[lookup_table_type] = None\n</code></pre>"},{"location":"reference/model/learning_system/cell_configuration/cell_state_lookup/#src.model.learning_system.cell_configuration.cell_state_lookup.CellStateLookup.build_lookup_table","title":"<code>build_lookup_table()</code>","text":"<p>Populate the lookup table.</p> <p>Returns:</p> Name Type Description <code>lookup_table_type</code> <code>lookup_table_type</code> <p>the populated lookup table.</p> Source code in <code>src/model/learning_system/cell_configuration/cell_state_lookup.py</code> <pre><code>def build_lookup_table(self) -&gt; lookup_table_type:\n    \"\"\"Populate the lookup table.\n\n    Returns:\n        lookup_table_type: the populated lookup table.\n    \"\"\"\n    self.cell_lookup_table = {}\n    for state in self.dynamics.state_pool.id_to_state.values():\n        location_x, location_y = state.agent_location\n        key = (location_x, location_y, state.entities)\n        existing = self.cell_lookup_table.get(key, None)\n        if existing is None or existing.agent_energy &lt; state.agent_energy:\n            self.cell_lookup_table[key] = state\n\n    return self.cell_lookup_table\n</code></pre>"},{"location":"reference/model/learning_system/cell_configuration/cell_state_lookup/#src.model.learning_system.cell_configuration.cell_state_lookup.CellStateLookup.get_state","title":"<code>get_state(reference_state, cell)</code>","text":"<p>Get a state with an agent in a given cell based on the reference.</p> <p>Parameters:</p> Name Type Description Default <code>reference_state</code> <code>StateInstance</code> <p>the base state to compare with</p> required <code>cell</code> <code>Tuple[int, int]</code> <p>the cell the agent should be in.</p> required <p>Returns:</p> Type Description <code>Optional[StateInstance]</code> <p>Optional[StateInstance]: returns the relevant state if one exists.</p> Source code in <code>src/model/learning_system/cell_configuration/cell_state_lookup.py</code> <pre><code>def get_state(\n    self, reference_state: StateInstance, cell: Tuple[int, int]\n) -&gt; Optional[StateInstance]:\n    \"\"\"Get a state with an agent in a given cell based on the reference.\n\n    Args:\n        reference_state (StateInstance): the base state to compare with\n        cell (Tuple[int, int]): the cell the agent should be in.\n\n    Returns:\n        Optional[StateInstance]: returns the relevant state if one exists.\n    \"\"\"\n    if self.cell_lookup_table is None:\n        self.cell_lookup_table = self.build_lookup_table()\n\n    cell_x, cell_y = cell\n    key = (cell_x, cell_y, reference_state.entities)\n    return self.cell_lookup_table.get(key, None)\n</code></pre>"},{"location":"reference/model/learning_system/state_description/","title":"State Description","text":"<p>This package contains functionality around representing a state.</p> <p>This representation is necessary for the view so the format must be serialisable</p>"},{"location":"reference/model/learning_system/state_description/state_description/","title":"State Description","text":""},{"location":"reference/model/learning_system/state_description/state_description/#src.model.learning_system.state_description.state_description.StateDescription","title":"<code>StateDescription</code>  <code>dataclass</code>","text":"<p>             Bases: <code>object</code></p> <p>Compile together the dynamic static state information.</p> <p>Provides all of the state information in a picklable object for the view.</p> Source code in <code>src/model/learning_system/state_description/state_description.py</code> <pre><code>@dataclass\nclass StateDescription(object):\n    \"\"\"Compile together the dynamic static state information.\n\n    Provides all of the state information in a picklable object for the view.\n    \"\"\"\n\n    grid_world: GridWorld\n    state: StateInstance\n    cell_config: cell_config_listing\n    global_options: GlobalOptions\n</code></pre>"},{"location":"reference/model/learning_system/state_description/state_description_factory/","title":"State Description Factory","text":""},{"location":"reference/model/learning_system/state_description/state_description_factory/#src.model.learning_system.state_description.state_description_factory.StateDescriptionFactory","title":"<code>StateDescriptionFactory</code>","text":"<p>             Bases: <code>BaseEntityDecorator</code></p> <p>Factory class for creating state descriptions from states.</p> Source code in <code>src/model/learning_system/state_description/state_description_factory.py</code> <pre><code>class StateDescriptionFactory(BaseEntityDecorator):\n    \"\"\"Factory class for creating state descriptions from states.\"\"\"\n\n    def __init__(self, entities: TopLevelEntities) -&gt; None:\n        \"\"\"Create a state description factory for these entities.\n\n        Args:\n            entities (TopLevelEntities): The entities this class uses\n                internally.\n        \"\"\"\n        super().__init__(entities)\n        self.cell_configuration_factory = CellConfigurationFactory(entities)\n\n    @override\n    def update_entities(self, entities: TopLevelEntities) -&gt; None:\n        \"\"\"Update the entities used by this decorator.\n\n        Args:\n            entities (TopLevelEntities): the new entities to use.\n        \"\"\"\n        super().update_entities(entities)\n        self.cell_configuration_factory.update_entities(entities)\n\n    def create_state_description(self, state_id: int) -&gt; StateDescription:\n        \"\"\"Create a new state description from a given state ID.\n\n        Args:\n            state_id (int): the state to describe for the UI.\n\n        Returns:\n            StateDescription: All of the details of the state for the UI.\n        \"\"\"\n        return StateDescription(\n            self.grid_world,\n            self.state_pool.get_state_from_id(state_id),\n            self.cell_configuration_factory.get_cell_configuration(state_id),\n            self.options,\n        )\n</code></pre>"},{"location":"reference/model/learning_system/state_description/state_description_factory/#src.model.learning_system.state_description.state_description_factory.StateDescriptionFactory.__init__","title":"<code>__init__(entities)</code>","text":"<p>Create a state description factory for these entities.</p> <p>Parameters:</p> Name Type Description Default <code>entities</code> <code>TopLevelEntities</code> <p>The entities this class uses internally.</p> required Source code in <code>src/model/learning_system/state_description/state_description_factory.py</code> <pre><code>def __init__(self, entities: TopLevelEntities) -&gt; None:\n    \"\"\"Create a state description factory for these entities.\n\n    Args:\n        entities (TopLevelEntities): The entities this class uses\n            internally.\n    \"\"\"\n    super().__init__(entities)\n    self.cell_configuration_factory = CellConfigurationFactory(entities)\n</code></pre>"},{"location":"reference/model/learning_system/state_description/state_description_factory/#src.model.learning_system.state_description.state_description_factory.StateDescriptionFactory.create_state_description","title":"<code>create_state_description(state_id)</code>","text":"<p>Create a new state description from a given state ID.</p> <p>Parameters:</p> Name Type Description Default <code>state_id</code> <code>int</code> <p>the state to describe for the UI.</p> required <p>Returns:</p> Name Type Description <code>StateDescription</code> <code>StateDescription</code> <p>All of the details of the state for the UI.</p> Source code in <code>src/model/learning_system/state_description/state_description_factory.py</code> <pre><code>def create_state_description(self, state_id: int) -&gt; StateDescription:\n    \"\"\"Create a new state description from a given state ID.\n\n    Args:\n        state_id (int): the state to describe for the UI.\n\n    Returns:\n        StateDescription: All of the details of the state for the UI.\n    \"\"\"\n    return StateDescription(\n        self.grid_world,\n        self.state_pool.get_state_from_id(state_id),\n        self.cell_configuration_factory.get_cell_configuration(state_id),\n        self.options,\n    )\n</code></pre>"},{"location":"reference/model/learning_system/state_description/state_description_factory/#src.model.learning_system.state_description.state_description_factory.StateDescriptionFactory.update_entities","title":"<code>update_entities(entities)</code>","text":"<p>Update the entities used by this decorator.</p> <p>Parameters:</p> Name Type Description Default <code>entities</code> <code>TopLevelEntities</code> <p>the new entities to use.</p> required Source code in <code>src/model/learning_system/state_description/state_description_factory.py</code> <pre><code>@override\ndef update_entities(self, entities: TopLevelEntities) -&gt; None:\n    \"\"\"Update the entities used by this decorator.\n\n    Args:\n        entities (TopLevelEntities): the new entities to use.\n    \"\"\"\n    super().update_entities(entities)\n    self.cell_configuration_factory.update_entities(entities)\n</code></pre>"},{"location":"reference/model/learning_system/value_standardisation/","title":"Value Standardisation","text":"<p>Package for managing the value at different states for visualisation.</p>"},{"location":"reference/model/learning_system/value_standardisation/normaliser/","title":"Normaliser","text":""},{"location":"reference/model/learning_system/value_standardisation/normaliser/#src.model.learning_system.value_standardisation.normaliser.StateValueNormaliser","title":"<code>StateValueNormaliser</code>","text":"<p>             Bases: <code>object</code></p> <p>Compute the normalised value of an agent being in a state.</p> Source code in <code>src/model/learning_system/value_standardisation/normaliser.py</code> <pre><code>class StateValueNormaliser(object):\n    \"\"\"Compute the normalised value of an agent being in a state.\"\"\"\n\n    def __init__(\n        self,\n        agent: BaseAgent,\n        state_pool: StatePool,\n        value_range: ValueRange,\n    ) -&gt; None:\n        \"\"\"Initialise the normaliser.\n\n        this class will normalise the values between 0 and 1.\n\n\n        Args:\n            agent (BaseAgent): the agent to decide the value.\n            state_pool (StatePool): a state pool with all possible states.\n            value_range (ValueRange): the range of possible values for this\n                agent and dynamics\n        \"\"\"\n        self.agent = agent\n        self.state_pool = state_pool\n        self.value_range = value_range\n        self.state_value_cache: Dict[StateInstance, float] = {}\n        self.action_value_cache: Dict[action_value_tuple, float] = {}\n\n    def get_state_action_value_normalised(\n        self,\n        state: StateInstance,\n        action: Action,\n    ) -&gt; float:\n        \"\"\"Get the normalised value of a state and action.\n\n        Args:\n            state (StateInstance): the state to check.\n            action (Action): the action to check.\n\n        Returns:\n            float: the value if one can be found.\n        \"\"\"\n        cache_key = (state, action)\n        cached_value = self.action_value_cache.get(cache_key, None)\n        if cached_value is not None:\n            return cached_value\n\n        action_value = self.value_range.rescale_value(\n            ValueType.state_action_value,\n            self.agent.get_state_action_value(\n                self.state_pool.get_state_id(state), action\n            ),\n        )\n        self.action_value_cache[cache_key] = action_value\n        return action_value\n\n    def get_state_value_normalised(self, state: StateInstance) -&gt; float:\n        \"\"\"Get the normalised value of this state.\n\n        Args:\n            state (StateInstance): the state to check.\n\n        Returns:\n            float: the value of the state normalised.\n        \"\"\"\n        cached_value = self.state_value_cache.get(state, None)\n        if cached_value is not None:\n            return cached_value\n\n        state_value = self.value_range.rescale_value(\n            ValueType.state_value,\n            self.agent.get_state_value(self.state_pool.get_state_id(state)),\n        )\n        self.state_value_cache[state] = state_value\n\n        return state_value\n</code></pre>"},{"location":"reference/model/learning_system/value_standardisation/normaliser/#src.model.learning_system.value_standardisation.normaliser.StateValueNormaliser.__init__","title":"<code>__init__(agent, state_pool, value_range)</code>","text":"<p>Initialise the normaliser.</p> <p>this class will normalise the values between 0 and 1.</p> <p>Parameters:</p> Name Type Description Default <code>agent</code> <code>BaseAgent</code> <p>the agent to decide the value.</p> required <code>state_pool</code> <code>StatePool</code> <p>a state pool with all possible states.</p> required <code>value_range</code> <code>ValueRange</code> <p>the range of possible values for this agent and dynamics</p> required Source code in <code>src/model/learning_system/value_standardisation/normaliser.py</code> <pre><code>def __init__(\n    self,\n    agent: BaseAgent,\n    state_pool: StatePool,\n    value_range: ValueRange,\n) -&gt; None:\n    \"\"\"Initialise the normaliser.\n\n    this class will normalise the values between 0 and 1.\n\n\n    Args:\n        agent (BaseAgent): the agent to decide the value.\n        state_pool (StatePool): a state pool with all possible states.\n        value_range (ValueRange): the range of possible values for this\n            agent and dynamics\n    \"\"\"\n    self.agent = agent\n    self.state_pool = state_pool\n    self.value_range = value_range\n    self.state_value_cache: Dict[StateInstance, float] = {}\n    self.action_value_cache: Dict[action_value_tuple, float] = {}\n</code></pre>"},{"location":"reference/model/learning_system/value_standardisation/normaliser/#src.model.learning_system.value_standardisation.normaliser.StateValueNormaliser.get_state_action_value_normalised","title":"<code>get_state_action_value_normalised(state, action)</code>","text":"<p>Get the normalised value of a state and action.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>StateInstance</code> <p>the state to check.</p> required <code>action</code> <code>Action</code> <p>the action to check.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the value if one can be found.</p> Source code in <code>src/model/learning_system/value_standardisation/normaliser.py</code> <pre><code>def get_state_action_value_normalised(\n    self,\n    state: StateInstance,\n    action: Action,\n) -&gt; float:\n    \"\"\"Get the normalised value of a state and action.\n\n    Args:\n        state (StateInstance): the state to check.\n        action (Action): the action to check.\n\n    Returns:\n        float: the value if one can be found.\n    \"\"\"\n    cache_key = (state, action)\n    cached_value = self.action_value_cache.get(cache_key, None)\n    if cached_value is not None:\n        return cached_value\n\n    action_value = self.value_range.rescale_value(\n        ValueType.state_action_value,\n        self.agent.get_state_action_value(\n            self.state_pool.get_state_id(state), action\n        ),\n    )\n    self.action_value_cache[cache_key] = action_value\n    return action_value\n</code></pre>"},{"location":"reference/model/learning_system/value_standardisation/normaliser/#src.model.learning_system.value_standardisation.normaliser.StateValueNormaliser.get_state_value_normalised","title":"<code>get_state_value_normalised(state)</code>","text":"<p>Get the normalised value of this state.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>StateInstance</code> <p>the state to check.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the value of the state normalised.</p> Source code in <code>src/model/learning_system/value_standardisation/normaliser.py</code> <pre><code>def get_state_value_normalised(self, state: StateInstance) -&gt; float:\n    \"\"\"Get the normalised value of this state.\n\n    Args:\n        state (StateInstance): the state to check.\n\n    Returns:\n        float: the value of the state normalised.\n    \"\"\"\n    cached_value = self.state_value_cache.get(state, None)\n    if cached_value is not None:\n        return cached_value\n\n    state_value = self.value_range.rescale_value(\n        ValueType.state_value,\n        self.agent.get_state_value(self.state_pool.get_state_id(state)),\n    )\n    self.state_value_cache[state] = state_value\n\n    return state_value\n</code></pre>"},{"location":"reference/model/learning_system/value_standardisation/normaliser_factory/","title":"Normaliser Factory","text":""},{"location":"reference/model/learning_system/value_standardisation/normaliser_factory/#src.model.learning_system.value_standardisation.normaliser_factory.NormaliserFactory","title":"<code>NormaliserFactory</code>","text":"<p>             Bases: <code>object</code></p> <p>Factory class for creating value normalisers.</p> Source code in <code>src/model/learning_system/value_standardisation/normaliser_factory.py</code> <pre><code>class NormaliserFactory(object):\n    \"\"\"Factory class for creating value normalisers.\"\"\"\n\n    def __init__(\n        self, agent: BaseAgent, dynamics: BaseDynamics, enable_cache: bool\n    ) -&gt; None:\n        \"\"\"Initialise the normaliser factory.\n\n        This factory creates normalisers and caches equivalent ones to avoid\n        re-computation\n\n        Args:\n            agent (BaseAgent): the agent to generate normalisers for\n            dynamics (BaseDynamics): the dynamics to generate normalisers for\n            enable_cache: weather the cache can be enabled (if the value table\n                changes like for q-learning then caching must be disabled)\n        \"\"\"\n        self.agent = agent\n        self.dynamics = dynamics\n        self.has_generated_all_states: bool = False\n        self.cache: Dict[entities_type, StateValueNormaliser] = {}\n        self.value_range: Optional[ValueRange] = None\n        self.enable_cache = enable_cache\n\n    def create_normaliser(self, base_state: int) -&gt; StateValueNormaliser:\n        \"\"\"Get the appropriate state normaliser for the given base state.\n\n        Args:\n            base_state (int): the state the defines the possible entities that\n                the normaliser should consider.\n\n        Returns:\n            StateValueNormaliser: _description_\n        \"\"\"\n        entities = self.dynamics.state_pool.get_state_from_id(\n            base_state\n        ).entities\n\n        if self.enable_cache:\n            cached_version = self.cache.get(entities, None)\n            if cached_version is not None:\n                return cached_version\n\n        normaliser = StateValueNormaliser(\n            self.agent,\n            self.__get_state_pool(),\n            self.__get_value_range(),\n        )\n        self.cache[entities] = normaliser\n        return normaliser\n\n    def __get_state_pool(self) -&gt; StatePool:\n        \"\"\"Get a fully populated state pool.\n\n        Returns:\n            StatePool: the pool of all possible reachable states\n        \"\"\"\n        if self.has_generated_all_states:\n            return self.dynamics.state_pool\n        # use the dynamics distribution code to ensure all states are visited\n        dd = DynamicsDistribution(100, self.dynamics)\n        dd.compile()\n        self.has_generated_all_states = True\n        return self.dynamics.state_pool\n\n    def __get_value_range(self) -&gt; ValueRange:\n        \"\"\"Get the value range for this given dynamics and agent.\n\n        Returns:\n            ValueRange: the range of values to provide a consistent scale\n        \"\"\"\n        if self.value_range is not None and self.enable_cache:\n            return self.value_range\n\n        self.value_range = ValueRange(self.__get_state_pool(), self.agent)\n        return self.value_range\n</code></pre>"},{"location":"reference/model/learning_system/value_standardisation/normaliser_factory/#src.model.learning_system.value_standardisation.normaliser_factory.NormaliserFactory.__get_state_pool","title":"<code>__get_state_pool()</code>","text":"<p>Get a fully populated state pool.</p> <p>Returns:</p> Name Type Description <code>StatePool</code> <code>StatePool</code> <p>the pool of all possible reachable states</p> Source code in <code>src/model/learning_system/value_standardisation/normaliser_factory.py</code> <pre><code>def __get_state_pool(self) -&gt; StatePool:\n    \"\"\"Get a fully populated state pool.\n\n    Returns:\n        StatePool: the pool of all possible reachable states\n    \"\"\"\n    if self.has_generated_all_states:\n        return self.dynamics.state_pool\n    # use the dynamics distribution code to ensure all states are visited\n    dd = DynamicsDistribution(100, self.dynamics)\n    dd.compile()\n    self.has_generated_all_states = True\n    return self.dynamics.state_pool\n</code></pre>"},{"location":"reference/model/learning_system/value_standardisation/normaliser_factory/#src.model.learning_system.value_standardisation.normaliser_factory.NormaliserFactory.__get_value_range","title":"<code>__get_value_range()</code>","text":"<p>Get the value range for this given dynamics and agent.</p> <p>Returns:</p> Name Type Description <code>ValueRange</code> <code>ValueRange</code> <p>the range of values to provide a consistent scale</p> Source code in <code>src/model/learning_system/value_standardisation/normaliser_factory.py</code> <pre><code>def __get_value_range(self) -&gt; ValueRange:\n    \"\"\"Get the value range for this given dynamics and agent.\n\n    Returns:\n        ValueRange: the range of values to provide a consistent scale\n    \"\"\"\n    if self.value_range is not None and self.enable_cache:\n        return self.value_range\n\n    self.value_range = ValueRange(self.__get_state_pool(), self.agent)\n    return self.value_range\n</code></pre>"},{"location":"reference/model/learning_system/value_standardisation/normaliser_factory/#src.model.learning_system.value_standardisation.normaliser_factory.NormaliserFactory.__init__","title":"<code>__init__(agent, dynamics, enable_cache)</code>","text":"<p>Initialise the normaliser factory.</p> <p>This factory creates normalisers and caches equivalent ones to avoid re-computation</p> <p>Parameters:</p> Name Type Description Default <code>agent</code> <code>BaseAgent</code> <p>the agent to generate normalisers for</p> required <code>dynamics</code> <code>BaseDynamics</code> <p>the dynamics to generate normalisers for</p> required <code>enable_cache</code> <code>bool</code> <p>weather the cache can be enabled (if the value table changes like for q-learning then caching must be disabled)</p> required Source code in <code>src/model/learning_system/value_standardisation/normaliser_factory.py</code> <pre><code>def __init__(\n    self, agent: BaseAgent, dynamics: BaseDynamics, enable_cache: bool\n) -&gt; None:\n    \"\"\"Initialise the normaliser factory.\n\n    This factory creates normalisers and caches equivalent ones to avoid\n    re-computation\n\n    Args:\n        agent (BaseAgent): the agent to generate normalisers for\n        dynamics (BaseDynamics): the dynamics to generate normalisers for\n        enable_cache: weather the cache can be enabled (if the value table\n            changes like for q-learning then caching must be disabled)\n    \"\"\"\n    self.agent = agent\n    self.dynamics = dynamics\n    self.has_generated_all_states: bool = False\n    self.cache: Dict[entities_type, StateValueNormaliser] = {}\n    self.value_range: Optional[ValueRange] = None\n    self.enable_cache = enable_cache\n</code></pre>"},{"location":"reference/model/learning_system/value_standardisation/normaliser_factory/#src.model.learning_system.value_standardisation.normaliser_factory.NormaliserFactory.create_normaliser","title":"<code>create_normaliser(base_state)</code>","text":"<p>Get the appropriate state normaliser for the given base state.</p> <p>Parameters:</p> Name Type Description Default <code>base_state</code> <code>int</code> <p>the state the defines the possible entities that the normaliser should consider.</p> required <p>Returns:</p> Name Type Description <code>StateValueNormaliser</code> <code>StateValueNormaliser</code> <p>description</p> Source code in <code>src/model/learning_system/value_standardisation/normaliser_factory.py</code> <pre><code>def create_normaliser(self, base_state: int) -&gt; StateValueNormaliser:\n    \"\"\"Get the appropriate state normaliser for the given base state.\n\n    Args:\n        base_state (int): the state the defines the possible entities that\n            the normaliser should consider.\n\n    Returns:\n        StateValueNormaliser: _description_\n    \"\"\"\n    entities = self.dynamics.state_pool.get_state_from_id(\n        base_state\n    ).entities\n\n    if self.enable_cache:\n        cached_version = self.cache.get(entities, None)\n        if cached_version is not None:\n            return cached_version\n\n    normaliser = StateValueNormaliser(\n        self.agent,\n        self.__get_state_pool(),\n        self.__get_value_range(),\n    )\n    self.cache[entities] = normaliser\n    return normaliser\n</code></pre>"},{"location":"reference/model/learning_system/value_standardisation/value_range/","title":"Value Range","text":""},{"location":"reference/model/learning_system/value_standardisation/value_range/#src.model.learning_system.value_standardisation.value_range.ValueRange","title":"<code>ValueRange</code>","text":"<p>             Bases: <code>object</code></p> <p>Maintains the range of all possible values for mapping from 0 to 1.</p> Source code in <code>src/model/learning_system/value_standardisation/value_range.py</code> <pre><code>class ValueRange(object):\n    \"\"\"Maintains the range of all possible values for mapping from 0 to 1.\"\"\"\n\n    def __init__(self, state_pool: StatePool, agent: BaseAgent) -&gt; None:\n        \"\"\"Initialise a value range.\n\n        Args:\n            state_pool (StatePool): the populated set of all possible states to\n                find the range of values.\n            agent (BaseAgent): the agent to decide on values\n\n        \"\"\"\n        self.state_pool = state_pool\n        self.agent = agent\n\n        self.action_range: Optional[Tuple[float, float]] = None\n\n        self.state_range: Optional[Tuple[float, float]] = None\n\n    def rescale_value(\n        self, value_type: ValueType, absolute_value: float\n    ) -&gt; float:\n        \"\"\"Rescale a value from a value type into the range 0-1.\n\n        the minimum value of this type would get a value of 0 and the maximum\n        value of this type would get a 1.\n\n        Args:\n            value_type (ValueType): the type of value received\n            absolute_value (float): the raw value before rescaling\n\n        Returns:\n            float: _description_\n        \"\"\"\n        min_value, max_value = self.__get_value_range(value_type)\n        if min_value == max_value:\n            # all values are identical place value in the middle\n            return 0.5\n        return (absolute_value - min_value) / (max_value - min_value)\n\n    def __get_value_range(self, value_type: ValueType) -&gt; Tuple[float, float]:\n        match value_type:\n            case ValueType.state_value:\n                return self.__get_state_value_range()\n            case ValueType.state_action_value:\n                return self.__get_state_action_value_range()\n\n    def __get_state_value_range(self) -&gt; Tuple[float, float]:\n        if self.state_range is not None:\n            return self.state_range\n        maximum_state_value = float(\"-inf\")\n        minimum_state_value = float(\"inf\")\n        for state in self.state_pool.state_to_id.values():\n            state_value = self.agent.get_state_value(state)\n            maximum_state_value = max(maximum_state_value, state_value)\n            minimum_state_value = min(minimum_state_value, state_value)\n\n        self.state_range = (minimum_state_value, maximum_state_value)\n        return self.state_range\n\n    def __get_state_action_value_range(self) -&gt; Tuple[float, float]:\n        if self.action_range is not None:\n            return self.action_range\n\n        maximum_action_value = float(\"-inf\")\n        minimum_action_value = float(\"inf\")\n\n        for state in self.state_pool.state_to_id.values():\n            for action in Action:\n                action_value = self.agent.get_state_action_value(state, action)\n                maximum_action_value = max(maximum_action_value, action_value)\n                minimum_action_value = min(minimum_action_value, action_value)\n\n        self.action_range = (minimum_action_value, maximum_action_value)\n        return self.action_range\n</code></pre>"},{"location":"reference/model/learning_system/value_standardisation/value_range/#src.model.learning_system.value_standardisation.value_range.ValueRange.__init__","title":"<code>__init__(state_pool, agent)</code>","text":"<p>Initialise a value range.</p> <p>Parameters:</p> Name Type Description Default <code>state_pool</code> <code>StatePool</code> <p>the populated set of all possible states to find the range of values.</p> required <code>agent</code> <code>BaseAgent</code> <p>the agent to decide on values</p> required Source code in <code>src/model/learning_system/value_standardisation/value_range.py</code> <pre><code>def __init__(self, state_pool: StatePool, agent: BaseAgent) -&gt; None:\n    \"\"\"Initialise a value range.\n\n    Args:\n        state_pool (StatePool): the populated set of all possible states to\n            find the range of values.\n        agent (BaseAgent): the agent to decide on values\n\n    \"\"\"\n    self.state_pool = state_pool\n    self.agent = agent\n\n    self.action_range: Optional[Tuple[float, float]] = None\n\n    self.state_range: Optional[Tuple[float, float]] = None\n</code></pre>"},{"location":"reference/model/learning_system/value_standardisation/value_range/#src.model.learning_system.value_standardisation.value_range.ValueRange.rescale_value","title":"<code>rescale_value(value_type, absolute_value)</code>","text":"<p>Rescale a value from a value type into the range 0-1.</p> <p>the minimum value of this type would get a value of 0 and the maximum value of this type would get a 1.</p> <p>Parameters:</p> Name Type Description Default <code>value_type</code> <code>ValueType</code> <p>the type of value received</p> required <code>absolute_value</code> <code>float</code> <p>the raw value before rescaling</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>description</p> Source code in <code>src/model/learning_system/value_standardisation/value_range.py</code> <pre><code>def rescale_value(\n    self, value_type: ValueType, absolute_value: float\n) -&gt; float:\n    \"\"\"Rescale a value from a value type into the range 0-1.\n\n    the minimum value of this type would get a value of 0 and the maximum\n    value of this type would get a 1.\n\n    Args:\n        value_type (ValueType): the type of value received\n        absolute_value (float): the raw value before rescaling\n\n    Returns:\n        float: _description_\n    \"\"\"\n    min_value, max_value = self.__get_value_range(value_type)\n    if min_value == max_value:\n        # all values are identical place value in the middle\n        return 0.5\n    return (absolute_value - min_value) / (max_value - min_value)\n</code></pre>"},{"location":"reference/model/learning_system/value_standardisation/value_range/#src.model.learning_system.value_standardisation.value_range.ValueType","title":"<code>ValueType</code>","text":"<p>             Bases: <code>Enum</code></p> <p>Enumerates the possible types of values.</p> Source code in <code>src/model/learning_system/value_standardisation/value_range.py</code> <pre><code>class ValueType(Enum):\n    \"\"\"Enumerates the possible types of values.\"\"\"\n\n    state_value = 0\n    state_action_value = 1\n</code></pre>"},{"location":"reference/model/state/","title":"State","text":"<p>This Package contains functionality for representing each state.</p>"},{"location":"reference/model/state/cell_entities/","title":"Cell Entities","text":""},{"location":"reference/model/state/cell_entities/#src.model.state.cell_entities.CellEntity","title":"<code>CellEntity</code>","text":"<p>             Bases: <code>Enum</code></p> <p>This class enumerates all the possible entities that may be in a cell.</p> Source code in <code>src/model/state/cell_entities.py</code> <pre><code>class CellEntity(Enum):\n    \"\"\"This class enumerates all the possible entities that may be in a cell.\"\"\"\n\n    agent = 1\n    goal = 2\n    empty = 3\n    blocked = 4\n</code></pre>"},{"location":"reference/model/state/state_builder/","title":"State Builder","text":""},{"location":"reference/model/state/state_builder/#src.model.state.state_builder.StateBuilder","title":"<code>StateBuilder</code>","text":"<p>             Bases: <code>object</code></p> <p>State builder simplifies creating states.</p> <p>Since states must be immutable the state builder lets you apply multiple changes without creating the intermediary states.</p> Source code in <code>src/model/state/state_builder.py</code> <pre><code>class StateBuilder(object):\n    \"\"\"State builder simplifies creating states.\n\n    Since states must be immutable the state builder lets you apply multiple\n    changes without creating the intermediary states.\n    \"\"\"\n\n    def __init__(\n        self,\n        previous_state: Optional[StateInstance] = None,\n    ) -&gt; None:\n        \"\"\"Initialise the state builder.\n\n        Args:\n            previous_state (Optional[StateInstance]): the state to build from,\n                if not specified an arbitrary state is chosen.\n        \"\"\"\n        if previous_state is None:\n            previous_state = StateInstance.get_blank_state()\n\n        self.entities = previous_state.entities\n        self.agent_location = previous_state.agent_location\n        self.agent_energy = previous_state.agent_energy\n\n    def set_agent_location(self, pos: tuple[int, int]) -&gt; Self:\n        \"\"\"Set the agent's location.\n\n        Args:\n            pos (tuple[int, int]): the agent's new location\n\n        Returns:\n            Self: the builder to continue chaining methods\n        \"\"\"\n        self.agent_location = pos\n        return self\n\n    def set_energy(self, energy: int) -&gt; Self:\n        \"\"\"Set the agent's energy.\n\n        Args:\n            energy (int): the agent's new energy\n\n        Returns:\n            Self: the builder to continue chaining methods\n        \"\"\"\n        self.agent_energy = energy\n        return self\n\n    def decrement_energy(self, amount=1) -&gt; Self:\n        \"\"\"Decrement the energy by an amount.\n\n        Args:\n            amount (int): the amount to reduce the energy by. Defaults to 1.\n\n        Returns:\n            Self: the builder to continue chaining methods\n        \"\"\"\n        self.agent_energy -= amount\n        if self.agent_energy &lt; 0:\n            self.agent_energy = 0\n        return self\n\n    def set_entity(self, cell: tuple[int, int], entity: CellEntity) -&gt; Self:\n        \"\"\"Set the entity that is in a cell.\n\n        Args:\n            cell (tuple[int, int]): the cell where to update the entity.\n            entity (CellEntity): the new entity at this location.\n\n        Returns:\n            Self: the builder to continue chaining methods\n        \"\"\"\n        self.entities = self.entities.set(cell, entity)\n        return self\n\n    def remove_entity(self, cell: tuple[int, int]) -&gt; Self:\n        \"\"\"Remove the entity that is in a cell.\n\n        Args:\n            cell (tuple[int, int]): the cell where to update an entity.\n\n        Returns:\n            Self: the builder to continue chaining methods\n        \"\"\"\n        self.entities = self.entities.delete(cell)\n        return self\n\n    def build(self) -&gt; StateInstance:\n        \"\"\"Compile the changes into the new state.\n\n        Returns:\n            StateInstance: the new state instance after the changes have been\n            applied.\n        \"\"\"\n        return StateInstance(\n            self.agent_location, self.entities, self.agent_energy\n        )\n</code></pre>"},{"location":"reference/model/state/state_builder/#src.model.state.state_builder.StateBuilder.__init__","title":"<code>__init__(previous_state=None)</code>","text":"<p>Initialise the state builder.</p> <p>Parameters:</p> Name Type Description Default <code>previous_state</code> <code>Optional[StateInstance]</code> <p>the state to build from, if not specified an arbitrary state is chosen.</p> <code>None</code> Source code in <code>src/model/state/state_builder.py</code> <pre><code>def __init__(\n    self,\n    previous_state: Optional[StateInstance] = None,\n) -&gt; None:\n    \"\"\"Initialise the state builder.\n\n    Args:\n        previous_state (Optional[StateInstance]): the state to build from,\n            if not specified an arbitrary state is chosen.\n    \"\"\"\n    if previous_state is None:\n        previous_state = StateInstance.get_blank_state()\n\n    self.entities = previous_state.entities\n    self.agent_location = previous_state.agent_location\n    self.agent_energy = previous_state.agent_energy\n</code></pre>"},{"location":"reference/model/state/state_builder/#src.model.state.state_builder.StateBuilder.build","title":"<code>build()</code>","text":"<p>Compile the changes into the new state.</p> <p>Returns:</p> Name Type Description <code>StateInstance</code> <code>StateInstance</code> <p>the new state instance after the changes have been</p> <code>StateInstance</code> <p>applied.</p> Source code in <code>src/model/state/state_builder.py</code> <pre><code>def build(self) -&gt; StateInstance:\n    \"\"\"Compile the changes into the new state.\n\n    Returns:\n        StateInstance: the new state instance after the changes have been\n        applied.\n    \"\"\"\n    return StateInstance(\n        self.agent_location, self.entities, self.agent_energy\n    )\n</code></pre>"},{"location":"reference/model/state/state_builder/#src.model.state.state_builder.StateBuilder.decrement_energy","title":"<code>decrement_energy(amount=1)</code>","text":"<p>Decrement the energy by an amount.</p> <p>Parameters:</p> Name Type Description Default <code>amount</code> <code>int</code> <p>the amount to reduce the energy by. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>the builder to continue chaining methods</p> Source code in <code>src/model/state/state_builder.py</code> <pre><code>def decrement_energy(self, amount=1) -&gt; Self:\n    \"\"\"Decrement the energy by an amount.\n\n    Args:\n        amount (int): the amount to reduce the energy by. Defaults to 1.\n\n    Returns:\n        Self: the builder to continue chaining methods\n    \"\"\"\n    self.agent_energy -= amount\n    if self.agent_energy &lt; 0:\n        self.agent_energy = 0\n    return self\n</code></pre>"},{"location":"reference/model/state/state_builder/#src.model.state.state_builder.StateBuilder.remove_entity","title":"<code>remove_entity(cell)</code>","text":"<p>Remove the entity that is in a cell.</p> <p>Parameters:</p> Name Type Description Default <code>cell</code> <code>tuple[int, int]</code> <p>the cell where to update an entity.</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>the builder to continue chaining methods</p> Source code in <code>src/model/state/state_builder.py</code> <pre><code>def remove_entity(self, cell: tuple[int, int]) -&gt; Self:\n    \"\"\"Remove the entity that is in a cell.\n\n    Args:\n        cell (tuple[int, int]): the cell where to update an entity.\n\n    Returns:\n        Self: the builder to continue chaining methods\n    \"\"\"\n    self.entities = self.entities.delete(cell)\n    return self\n</code></pre>"},{"location":"reference/model/state/state_builder/#src.model.state.state_builder.StateBuilder.set_agent_location","title":"<code>set_agent_location(pos)</code>","text":"<p>Set the agent's location.</p> <p>Parameters:</p> Name Type Description Default <code>pos</code> <code>tuple[int, int]</code> <p>the agent's new location</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>the builder to continue chaining methods</p> Source code in <code>src/model/state/state_builder.py</code> <pre><code>def set_agent_location(self, pos: tuple[int, int]) -&gt; Self:\n    \"\"\"Set the agent's location.\n\n    Args:\n        pos (tuple[int, int]): the agent's new location\n\n    Returns:\n        Self: the builder to continue chaining methods\n    \"\"\"\n    self.agent_location = pos\n    return self\n</code></pre>"},{"location":"reference/model/state/state_builder/#src.model.state.state_builder.StateBuilder.set_energy","title":"<code>set_energy(energy)</code>","text":"<p>Set the agent's energy.</p> <p>Parameters:</p> Name Type Description Default <code>energy</code> <code>int</code> <p>the agent's new energy</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>the builder to continue chaining methods</p> Source code in <code>src/model/state/state_builder.py</code> <pre><code>def set_energy(self, energy: int) -&gt; Self:\n    \"\"\"Set the agent's energy.\n\n    Args:\n        energy (int): the agent's new energy\n\n    Returns:\n        Self: the builder to continue chaining methods\n    \"\"\"\n    self.agent_energy = energy\n    return self\n</code></pre>"},{"location":"reference/model/state/state_builder/#src.model.state.state_builder.StateBuilder.set_entity","title":"<code>set_entity(cell, entity)</code>","text":"<p>Set the entity that is in a cell.</p> <p>Parameters:</p> Name Type Description Default <code>cell</code> <code>tuple[int, int]</code> <p>the cell where to update the entity.</p> required <code>entity</code> <code>CellEntity</code> <p>the new entity at this location.</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>the builder to continue chaining methods</p> Source code in <code>src/model/state/state_builder.py</code> <pre><code>def set_entity(self, cell: tuple[int, int], entity: CellEntity) -&gt; Self:\n    \"\"\"Set the entity that is in a cell.\n\n    Args:\n        cell (tuple[int, int]): the cell where to update the entity.\n        entity (CellEntity): the new entity at this location.\n\n    Returns:\n        Self: the builder to continue chaining methods\n    \"\"\"\n    self.entities = self.entities.set(cell, entity)\n    return self\n</code></pre>"},{"location":"reference/model/state/state_instance/","title":"State Instance","text":""},{"location":"reference/model/state/state_instance/#src.model.state.state_instance.StateInstance","title":"<code>StateInstance</code>","text":"<p>             Bases: <code>object</code></p> <p>This class represents a possible state in the grid world of this MDP.</p> Source code in <code>src/model/state/state_instance.py</code> <pre><code>class StateInstance(object):\n    \"\"\"This class represents a possible state in the grid world of this MDP.\"\"\"\n\n    def __init__(\n        self,\n        agent_location: Tuple[int, int],\n        entities: entities_type,\n        agent_energy: int,\n    ) -&gt; None:\n        \"\"\"Initialise a new state.\n\n        each state must be immutable. therefore to achieve a state with\n        different properties a new state must be created, this is done by the\n        dynamics.\n\n        Args:\n            agent_location (tuple[int, int]): _description_\n            entities (entities_type): _description_\n            agent_energy (int): _description_\n        \"\"\"\n        self.agent_location = agent_location\n        self.entities = entities\n        self.agent_energy = agent_energy\n\n    @classmethod\n    def get_blank_state(cls) -&gt; Self:\n        \"\"\"Create a blank state.\n\n        Returns:\n            Self: a state with no particular features.\n        \"\"\"\n        return cls((0, 0), Map(), 10)\n\n    def __hash__(self) -&gt; int:\n        \"\"\"Generate a hash value for this state.\n\n        Helpful in speeding up indexing operations.\n\n        Returns:\n            int: the hash of this state\n        \"\"\"\n        return hash((self.agent_location, self.entities, self.agent_energy))\n\n    def __eq__(self, other: object) -&gt; bool:\n        \"\"\"Test for equality between two states.\n\n        Args:\n            other (object): the other state to compare to\n\n        Returns:\n            bool: true if the two states can be considered equal.\n        \"\"\"\n        if not isinstance(other, StateInstance):\n            return False\n        return (\n            self.agent_location == other.agent_location\n            and self.entities == other.entities\n            and self.agent_energy == other.agent_energy\n        )\n</code></pre>"},{"location":"reference/model/state/state_instance/#src.model.state.state_instance.StateInstance.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Test for equality between two states.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>object</code> <p>the other state to compare to</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>true if the two states can be considered equal.</p> Source code in <code>src/model/state/state_instance.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n    \"\"\"Test for equality between two states.\n\n    Args:\n        other (object): the other state to compare to\n\n    Returns:\n        bool: true if the two states can be considered equal.\n    \"\"\"\n    if not isinstance(other, StateInstance):\n        return False\n    return (\n        self.agent_location == other.agent_location\n        and self.entities == other.entities\n        and self.agent_energy == other.agent_energy\n    )\n</code></pre>"},{"location":"reference/model/state/state_instance/#src.model.state.state_instance.StateInstance.__hash__","title":"<code>__hash__()</code>","text":"<p>Generate a hash value for this state.</p> <p>Helpful in speeding up indexing operations.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>the hash of this state</p> Source code in <code>src/model/state/state_instance.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Generate a hash value for this state.\n\n    Helpful in speeding up indexing operations.\n\n    Returns:\n        int: the hash of this state\n    \"\"\"\n    return hash((self.agent_location, self.entities, self.agent_energy))\n</code></pre>"},{"location":"reference/model/state/state_instance/#src.model.state.state_instance.StateInstance.__init__","title":"<code>__init__(agent_location, entities, agent_energy)</code>","text":"<p>Initialise a new state.</p> <p>each state must be immutable. therefore to achieve a state with different properties a new state must be created, this is done by the dynamics.</p> <p>Parameters:</p> Name Type Description Default <code>agent_location</code> <code>tuple[int, int]</code> <p>description</p> required <code>entities</code> <code>entities_type</code> <p>description</p> required <code>agent_energy</code> <code>int</code> <p>description</p> required Source code in <code>src/model/state/state_instance.py</code> <pre><code>def __init__(\n    self,\n    agent_location: Tuple[int, int],\n    entities: entities_type,\n    agent_energy: int,\n) -&gt; None:\n    \"\"\"Initialise a new state.\n\n    each state must be immutable. therefore to achieve a state with\n    different properties a new state must be created, this is done by the\n    dynamics.\n\n    Args:\n        agent_location (tuple[int, int]): _description_\n        entities (entities_type): _description_\n        agent_energy (int): _description_\n    \"\"\"\n    self.agent_location = agent_location\n    self.entities = entities\n    self.agent_energy = agent_energy\n</code></pre>"},{"location":"reference/model/state/state_instance/#src.model.state.state_instance.StateInstance.get_blank_state","title":"<code>get_blank_state()</code>  <code>classmethod</code>","text":"<p>Create a blank state.</p> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>a state with no particular features.</p> Source code in <code>src/model/state/state_instance.py</code> <pre><code>@classmethod\ndef get_blank_state(cls) -&gt; Self:\n    \"\"\"Create a blank state.\n\n    Returns:\n        Self: a state with no particular features.\n    \"\"\"\n    return cls((0, 0), Map(), 10)\n</code></pre>"},{"location":"reference/model/state/state_pool/","title":"State Pool","text":""},{"location":"reference/model/state/state_pool/#src.model.state.state_pool.StatePool","title":"<code>StatePool</code>","text":"<p>             Bases: <code>object</code></p> <p>Class that manages the creation of states.</p> <p>This class avoids redundant states and allows for consistent identification</p> Source code in <code>src/model/state/state_pool.py</code> <pre><code>class StatePool(object):\n    \"\"\"Class that manages the creation of states.\n\n    This class avoids redundant states and allows for consistent identification\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialise a state pool.\"\"\"\n        self.id_to_state: Dict[int, StateInstance] = {}\n        self.state_to_id: Dict[StateInstance, int] = {}\n\n    def is_existing_state(self, state: StateInstance) -&gt; bool:\n        \"\"\"Determine weather a state has already been registered.\n\n        Args:\n            state (StateInstance): the state to check\n\n        Returns:\n            bool: true if this state already exists in this pool\n        \"\"\"\n        return state in self.state_to_id\n\n    def get_state_id(self, state: StateInstance) -&gt; int:\n        \"\"\"Get the numeric id for a given state.\n\n        If the state has already been registered with this pool then it should\n        return the existing key. else it should add this state to the pool and\n        return the new state.\n\n        Note, this id is not necessarily globally unique however it is unique in\n        this state pool\n\n        Args:\n            state (StateInstance): the state to get a unique id for\n\n        Returns:\n            int: the id for this state\n        \"\"\"\n        if self.is_existing_state(state):\n            return self.state_to_id[state]\n        new_id = len(self.state_to_id)\n        self.state_to_id[state] = new_id\n        self.id_to_state[new_id] = state\n        return new_id\n\n    def get_state_from_id(self, identifier: int) -&gt; StateInstance:\n        \"\"\"Get the state object corresponding to the given key in this pool.\n\n        Args:\n            identifier (int): the key of the state to get\n\n        Returns:\n            StateInstance: the state that is registered under this id\n        \"\"\"\n        return self.id_to_state[identifier]\n</code></pre>"},{"location":"reference/model/state/state_pool/#src.model.state.state_pool.StatePool.__init__","title":"<code>__init__()</code>","text":"<p>Initialise a state pool.</p> Source code in <code>src/model/state/state_pool.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialise a state pool.\"\"\"\n    self.id_to_state: Dict[int, StateInstance] = {}\n    self.state_to_id: Dict[StateInstance, int] = {}\n</code></pre>"},{"location":"reference/model/state/state_pool/#src.model.state.state_pool.StatePool.get_state_from_id","title":"<code>get_state_from_id(identifier)</code>","text":"<p>Get the state object corresponding to the given key in this pool.</p> <p>Parameters:</p> Name Type Description Default <code>identifier</code> <code>int</code> <p>the key of the state to get</p> required <p>Returns:</p> Name Type Description <code>StateInstance</code> <code>StateInstance</code> <p>the state that is registered under this id</p> Source code in <code>src/model/state/state_pool.py</code> <pre><code>def get_state_from_id(self, identifier: int) -&gt; StateInstance:\n    \"\"\"Get the state object corresponding to the given key in this pool.\n\n    Args:\n        identifier (int): the key of the state to get\n\n    Returns:\n        StateInstance: the state that is registered under this id\n    \"\"\"\n    return self.id_to_state[identifier]\n</code></pre>"},{"location":"reference/model/state/state_pool/#src.model.state.state_pool.StatePool.get_state_id","title":"<code>get_state_id(state)</code>","text":"<p>Get the numeric id for a given state.</p> <p>If the state has already been registered with this pool then it should return the existing key. else it should add this state to the pool and return the new state.</p> <p>Note, this id is not necessarily globally unique however it is unique in this state pool</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>StateInstance</code> <p>the state to get a unique id for</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>the id for this state</p> Source code in <code>src/model/state/state_pool.py</code> <pre><code>def get_state_id(self, state: StateInstance) -&gt; int:\n    \"\"\"Get the numeric id for a given state.\n\n    If the state has already been registered with this pool then it should\n    return the existing key. else it should add this state to the pool and\n    return the new state.\n\n    Note, this id is not necessarily globally unique however it is unique in\n    this state pool\n\n    Args:\n        state (StateInstance): the state to get a unique id for\n\n    Returns:\n        int: the id for this state\n    \"\"\"\n    if self.is_existing_state(state):\n        return self.state_to_id[state]\n    new_id = len(self.state_to_id)\n    self.state_to_id[state] = new_id\n    self.id_to_state[new_id] = state\n    return new_id\n</code></pre>"},{"location":"reference/model/state/state_pool/#src.model.state.state_pool.StatePool.is_existing_state","title":"<code>is_existing_state(state)</code>","text":"<p>Determine weather a state has already been registered.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>StateInstance</code> <p>the state to check</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>true if this state already exists in this pool</p> Source code in <code>src/model/state/state_pool.py</code> <pre><code>def is_existing_state(self, state: StateInstance) -&gt; bool:\n    \"\"\"Determine weather a state has already been registered.\n\n    Args:\n        state (StateInstance): the state to check\n\n    Returns:\n        bool: true if this state already exists in this pool\n    \"\"\"\n    return state in self.state_to_id\n</code></pre>"},{"location":"reference/view/","title":"View","text":"<p>The view package this package contains the code that defines the view.</p> <p>the view is the user interface with this program.</p>"},{"location":"reference/view/option_controls/","title":"Option Controls","text":""},{"location":"reference/view/option_controls/#src.view.option_controls.OptionControls","title":"<code>OptionControls</code>","text":"<p>             Bases: <code>QGroupBox</code></p> <p>Widget that contains the controls for interacting with the grid world.</p> Source code in <code>src/view/option_controls.py</code> <pre><code>class OptionControls(QGroupBox):\n    \"\"\"Widget that contains the controls for interacting with the grid world.\"\"\"\n\n    agent_options = {\n        \"Value Iteration\": AgentOptions.value_iteration_optimised,\n        \"Q-Learning\": AgentOptions.q_learning,\n    }\n\n    agent_strategy_options = {\n        \"Epsilon-greedy\": ExplorationStrategyOptions.epsilon_greedy\n    }\n\n    dynamics_options = {\n        \"Collection\": DynamicsOptions.collection,\n    }\n\n    group_title = \"Simulation Configuration Controls\"\n\n    reset_button_text = \"reset\"\n\n    def __init__(\n        self, parent: QWidget, control_factory: ControlFactory\n    ) -&gt; None:\n        \"\"\"Initialise the option controls.\n\n        Args:\n            parent (QWidget): the parent of this widget.\n            control_factory (ControlFactory): the factory to make the controls\n                with.\n        \"\"\"\n        super().__init__(self.group_title, parent)\n\n        layout = QGridLayout(self)\n\n        agent = control_factory.create_combo(\n            self, self.agent_options, UserAction.set_agent\n        )\n        layout.addWidget(agent, 0, 0)\n\n        agent_strategy = control_factory.create_combo(\n            self, self.agent_strategy_options, UserAction.set_agent_strategy\n        )\n        layout.addWidget(agent_strategy, 0, 1)\n\n        dynamics = control_factory.create_combo(\n            self, self.dynamics_options, UserAction.set_dynamics\n        )\n        layout.addWidget(dynamics, 0, 2)\n\n        reset = control_factory.create_button(\n            self, self.reset_button_text, UserAction.reset_system\n        )\n        layout.addWidget(reset, 0, 3)\n</code></pre>"},{"location":"reference/view/option_controls/#src.view.option_controls.OptionControls.__init__","title":"<code>__init__(parent, control_factory)</code>","text":"<p>Initialise the option controls.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>the parent of this widget.</p> required <code>control_factory</code> <code>ControlFactory</code> <p>the factory to make the controls with.</p> required Source code in <code>src/view/option_controls.py</code> <pre><code>def __init__(\n    self, parent: QWidget, control_factory: ControlFactory\n) -&gt; None:\n    \"\"\"Initialise the option controls.\n\n    Args:\n        parent (QWidget): the parent of this widget.\n        control_factory (ControlFactory): the factory to make the controls\n            with.\n    \"\"\"\n    super().__init__(self.group_title, parent)\n\n    layout = QGridLayout(self)\n\n    agent = control_factory.create_combo(\n        self, self.agent_options, UserAction.set_agent\n    )\n    layout.addWidget(agent, 0, 0)\n\n    agent_strategy = control_factory.create_combo(\n        self, self.agent_strategy_options, UserAction.set_agent_strategy\n    )\n    layout.addWidget(agent_strategy, 0, 1)\n\n    dynamics = control_factory.create_combo(\n        self, self.dynamics_options, UserAction.set_dynamics\n    )\n    layout.addWidget(dynamics, 0, 2)\n\n    reset = control_factory.create_button(\n        self, self.reset_button_text, UserAction.reset_system\n    )\n    layout.addWidget(reset, 0, 3)\n</code></pre>"},{"location":"reference/view/state_publisher/","title":"State Publisher","text":""},{"location":"reference/view/state_publisher/#src.view.state_publisher.BaseStateObserver","title":"<code>BaseStateObserver</code>","text":"<p>             Bases: <code>object</code></p> <p>The base class for state observers.</p> Source code in <code>src/view/state_publisher.py</code> <pre><code>class BaseStateObserver(object):\n    \"\"\"The base class for state observers.\"\"\"\n\n    def state_updated(self, state: StateDescription) -&gt; None:\n        \"\"\"Handle state update events.\n\n        Args:\n            state (StateDescription): the new state\n\n        Raises:\n            NotImplementedError: If the method is not overridden by a concrete\n                observer.\n        \"\"\"\n        self.__throw_not_implemented()\n\n    def __throw_not_implemented(self):\n        raise NotImplementedError(\n            \"This method should be overridden by a concrete observer\"\n        )\n</code></pre>"},{"location":"reference/view/state_publisher/#src.view.state_publisher.BaseStateObserver.state_updated","title":"<code>state_updated(state)</code>","text":"<p>Handle state update events.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>StateDescription</code> <p>the new state</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the method is not overridden by a concrete observer.</p> Source code in <code>src/view/state_publisher.py</code> <pre><code>def state_updated(self, state: StateDescription) -&gt; None:\n    \"\"\"Handle state update events.\n\n    Args:\n        state (StateDescription): the new state\n\n    Raises:\n        NotImplementedError: If the method is not overridden by a concrete\n            observer.\n    \"\"\"\n    self.__throw_not_implemented()\n</code></pre>"},{"location":"reference/view/state_publisher/#src.view.state_publisher.StatePublisher","title":"<code>StatePublisher</code>","text":"<p>             Bases: <code>object</code></p> <p>Publisher class for state updates.</p> Source code in <code>src/view/state_publisher.py</code> <pre><code>class StatePublisher(object):\n    \"\"\"Publisher class for state updates.\"\"\"\n\n    def __init__(\n        self, parent: QWidget, controller: LearningSystemController\n    ) -&gt; None:\n        \"\"\"Initialise a new state publisher.\n\n        Args:\n            parent (QWidget): the widget that this publisher is associated with.\n                timers do not work without this.\n            controller (LearningSystemController): the controller to listen for\n                state update from.\n        \"\"\"\n        timer = QTimer(parent)\n        timer.timeout.connect(self.check_for_updates)\n        timer.start(1)\n\n        self.update_bridge = controller.state_update_bridge\n\n        self.observers: list[BaseStateObserver] = []\n\n        # used to provided initial state\n        self.latest_state: Optional[StateDescription] = None\n\n        # start updates\n        controller.user_action_bridge.submit_action(\n            UserAction.fetch_current_state\n        )\n\n    def subscribe(self, observer: BaseStateObserver) -&gt; None:\n        \"\"\"Subscribe a new observer to state updates.\n\n        Args:\n            observer (BaseStateObserver): the observer to listen for state\n                updates.\n        \"\"\"\n        self.observers.append(observer)\n        if self.latest_state is not None:\n            observer.state_updated(self.latest_state)\n\n    def check_for_updates(self):\n        \"\"\"Check if any updates to the UI are requested.\"\"\"\n        state = self.update_bridge.get_latest_state()\n        if state is not None:\n            for observer in self.observers:\n                observer.state_updated(state)\n</code></pre>"},{"location":"reference/view/state_publisher/#src.view.state_publisher.StatePublisher.__init__","title":"<code>__init__(parent, controller)</code>","text":"<p>Initialise a new state publisher.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>the widget that this publisher is associated with. timers do not work without this.</p> required <code>controller</code> <code>LearningSystemController</code> <p>the controller to listen for state update from.</p> required Source code in <code>src/view/state_publisher.py</code> <pre><code>def __init__(\n    self, parent: QWidget, controller: LearningSystemController\n) -&gt; None:\n    \"\"\"Initialise a new state publisher.\n\n    Args:\n        parent (QWidget): the widget that this publisher is associated with.\n            timers do not work without this.\n        controller (LearningSystemController): the controller to listen for\n            state update from.\n    \"\"\"\n    timer = QTimer(parent)\n    timer.timeout.connect(self.check_for_updates)\n    timer.start(1)\n\n    self.update_bridge = controller.state_update_bridge\n\n    self.observers: list[BaseStateObserver] = []\n\n    # used to provided initial state\n    self.latest_state: Optional[StateDescription] = None\n\n    # start updates\n    controller.user_action_bridge.submit_action(\n        UserAction.fetch_current_state\n    )\n</code></pre>"},{"location":"reference/view/state_publisher/#src.view.state_publisher.StatePublisher.check_for_updates","title":"<code>check_for_updates()</code>","text":"<p>Check if any updates to the UI are requested.</p> Source code in <code>src/view/state_publisher.py</code> <pre><code>def check_for_updates(self):\n    \"\"\"Check if any updates to the UI are requested.\"\"\"\n    state = self.update_bridge.get_latest_state()\n    if state is not None:\n        for observer in self.observers:\n            observer.state_updated(state)\n</code></pre>"},{"location":"reference/view/state_publisher/#src.view.state_publisher.StatePublisher.subscribe","title":"<code>subscribe(observer)</code>","text":"<p>Subscribe a new observer to state updates.</p> <p>Parameters:</p> Name Type Description Default <code>observer</code> <code>BaseStateObserver</code> <p>the observer to listen for state updates.</p> required Source code in <code>src/view/state_publisher.py</code> <pre><code>def subscribe(self, observer: BaseStateObserver) -&gt; None:\n    \"\"\"Subscribe a new observer to state updates.\n\n    Args:\n        observer (BaseStateObserver): the observer to listen for state\n            updates.\n    \"\"\"\n    self.observers.append(observer)\n    if self.latest_state is not None:\n        observer.state_updated(self.latest_state)\n</code></pre>"},{"location":"reference/view/view_root_v2/","title":"View Root V2","text":""},{"location":"reference/view/view_root_v2/#src.view.view_root_v2.ReinforcementLearningApp","title":"<code>ReinforcementLearningApp</code>","text":"<p>             Bases: <code>QWidget</code></p> <p>This is the root of the applications main UI.</p> Source code in <code>src/view/view_root_v2.py</code> <pre><code>class ReinforcementLearningApp(QWidget):\n    \"\"\"This is the root of the applications main UI.\"\"\"\n\n    tab_labels = {\n        AgentOptions.value_iteration_optimised: \"Value Iteration\",\n        AgentOptions.q_learning: \"Q-Learning\",\n    }\n\n    def __init__(self, controller: LearningSystemController) -&gt; None:\n        \"\"\"Instantiate the applications user interface.\n\n        Args:\n            controller (LearningSystemController): the controller\n            responsible for managing user actions.\n        \"\"\"\n        super().__init__(parent=None, f=Qt.WindowType.Window)\n        self.setWindowTitle(\"RHUL MSci FYP - Reinforcement Learning App\")\n        self.setup_config()\n\n        self.publisher = StatePublisher(self, controller)\n        layout = QGridLayout(self)\n\n        control_factory = ControlFactory(controller, self.publisher)\n\n        self.controls = OptionControls(self, control_factory)\n        layout.addWidget(self.controls, 0, 0)\n\n        self.grid_world = GridWorld(self, controller)\n        layout.addWidget(self.grid_world, 1, 0)\n        self.publisher.subscribe(self.grid_world)\n\n    def setup_config(self):\n        \"\"\"Set app properties from config.\"\"\"\n        config = ConfigReader().gui()\n        setup_theme(config.appearance_mode())\n        width, height = config.initial_size().split(\"x\")\n        self.resize(int(width), int(height))\n</code></pre>"},{"location":"reference/view/view_root_v2/#src.view.view_root_v2.ReinforcementLearningApp.__init__","title":"<code>__init__(controller)</code>","text":"<p>Instantiate the applications user interface.</p> <p>Parameters:</p> Name Type Description Default <code>controller</code> <code>LearningSystemController</code> <p>the controller</p> required Source code in <code>src/view/view_root_v2.py</code> <pre><code>def __init__(self, controller: LearningSystemController) -&gt; None:\n    \"\"\"Instantiate the applications user interface.\n\n    Args:\n        controller (LearningSystemController): the controller\n        responsible for managing user actions.\n    \"\"\"\n    super().__init__(parent=None, f=Qt.WindowType.Window)\n    self.setWindowTitle(\"RHUL MSci FYP - Reinforcement Learning App\")\n    self.setup_config()\n\n    self.publisher = StatePublisher(self, controller)\n    layout = QGridLayout(self)\n\n    control_factory = ControlFactory(controller, self.publisher)\n\n    self.controls = OptionControls(self, control_factory)\n    layout.addWidget(self.controls, 0, 0)\n\n    self.grid_world = GridWorld(self, controller)\n    layout.addWidget(self.grid_world, 1, 0)\n    self.publisher.subscribe(self.grid_world)\n</code></pre>"},{"location":"reference/view/view_root_v2/#src.view.view_root_v2.ReinforcementLearningApp.setup_config","title":"<code>setup_config()</code>","text":"<p>Set app properties from config.</p> Source code in <code>src/view/view_root_v2.py</code> <pre><code>def setup_config(self):\n    \"\"\"Set app properties from config.\"\"\"\n    config = ConfigReader().gui()\n    setup_theme(config.appearance_mode())\n    width, height = config.initial_size().split(\"x\")\n    self.resize(int(width), int(height))\n</code></pre>"},{"location":"reference/view/controls/","title":"Controls","text":"<p>This package contains control widgets.</p> <p>These custom controls are setup to notify the controller</p>"},{"location":"reference/view/controls/control_factory/","title":"Control Factory","text":""},{"location":"reference/view/controls/control_factory/#src.view.controls.control_factory.ControlFactory","title":"<code>ControlFactory</code>","text":"<p>             Bases: <code>object</code></p> <p>Factory class for creating controls.</p> Source code in <code>src/view/controls/control_factory.py</code> <pre><code>class ControlFactory(object):\n    \"\"\"Factory class for creating controls.\"\"\"\n\n    def __init__(\n        self,\n        controller: LearningSystemController,\n        state_update_publisher: StatePublisher,\n    ) -&gt; None:\n        \"\"\"Initialise the factory.\n\n        Args:\n            controller (LearningSystemController): the controller these controls\n                should be connected to.\n            state_update_publisher (StatePublisher): the publisher used by\n                reactive controls.\n        \"\"\"\n        self.controller = controller\n        self.state_update_publisher = state_update_publisher\n\n    def create_button(\n        self,\n        parent: QWidget,\n        text: str,\n        action: UserAction,\n        responsive_text_handler: Optional[responsive_text_handler_type] = None,\n    ) -&gt; CustomButtonWidget:\n        \"\"\"Create the Button widget.\n\n        Args:\n            parent (QWidget): the parent of this widget\n            text (str): the text to display\n            action (UserAction): the action this button should perform when\n                pressed.\n            responsive_text_handler (Optional[responsive_text_handler_type]): an\n                additional property that can be provided to update the text\n                dynamically.\n\n        Returns:\n            CustomButtonWidget: the connected widget.\n        \"\"\"\n        widget = CustomButtonWidget(\n            parent, text, action, self.controller, responsive_text_handler\n        )\n\n        if responsive_text_handler is not None:\n            self.state_update_publisher.subscribe(widget)\n        return widget\n\n    def create_combo(\n        self,\n        parent: QWidget,\n        options: Dict[str, Any],\n        action: UserAction,\n        responsive_options_handler: Optional[handler_type] = None,\n    ) -&gt; CustomComboWidget:\n        \"\"\"Create combo box widget.\n\n        Args:\n            parent (QWidget): the parent widget this widget should be rendered\n                into.\n            options (Dict[str, Any]): the options to pick between.\n            action (UserAction): The user action this combo box corresponds to\n            responsive_options_handler (Optional[handler_type]): an optional\n                handler to make this combo box responsive to state updates.\n\n        Returns:\n            CustomComboWidget: the connected widget.\n        \"\"\"\n        first_option = list(options)[0]\n\n        state = ComboWidgetState(options, first_option, enabled=True)\n        widget = CustomComboWidget(\n            parent, state, action, self.controller, responsive_options_handler\n        )\n        if responsive_options_handler is not None:\n            self.state_update_publisher.subscribe(widget)\n\n        return widget\n</code></pre>"},{"location":"reference/view/controls/control_factory/#src.view.controls.control_factory.ControlFactory.__init__","title":"<code>__init__(controller, state_update_publisher)</code>","text":"<p>Initialise the factory.</p> <p>Parameters:</p> Name Type Description Default <code>controller</code> <code>LearningSystemController</code> <p>the controller these controls should be connected to.</p> required <code>state_update_publisher</code> <code>StatePublisher</code> <p>the publisher used by reactive controls.</p> required Source code in <code>src/view/controls/control_factory.py</code> <pre><code>def __init__(\n    self,\n    controller: LearningSystemController,\n    state_update_publisher: StatePublisher,\n) -&gt; None:\n    \"\"\"Initialise the factory.\n\n    Args:\n        controller (LearningSystemController): the controller these controls\n            should be connected to.\n        state_update_publisher (StatePublisher): the publisher used by\n            reactive controls.\n    \"\"\"\n    self.controller = controller\n    self.state_update_publisher = state_update_publisher\n</code></pre>"},{"location":"reference/view/controls/control_factory/#src.view.controls.control_factory.ControlFactory.create_button","title":"<code>create_button(parent, text, action, responsive_text_handler=None)</code>","text":"<p>Create the Button widget.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>the parent of this widget</p> required <code>text</code> <code>str</code> <p>the text to display</p> required <code>action</code> <code>UserAction</code> <p>the action this button should perform when pressed.</p> required <code>responsive_text_handler</code> <code>Optional[responsive_text_handler_type]</code> <p>an additional property that can be provided to update the text dynamically.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>CustomButtonWidget</code> <code>CustomButtonWidget</code> <p>the connected widget.</p> Source code in <code>src/view/controls/control_factory.py</code> <pre><code>def create_button(\n    self,\n    parent: QWidget,\n    text: str,\n    action: UserAction,\n    responsive_text_handler: Optional[responsive_text_handler_type] = None,\n) -&gt; CustomButtonWidget:\n    \"\"\"Create the Button widget.\n\n    Args:\n        parent (QWidget): the parent of this widget\n        text (str): the text to display\n        action (UserAction): the action this button should perform when\n            pressed.\n        responsive_text_handler (Optional[responsive_text_handler_type]): an\n            additional property that can be provided to update the text\n            dynamically.\n\n    Returns:\n        CustomButtonWidget: the connected widget.\n    \"\"\"\n    widget = CustomButtonWidget(\n        parent, text, action, self.controller, responsive_text_handler\n    )\n\n    if responsive_text_handler is not None:\n        self.state_update_publisher.subscribe(widget)\n    return widget\n</code></pre>"},{"location":"reference/view/controls/control_factory/#src.view.controls.control_factory.ControlFactory.create_combo","title":"<code>create_combo(parent, options, action, responsive_options_handler=None)</code>","text":"<p>Create combo box widget.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>the parent widget this widget should be rendered into.</p> required <code>options</code> <code>Dict[str, Any]</code> <p>the options to pick between.</p> required <code>action</code> <code>UserAction</code> <p>The user action this combo box corresponds to</p> required <code>responsive_options_handler</code> <code>Optional[handler_type]</code> <p>an optional handler to make this combo box responsive to state updates.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>CustomComboWidget</code> <code>CustomComboWidget</code> <p>the connected widget.</p> Source code in <code>src/view/controls/control_factory.py</code> <pre><code>def create_combo(\n    self,\n    parent: QWidget,\n    options: Dict[str, Any],\n    action: UserAction,\n    responsive_options_handler: Optional[handler_type] = None,\n) -&gt; CustomComboWidget:\n    \"\"\"Create combo box widget.\n\n    Args:\n        parent (QWidget): the parent widget this widget should be rendered\n            into.\n        options (Dict[str, Any]): the options to pick between.\n        action (UserAction): The user action this combo box corresponds to\n        responsive_options_handler (Optional[handler_type]): an optional\n            handler to make this combo box responsive to state updates.\n\n    Returns:\n        CustomComboWidget: the connected widget.\n    \"\"\"\n    first_option = list(options)[0]\n\n    state = ComboWidgetState(options, first_option, enabled=True)\n    widget = CustomComboWidget(\n        parent, state, action, self.controller, responsive_options_handler\n    )\n    if responsive_options_handler is not None:\n        self.state_update_publisher.subscribe(widget)\n\n    return widget\n</code></pre>"},{"location":"reference/view/controls/custom_button_widget/","title":"Custom Button Widget","text":""},{"location":"reference/view/controls/custom_button_widget/#src.view.controls.custom_button_widget.CustomButtonWidget","title":"<code>CustomButtonWidget</code>","text":"<p>             Bases: <code>QPushButton</code>, <code>BaseStateObserver</code></p> <p>Custom Button widget configured to update the controller.</p> Source code in <code>src/view/controls/custom_button_widget.py</code> <pre><code>class CustomButtonWidget(QPushButton, BaseStateObserver):\n    \"\"\"Custom Button widget configured to update the controller.\"\"\"\n\n    def __init__(\n        self,\n        parent: QWidget,\n        text: str,\n        action: UserAction,\n        controller: LearningSystemController,\n        responsive_text_handler: Optional[responsive_text_handler_type],\n    ):\n        \"\"\"Initialise the Button widget.\n\n        Args:\n            parent (QWidget): the parent of this widget\n            text (str): the text to display\n            action (UserAction): the action this button should perform when\n                pressed.\n            controller (LearningSystemController): the controller to notify.\n            responsive_text_handler (Optional[responsive_text_handler_type]): an\n                additional property that can be provided to update the text\n                dynamically.\n        \"\"\"\n        super().__init__(text, parent)\n        self.action = action\n        self.controller = controller\n\n        self.clicked.connect(self.__click_handler)\n\n        self.responsive_text_handler = responsive_text_handler\n\n    @override\n    def state_updated(self, state: StateDescription) -&gt; None:\n        \"\"\"Handle state update events.\n\n        Args:\n            state (StateDescription): the new state\n        \"\"\"\n        if self.responsive_text_handler is not None:\n            text = self.responsive_text_handler(state)\n            self.setText(text)\n\n    def __click_handler(self) -&gt; None:\n        \"\"\"Update the controller when a click is registered.\"\"\"\n        self.controller.user_action_bridge.submit_action(self.action)\n</code></pre>"},{"location":"reference/view/controls/custom_button_widget/#src.view.controls.custom_button_widget.CustomButtonWidget.__click_handler","title":"<code>__click_handler()</code>","text":"<p>Update the controller when a click is registered.</p> Source code in <code>src/view/controls/custom_button_widget.py</code> <pre><code>def __click_handler(self) -&gt; None:\n    \"\"\"Update the controller when a click is registered.\"\"\"\n    self.controller.user_action_bridge.submit_action(self.action)\n</code></pre>"},{"location":"reference/view/controls/custom_button_widget/#src.view.controls.custom_button_widget.CustomButtonWidget.__init__","title":"<code>__init__(parent, text, action, controller, responsive_text_handler)</code>","text":"<p>Initialise the Button widget.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>the parent of this widget</p> required <code>text</code> <code>str</code> <p>the text to display</p> required <code>action</code> <code>UserAction</code> <p>the action this button should perform when pressed.</p> required <code>controller</code> <code>LearningSystemController</code> <p>the controller to notify.</p> required <code>responsive_text_handler</code> <code>Optional[responsive_text_handler_type]</code> <p>an additional property that can be provided to update the text dynamically.</p> required Source code in <code>src/view/controls/custom_button_widget.py</code> <pre><code>def __init__(\n    self,\n    parent: QWidget,\n    text: str,\n    action: UserAction,\n    controller: LearningSystemController,\n    responsive_text_handler: Optional[responsive_text_handler_type],\n):\n    \"\"\"Initialise the Button widget.\n\n    Args:\n        parent (QWidget): the parent of this widget\n        text (str): the text to display\n        action (UserAction): the action this button should perform when\n            pressed.\n        controller (LearningSystemController): the controller to notify.\n        responsive_text_handler (Optional[responsive_text_handler_type]): an\n            additional property that can be provided to update the text\n            dynamically.\n    \"\"\"\n    super().__init__(text, parent)\n    self.action = action\n    self.controller = controller\n\n    self.clicked.connect(self.__click_handler)\n\n    self.responsive_text_handler = responsive_text_handler\n</code></pre>"},{"location":"reference/view/controls/custom_button_widget/#src.view.controls.custom_button_widget.CustomButtonWidget.state_updated","title":"<code>state_updated(state)</code>","text":"<p>Handle state update events.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>StateDescription</code> <p>the new state</p> required Source code in <code>src/view/controls/custom_button_widget.py</code> <pre><code>@override\ndef state_updated(self, state: StateDescription) -&gt; None:\n    \"\"\"Handle state update events.\n\n    Args:\n        state (StateDescription): the new state\n    \"\"\"\n    if self.responsive_text_handler is not None:\n        text = self.responsive_text_handler(state)\n        self.setText(text)\n</code></pre>"},{"location":"reference/view/controls/custom_combo_widget/","title":"Custom Combo Widget","text":""},{"location":"reference/view/controls/custom_combo_widget/#src.view.controls.custom_combo_widget.ComboWidgetState","title":"<code>ComboWidgetState</code>  <code>dataclass</code>","text":"<p>             Bases: <code>object</code></p> <p>Class that represents the configuration of a combo box.</p> Source code in <code>src/view/controls/custom_combo_widget.py</code> <pre><code>@dataclass(frozen=True)\nclass ComboWidgetState(object):\n    \"\"\"Class that represents the configuration of a combo box.\"\"\"\n\n    options: Dict[str, Any]\n    selected_option: str\n    enabled: bool = True\n</code></pre>"},{"location":"reference/view/controls/custom_combo_widget/#src.view.controls.custom_combo_widget.CustomComboWidget","title":"<code>CustomComboWidget</code>","text":"<p>             Bases: <code>QComboBox</code>, <code>BaseStateObserver</code></p> <p>Extension of a combo box widget to provide update functionality.</p> Source code in <code>src/view/controls/custom_combo_widget.py</code> <pre><code>class CustomComboWidget(QComboBox, BaseStateObserver):\n    \"\"\"Extension of a combo box widget to provide update functionality.\"\"\"\n\n    def __init__(\n        self,\n        parent: QWidget,\n        state: ComboWidgetState,\n        action: UserAction,\n        controller: LearningSystemController,\n        responsive_options_handler: Optional[handler_type] = None,\n    ) -&gt; None:\n        \"\"\"Initialise the combo box widget.\n\n        Args:\n            parent (QWidget): the parent widget this widget should be rendered\n                into.\n            state (ComboWidgetState): The configuration of the combo box.\n            action (UserAction): The user action this combo box corresponds to\n            controller (LearningSystemController): the controller to update when\n                the user selects something.\n            responsive_options_handler (Optional[handler_type]): an optional\n                handler to make this combo box responsive to state updates.\n        \"\"\"\n        super().__init__(parent)\n        self.state = state\n        self.__set_state(state)\n        self.action = action\n        self.controller = controller\n\n        self.responsive_options_handler = responsive_options_handler\n\n        self.currentTextChanged.connect(self.__update_handler)\n\n    @override\n    def state_updated(self, state: StateDescription) -&gt; None:\n        \"\"\"Handle state update events.\n\n        Args:\n            state (StateDescription): the new state\n        \"\"\"\n        if self.responsive_options_handler is not None:\n            combo_state = self.responsive_options_handler(state)\n            self.__set_state(combo_state)\n\n    def __update_handler(self, text: str) -&gt; None:\n        \"\"\"Handle update, send the appropriate request to the user.\n\n        Args:\n            text (str): the option that has been selected.\n        \"\"\"\n        self.controller.user_action_bridge.submit_action(\n            self.action, self.state.options[text]\n        )\n\n    def __set_state(self, state: ComboWidgetState):\n        self.state = state\n        self.addItems(list(state.options.keys()))\n        self.setCurrentText(state.selected_option)\n        self.setEnabled(state.enabled)\n</code></pre>"},{"location":"reference/view/controls/custom_combo_widget/#src.view.controls.custom_combo_widget.CustomComboWidget.__init__","title":"<code>__init__(parent, state, action, controller, responsive_options_handler=None)</code>","text":"<p>Initialise the combo box widget.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>the parent widget this widget should be rendered into.</p> required <code>state</code> <code>ComboWidgetState</code> <p>The configuration of the combo box.</p> required <code>action</code> <code>UserAction</code> <p>The user action this combo box corresponds to</p> required <code>controller</code> <code>LearningSystemController</code> <p>the controller to update when the user selects something.</p> required <code>responsive_options_handler</code> <code>Optional[handler_type]</code> <p>an optional handler to make this combo box responsive to state updates.</p> <code>None</code> Source code in <code>src/view/controls/custom_combo_widget.py</code> <pre><code>def __init__(\n    self,\n    parent: QWidget,\n    state: ComboWidgetState,\n    action: UserAction,\n    controller: LearningSystemController,\n    responsive_options_handler: Optional[handler_type] = None,\n) -&gt; None:\n    \"\"\"Initialise the combo box widget.\n\n    Args:\n        parent (QWidget): the parent widget this widget should be rendered\n            into.\n        state (ComboWidgetState): The configuration of the combo box.\n        action (UserAction): The user action this combo box corresponds to\n        controller (LearningSystemController): the controller to update when\n            the user selects something.\n        responsive_options_handler (Optional[handler_type]): an optional\n            handler to make this combo box responsive to state updates.\n    \"\"\"\n    super().__init__(parent)\n    self.state = state\n    self.__set_state(state)\n    self.action = action\n    self.controller = controller\n\n    self.responsive_options_handler = responsive_options_handler\n\n    self.currentTextChanged.connect(self.__update_handler)\n</code></pre>"},{"location":"reference/view/controls/custom_combo_widget/#src.view.controls.custom_combo_widget.CustomComboWidget.__update_handler","title":"<code>__update_handler(text)</code>","text":"<p>Handle update, send the appropriate request to the user.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>the option that has been selected.</p> required Source code in <code>src/view/controls/custom_combo_widget.py</code> <pre><code>def __update_handler(self, text: str) -&gt; None:\n    \"\"\"Handle update, send the appropriate request to the user.\n\n    Args:\n        text (str): the option that has been selected.\n    \"\"\"\n    self.controller.user_action_bridge.submit_action(\n        self.action, self.state.options[text]\n    )\n</code></pre>"},{"location":"reference/view/controls/custom_combo_widget/#src.view.controls.custom_combo_widget.CustomComboWidget.state_updated","title":"<code>state_updated(state)</code>","text":"<p>Handle state update events.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>StateDescription</code> <p>the new state</p> required Source code in <code>src/view/controls/custom_combo_widget.py</code> <pre><code>@override\ndef state_updated(self, state: StateDescription) -&gt; None:\n    \"\"\"Handle state update events.\n\n    Args:\n        state (StateDescription): the new state\n    \"\"\"\n    if self.responsive_options_handler is not None:\n        combo_state = self.responsive_options_handler(state)\n        self.__set_state(combo_state)\n</code></pre>"},{"location":"reference/view/grid_world_view_v2/","title":"Grid World View V2","text":"<p>This package allows you to display and interact with a grid world.</p>"},{"location":"reference/view/grid_world_view_v2/auto_speed_state_manager/","title":"Auto Speed State Manager","text":""},{"location":"reference/view/grid_world_view_v2/auto_speed_state_manager/#src.view.grid_world_view_v2.auto_speed_state_manager.AutoSpeed","title":"<code>AutoSpeed</code>","text":"<p>             Bases: <code>Enum</code></p> <p>Enumerates all possible auto speeds.</p> Source code in <code>src/view/grid_world_view_v2/auto_speed_state_manager.py</code> <pre><code>class AutoSpeed(Enum):\n    \"\"\"Enumerates all possible auto speeds.\"\"\"\n\n    manual = 0  # one step at a time\n    auto_local = 1  # step as fast as the states can be rendered\n    auto_full = 2  # full speed just show what states we can\n</code></pre>"},{"location":"reference/view/grid_world_view_v2/auto_speed_state_manager/#src.view.grid_world_view_v2.auto_speed_state_manager.AutoStateManager","title":"<code>AutoStateManager</code>","text":"<p>             Bases: <code>object</code></p> <p>Manages the state for the auto progress feature.</p> Source code in <code>src/view/grid_world_view_v2/auto_speed_state_manager.py</code> <pre><code>class AutoStateManager(object):\n    \"\"\"Manages the state for the auto progress feature.\"\"\"\n\n    auto_speed_ms = 300\n\n    progress_button_text = {\n        ProgressButtonMode.manual: \"Next\",\n        ProgressButtonMode.pause: \"Pause\",\n        ProgressButtonMode.restart: \"Start\",\n    }\n\n    def __init__(self, controller: LearningSystemController) -&gt; None:\n        \"\"\"Initialise the state manager.\n\n        initially in the manual mode\n\n        Args:\n            controller (LearningSystemController): update the controller with\n            the user's action.\n        \"\"\"\n        self.current_speed = AutoSpeed.manual\n        self.paused = False\n        self.auto_timer = QTimer()\n        self.auto_timer.timeout.connect(self.__one_step)\n        self.controller = controller\n\n    def set_speed(self, speed: AutoSpeed):\n        \"\"\"Set the current speed.\n\n        Args:\n            speed (AutoSpeed): the new speed (mode) to operate in.\n        \"\"\"\n        if speed is self.current_speed:\n            return\n\n        self.__stop_mode(self.current_speed)\n\n        self.paused = False\n\n        self.__start_mode(speed)\n        self.current_speed = speed\n\n    def progress_button_pressed(self):\n        \"\"\"Handle the progress button being pressed.\n\n        the action performed by this depends on the mode of the button.\n\n        \"\"\"\n        match self.__progress_button_mode():\n            case ProgressButtonMode.manual:\n                self.__one_step()\n            case ProgressButtonMode.pause:\n                self.__stop_mode(self.current_speed)\n                self.paused = True\n            case ProgressButtonMode.restart:\n                self.__start_mode(self.current_speed)\n                self.paused = False\n\n    def get_progress_button_text(self) -&gt; str:\n        \"\"\"Get the label for the progress button.\n\n        This indicates to the user what this button will perform.\n\n        Returns:\n            str: the current label for the button.\n        \"\"\"\n        return self.progress_button_text[self.__progress_button_mode()]\n\n    def __progress_button_mode(self) -&gt; ProgressButtonMode:\n        if self.current_speed is AutoSpeed.manual:\n            return ProgressButtonMode.manual\n\n        if self.paused:\n            return ProgressButtonMode.restart\n\n        return ProgressButtonMode.pause\n\n    def __one_step(self):\n        self.controller.user_action_bridge.submit_action(UserAction.one_step)\n\n    def __stop_mode(self, mode: AutoSpeed):\n        match mode:\n            case AutoSpeed.auto_local:\n                self.auto_timer.stop()\n            case AutoSpeed.auto_full:\n                self.controller.user_action_bridge.submit_action(\n                    UserAction.stop_auto\n                )\n\n    def __start_mode(self, mode: AutoSpeed):\n        match mode:\n            case AutoSpeed.auto_local:\n                self.auto_timer.start(self.auto_speed_ms)\n            case AutoSpeed.auto_full:\n                self.controller.user_action_bridge.submit_action(\n                    UserAction.start_auto\n                )\n</code></pre>"},{"location":"reference/view/grid_world_view_v2/auto_speed_state_manager/#src.view.grid_world_view_v2.auto_speed_state_manager.AutoStateManager.__init__","title":"<code>__init__(controller)</code>","text":"<p>Initialise the state manager.</p> <p>initially in the manual mode</p> <p>Parameters:</p> Name Type Description Default <code>controller</code> <code>LearningSystemController</code> <p>update the controller with</p> required Source code in <code>src/view/grid_world_view_v2/auto_speed_state_manager.py</code> <pre><code>def __init__(self, controller: LearningSystemController) -&gt; None:\n    \"\"\"Initialise the state manager.\n\n    initially in the manual mode\n\n    Args:\n        controller (LearningSystemController): update the controller with\n        the user's action.\n    \"\"\"\n    self.current_speed = AutoSpeed.manual\n    self.paused = False\n    self.auto_timer = QTimer()\n    self.auto_timer.timeout.connect(self.__one_step)\n    self.controller = controller\n</code></pre>"},{"location":"reference/view/grid_world_view_v2/auto_speed_state_manager/#src.view.grid_world_view_v2.auto_speed_state_manager.AutoStateManager.get_progress_button_text","title":"<code>get_progress_button_text()</code>","text":"<p>Get the label for the progress button.</p> <p>This indicates to the user what this button will perform.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>the current label for the button.</p> Source code in <code>src/view/grid_world_view_v2/auto_speed_state_manager.py</code> <pre><code>def get_progress_button_text(self) -&gt; str:\n    \"\"\"Get the label for the progress button.\n\n    This indicates to the user what this button will perform.\n\n    Returns:\n        str: the current label for the button.\n    \"\"\"\n    return self.progress_button_text[self.__progress_button_mode()]\n</code></pre>"},{"location":"reference/view/grid_world_view_v2/auto_speed_state_manager/#src.view.grid_world_view_v2.auto_speed_state_manager.AutoStateManager.progress_button_pressed","title":"<code>progress_button_pressed()</code>","text":"<p>Handle the progress button being pressed.</p> <p>the action performed by this depends on the mode of the button.</p> Source code in <code>src/view/grid_world_view_v2/auto_speed_state_manager.py</code> <pre><code>def progress_button_pressed(self):\n    \"\"\"Handle the progress button being pressed.\n\n    the action performed by this depends on the mode of the button.\n\n    \"\"\"\n    match self.__progress_button_mode():\n        case ProgressButtonMode.manual:\n            self.__one_step()\n        case ProgressButtonMode.pause:\n            self.__stop_mode(self.current_speed)\n            self.paused = True\n        case ProgressButtonMode.restart:\n            self.__start_mode(self.current_speed)\n            self.paused = False\n</code></pre>"},{"location":"reference/view/grid_world_view_v2/auto_speed_state_manager/#src.view.grid_world_view_v2.auto_speed_state_manager.AutoStateManager.set_speed","title":"<code>set_speed(speed)</code>","text":"<p>Set the current speed.</p> <p>Parameters:</p> Name Type Description Default <code>speed</code> <code>AutoSpeed</code> <p>the new speed (mode) to operate in.</p> required Source code in <code>src/view/grid_world_view_v2/auto_speed_state_manager.py</code> <pre><code>def set_speed(self, speed: AutoSpeed):\n    \"\"\"Set the current speed.\n\n    Args:\n        speed (AutoSpeed): the new speed (mode) to operate in.\n    \"\"\"\n    if speed is self.current_speed:\n        return\n\n    self.__stop_mode(self.current_speed)\n\n    self.paused = False\n\n    self.__start_mode(speed)\n    self.current_speed = speed\n</code></pre>"},{"location":"reference/view/grid_world_view_v2/auto_speed_state_manager/#src.view.grid_world_view_v2.auto_speed_state_manager.ProgressButtonMode","title":"<code>ProgressButtonMode</code>","text":"<p>             Bases: <code>Enum</code></p> <p>Enumerates all the different modes of the progress button.</p> Source code in <code>src/view/grid_world_view_v2/auto_speed_state_manager.py</code> <pre><code>class ProgressButtonMode(Enum):\n    \"\"\"Enumerates all the different modes of the progress button.\"\"\"\n\n    manual = 0\n    pause = 1\n    restart = 2\n</code></pre>"},{"location":"reference/view/grid_world_view_v2/grid_world_v2/","title":"Grid World V2","text":""},{"location":"reference/view/grid_world_view_v2/grid_world_v2/#src.view.grid_world_view_v2.grid_world_v2.GridWorld","title":"<code>GridWorld</code>","text":"<p>             Bases: <code>QWidget</code>, <code>BaseStateObserver</code></p> <p>This component combines a display with its controls.</p> <p>this widget represents a complete interface grid based agents.</p> Source code in <code>src/view/grid_world_view_v2/grid_world_v2.py</code> <pre><code>class GridWorld(QWidget, BaseStateObserver):\n    \"\"\"This component combines a display with its controls.\n\n    this widget represents a complete interface grid based agents.\n    \"\"\"\n\n    def __init__(\n        self, parent: Optional[QWidget], controller: LearningSystemController\n    ) -&gt; None:\n        \"\"\"Initialise the grid world agent.\n\n        Args:\n            parent (Optional[QWidget]): the parent widget this view should be\n                mounted within.\n            controller (LearningSystemController): Notify this controller when\n                the user selects controls.\n        \"\"\"\n        super().__init__(parent)\n        layout = QGridLayout(self)\n\n        self.display = DisplayState(self)\n        layout.addWidget(self.display, 0, 0)\n        layout.setRowStretch(0, 1)\n\n        self.controls = InteractionControls(self, controller)\n        layout.addWidget(self.controls, 1, 0)\n\n    @override\n    def state_updated(self, state: StateDescription):\n        \"\"\"Handle state update events.\n\n        Args:\n            state (StateDescription): the new state\n\n        \"\"\"\n        self.display.set_state(state)\n</code></pre>"},{"location":"reference/view/grid_world_view_v2/grid_world_v2/#src.view.grid_world_view_v2.grid_world_v2.GridWorld.__init__","title":"<code>__init__(parent, controller)</code>","text":"<p>Initialise the grid world agent.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>Optional[QWidget]</code> <p>the parent widget this view should be mounted within.</p> required <code>controller</code> <code>LearningSystemController</code> <p>Notify this controller when the user selects controls.</p> required Source code in <code>src/view/grid_world_view_v2/grid_world_v2.py</code> <pre><code>def __init__(\n    self, parent: Optional[QWidget], controller: LearningSystemController\n) -&gt; None:\n    \"\"\"Initialise the grid world agent.\n\n    Args:\n        parent (Optional[QWidget]): the parent widget this view should be\n            mounted within.\n        controller (LearningSystemController): Notify this controller when\n            the user selects controls.\n    \"\"\"\n    super().__init__(parent)\n    layout = QGridLayout(self)\n\n    self.display = DisplayState(self)\n    layout.addWidget(self.display, 0, 0)\n    layout.setRowStretch(0, 1)\n\n    self.controls = InteractionControls(self, controller)\n    layout.addWidget(self.controls, 1, 0)\n</code></pre>"},{"location":"reference/view/grid_world_view_v2/grid_world_v2/#src.view.grid_world_view_v2.grid_world_v2.GridWorld.state_updated","title":"<code>state_updated(state)</code>","text":"<p>Handle state update events.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>StateDescription</code> <p>the new state</p> required Source code in <code>src/view/grid_world_view_v2/grid_world_v2.py</code> <pre><code>@override\ndef state_updated(self, state: StateDescription):\n    \"\"\"Handle state update events.\n\n    Args:\n        state (StateDescription): the new state\n\n    \"\"\"\n    self.display.set_state(state)\n</code></pre>"},{"location":"reference/view/grid_world_view_v2/interaction_controls/","title":"Interaction Controls","text":""},{"location":"reference/view/grid_world_view_v2/interaction_controls/#src.view.grid_world_view_v2.interaction_controls.InteractionControls","title":"<code>InteractionControls</code>","text":"<p>             Bases: <code>QGroupBox</code></p> <p>Widget that contains the controls for interacting with the grid world.</p> Source code in <code>src/view/grid_world_view_v2/interaction_controls.py</code> <pre><code>class InteractionControls(QGroupBox):\n    \"\"\"Widget that contains the controls for interacting with the grid world.\"\"\"\n\n    display_mode_options = {\n        \"default\": DisplayMode.default,\n        \"best action\": DisplayMode.best_action,\n        \"state value\": DisplayMode.state_value,\n        \"action value\": DisplayMode.action_value_global,\n        \"action value local\": DisplayMode.action_value_local,\n    }\n\n    auto_speed_options = {\n        \"Manual\": AutoSpeed.manual,\n        \"Auto\": AutoSpeed.auto_local,\n        \"Fast\": AutoSpeed.auto_full,\n    }\n\n    group_title = \"Simulation Interaction Controls\"\n\n    def __init__(\n        self, parent: QWidget, controller: LearningSystemController\n    ) -&gt; None:\n        \"\"\"Initialise the controls.\n\n        Args:\n            parent (QWidget): the parent of this widget.\n            controller (LearningSystemController): the channel to notify the\n                controller of the users actions.\n        \"\"\"\n        super().__init__(self.group_title, parent)\n\n        self.controller = controller\n\n        layout = QGridLayout(self)\n\n        self.__add_display_mode(layout)\n\n        self.__add_reset_button(layout)\n\n        self.__add_auto_speed_toggles(layout)\n\n        self.auto_mode_manger = AutoStateManager(controller)\n\n        self.progress_button = QPushButton(\n            self.auto_mode_manger.get_progress_button_text()\n        )\n        self.progress_button.clicked.connect(self.progress_button_pressed)\n        layout.addWidget(self.progress_button, 0, 3)\n\n    def reset_button_pressed(self):\n        \"\"\"When the reset button is pressed. reset the state.\"\"\"\n        self.controller.user_action_bridge.submit_action(UserAction.reset_state)\n\n    def progress_button_pressed(self):\n        \"\"\"When the next button is presses step the state forward.\"\"\"\n        self.auto_mode_manger.progress_button_pressed()\n        self.progress_button.setText(\n            self.auto_mode_manger.get_progress_button_text()\n        )\n\n    def auto_speed_toggled(self, option: str):\n        \"\"\"Handle when new speed is selected.\n\n        Args:\n            option (str): the new speed to operate.\n        \"\"\"\n        auto_speed = self.auto_speed_options[option]\n        self.auto_mode_manger.set_speed(auto_speed)\n        self.progress_button.setText(\n            self.auto_mode_manger.get_progress_button_text()\n        )\n\n    def display_mode_toggled(self, option: str):\n        \"\"\"When the display mode option menu is selected.\n\n        Args:\n            option (str): the mode selected\n        \"\"\"\n        display_mode = self.display_mode_options[option]\n        self.controller.user_action_bridge.submit_action(\n            UserAction.set_display_mode, display_mode\n        )\n\n    def __add_display_mode(self, layout: QGridLayout):\n        display_mode = QComboBox()\n        display_mode.addItems(list(self.display_mode_options.keys()))\n        display_mode.currentTextChanged.connect(self.display_mode_toggled)\n        layout.addWidget(display_mode, 0, 0)\n\n    def __add_reset_button(self, layout: QGridLayout):\n        reset_button = QPushButton(\"Reset\")\n        reset_button.clicked.connect(self.reset_button_pressed)\n        layout.addWidget(reset_button, 0, 1)\n\n    def __add_auto_speed_toggles(self, layout: QGridLayout):\n        auto_speed = QComboBox()\n        auto_speed.addItems(list(self.auto_speed_options.keys()))\n        auto_speed.currentTextChanged.connect(self.auto_speed_toggled)\n        layout.addWidget(auto_speed, 0, 2)\n</code></pre>"},{"location":"reference/view/grid_world_view_v2/interaction_controls/#src.view.grid_world_view_v2.interaction_controls.InteractionControls.__init__","title":"<code>__init__(parent, controller)</code>","text":"<p>Initialise the controls.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>the parent of this widget.</p> required <code>controller</code> <code>LearningSystemController</code> <p>the channel to notify the controller of the users actions.</p> required Source code in <code>src/view/grid_world_view_v2/interaction_controls.py</code> <pre><code>def __init__(\n    self, parent: QWidget, controller: LearningSystemController\n) -&gt; None:\n    \"\"\"Initialise the controls.\n\n    Args:\n        parent (QWidget): the parent of this widget.\n        controller (LearningSystemController): the channel to notify the\n            controller of the users actions.\n    \"\"\"\n    super().__init__(self.group_title, parent)\n\n    self.controller = controller\n\n    layout = QGridLayout(self)\n\n    self.__add_display_mode(layout)\n\n    self.__add_reset_button(layout)\n\n    self.__add_auto_speed_toggles(layout)\n\n    self.auto_mode_manger = AutoStateManager(controller)\n\n    self.progress_button = QPushButton(\n        self.auto_mode_manger.get_progress_button_text()\n    )\n    self.progress_button.clicked.connect(self.progress_button_pressed)\n    layout.addWidget(self.progress_button, 0, 3)\n</code></pre>"},{"location":"reference/view/grid_world_view_v2/interaction_controls/#src.view.grid_world_view_v2.interaction_controls.InteractionControls.auto_speed_toggled","title":"<code>auto_speed_toggled(option)</code>","text":"<p>Handle when new speed is selected.</p> <p>Parameters:</p> Name Type Description Default <code>option</code> <code>str</code> <p>the new speed to operate.</p> required Source code in <code>src/view/grid_world_view_v2/interaction_controls.py</code> <pre><code>def auto_speed_toggled(self, option: str):\n    \"\"\"Handle when new speed is selected.\n\n    Args:\n        option (str): the new speed to operate.\n    \"\"\"\n    auto_speed = self.auto_speed_options[option]\n    self.auto_mode_manger.set_speed(auto_speed)\n    self.progress_button.setText(\n        self.auto_mode_manger.get_progress_button_text()\n    )\n</code></pre>"},{"location":"reference/view/grid_world_view_v2/interaction_controls/#src.view.grid_world_view_v2.interaction_controls.InteractionControls.display_mode_toggled","title":"<code>display_mode_toggled(option)</code>","text":"<p>When the display mode option menu is selected.</p> <p>Parameters:</p> Name Type Description Default <code>option</code> <code>str</code> <p>the mode selected</p> required Source code in <code>src/view/grid_world_view_v2/interaction_controls.py</code> <pre><code>def display_mode_toggled(self, option: str):\n    \"\"\"When the display mode option menu is selected.\n\n    Args:\n        option (str): the mode selected\n    \"\"\"\n    display_mode = self.display_mode_options[option]\n    self.controller.user_action_bridge.submit_action(\n        UserAction.set_display_mode, display_mode\n    )\n</code></pre>"},{"location":"reference/view/grid_world_view_v2/interaction_controls/#src.view.grid_world_view_v2.interaction_controls.InteractionControls.progress_button_pressed","title":"<code>progress_button_pressed()</code>","text":"<p>When the next button is presses step the state forward.</p> Source code in <code>src/view/grid_world_view_v2/interaction_controls.py</code> <pre><code>def progress_button_pressed(self):\n    \"\"\"When the next button is presses step the state forward.\"\"\"\n    self.auto_mode_manger.progress_button_pressed()\n    self.progress_button.setText(\n        self.auto_mode_manger.get_progress_button_text()\n    )\n</code></pre>"},{"location":"reference/view/grid_world_view_v2/interaction_controls/#src.view.grid_world_view_v2.interaction_controls.InteractionControls.reset_button_pressed","title":"<code>reset_button_pressed()</code>","text":"<p>When the reset button is pressed. reset the state.</p> Source code in <code>src/view/grid_world_view_v2/interaction_controls.py</code> <pre><code>def reset_button_pressed(self):\n    \"\"\"When the reset button is pressed. reset the state.\"\"\"\n    self.controller.user_action_bridge.submit_action(UserAction.reset_state)\n</code></pre>"},{"location":"reference/view/grid_world_view_v2/display_state_v2/","title":"Display State V2","text":"<p>This package provides the code needed to render the grid world.</p> <p>It contains the top level widget to display this grid world scene to the user.</p>"},{"location":"reference/view/grid_world_view_v2/display_state_v2/display/","title":"Display","text":""},{"location":"reference/view/grid_world_view_v2/display_state_v2/display/#src.view.grid_world_view_v2.display_state_v2.display.DisplayState","title":"<code>DisplayState</code>","text":"<p>             Bases: <code>QWidget</code></p> <p>Widget for displaying a given grid world state.</p> Source code in <code>src/view/grid_world_view_v2/display_state_v2/display.py</code> <pre><code>class DisplayState(QWidget):\n    \"\"\"Widget for displaying a given grid world state.\"\"\"\n\n    cell_margins = 0.1\n    background_color = (200, 200, 200, 0)\n\n    def __init__(self, parent: Optional[QWidget]) -&gt; None:\n        \"\"\"Initialise the state display.\n\n        this widget will display a given state and update it on request.\n\n        Args:\n            parent (QWidget): the parent of this widget.\n        \"\"\"\n        super().__init__(parent)\n\n        self.image_label = QLabel(self)\n        self.image_label.setContentsMargins(0, 0, 0, 0)\n        self.image_label.setStyleSheet(\"border: 0;\")\n        self.setContentsMargins(0, 0, 0, 0)\n\n        layout = QGridLayout(self)\n        layout.setSpacing(0)\n        layout.setContentsMargins(0, 0, 0, 0)\n        layout.addWidget(self.image_label, 0, 0)\n\n        self.state: Optional[StateDescription] = None\n\n    def set_state(self, state: StateDescription):\n        \"\"\"Set the state to be displayed.\n\n        Args:\n            state (StateDescription): the state to be displayed\n        \"\"\"\n        self.state = state\n        self.__configure_grid()\n\n    @override\n    def resizeEvent(  # noqa: N802 built in method to base class\n        self, event: QResizeEvent\n    ):\n        \"\"\"Handle resize event.\n\n        resize the inner grid based upon the updated dimensions.\n\n        Args:\n            event (QResizeEvent): the resize event\n        \"\"\"\n        self.__configure_grid()\n\n    def __make_blank_image(self):\n        size = self.__get_current_size()\n        image_mode = \"RGBA\"\n        image = Image.new(image_mode, size, self.background_color)\n        image_draw = ImageDraw.Draw(image, image_mode)\n        return image, image_draw\n\n    def __configure_grid(self):\n        if self.state is None:\n            return\n        width, height = self.__get_current_size()\n        expected_cell_size = self.state.grid_world.get_cell_sizing(\n            width, height, self.cell_margins\n        )[0]\n        if expected_cell_size &lt; 10:\n            # cells are too small\n            return\n        self.__populate_cells(self.state)\n        image, image_draw = self.__make_blank_image()\n\n        for cell in self.cells.values():\n            cell.draw(image, image_draw)\n\n        self.image_label.setPixmap(QPixmap.fromImage(ImageQt(image)))\n\n    def __populate_cells(\n        self,\n        state: StateDescription,\n    ):\n        self.cells = {}\n        width, height = self.__get_current_size()\n        cell_positions = state.grid_world.list_cell_positions(\n            width, height, self.cell_margins\n        )\n\n        for cell_position in cell_positions:\n            (\n                cell_coordinate,\n                bounding_box,\n            ) = cell_position\n            self.cells[cell_coordinate] = Cell(\n                state.global_options,\n                state.cell_config[cell_coordinate],\n                bounding_box,\n            )\n\n    def __get_current_size(self):\n        width = self.image_label.contentsRect().width() - 2\n        height = self.image_label.contentsRect().height() - 2\n        return width, height\n</code></pre>"},{"location":"reference/view/grid_world_view_v2/display_state_v2/display/#src.view.grid_world_view_v2.display_state_v2.display.DisplayState.__init__","title":"<code>__init__(parent)</code>","text":"<p>Initialise the state display.</p> <p>this widget will display a given state and update it on request.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>the parent of this widget.</p> required Source code in <code>src/view/grid_world_view_v2/display_state_v2/display.py</code> <pre><code>def __init__(self, parent: Optional[QWidget]) -&gt; None:\n    \"\"\"Initialise the state display.\n\n    this widget will display a given state and update it on request.\n\n    Args:\n        parent (QWidget): the parent of this widget.\n    \"\"\"\n    super().__init__(parent)\n\n    self.image_label = QLabel(self)\n    self.image_label.setContentsMargins(0, 0, 0, 0)\n    self.image_label.setStyleSheet(\"border: 0;\")\n    self.setContentsMargins(0, 0, 0, 0)\n\n    layout = QGridLayout(self)\n    layout.setSpacing(0)\n    layout.setContentsMargins(0, 0, 0, 0)\n    layout.addWidget(self.image_label, 0, 0)\n\n    self.state: Optional[StateDescription] = None\n</code></pre>"},{"location":"reference/view/grid_world_view_v2/display_state_v2/display/#src.view.grid_world_view_v2.display_state_v2.display.DisplayState.resizeEvent","title":"<code>resizeEvent(event)</code>","text":"<p>Handle resize event.</p> <p>resize the inner grid based upon the updated dimensions.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>QResizeEvent</code> <p>the resize event</p> required Source code in <code>src/view/grid_world_view_v2/display_state_v2/display.py</code> <pre><code>@override\ndef resizeEvent(  # noqa: N802 built in method to base class\n    self, event: QResizeEvent\n):\n    \"\"\"Handle resize event.\n\n    resize the inner grid based upon the updated dimensions.\n\n    Args:\n        event (QResizeEvent): the resize event\n    \"\"\"\n    self.__configure_grid()\n</code></pre>"},{"location":"reference/view/grid_world_view_v2/display_state_v2/display/#src.view.grid_world_view_v2.display_state_v2.display.DisplayState.set_state","title":"<code>set_state(state)</code>","text":"<p>Set the state to be displayed.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>StateDescription</code> <p>the state to be displayed</p> required Source code in <code>src/view/grid_world_view_v2/display_state_v2/display.py</code> <pre><code>def set_state(self, state: StateDescription):\n    \"\"\"Set the state to be displayed.\n\n    Args:\n        state (StateDescription): the state to be displayed\n    \"\"\"\n    self.state = state\n    self.__configure_grid()\n</code></pre>"},{"location":"reference/view/grid_world_view_v2/display_state_v2/cell/","title":"Cell","text":"<p>This package is for the drawing of a cell in the grid world view.</p>"},{"location":"reference/view/grid_world_view_v2/display_state_v2/cell/arrow_layer/","title":"Arrow Layer","text":""},{"location":"reference/view/grid_world_view_v2/display_state_v2/cell/arrow_layer/#src.view.grid_world_view_v2.display_state_v2.cell.arrow_layer.ArrowLayer","title":"<code>ArrowLayer</code>","text":"<p>             Bases: <code>BaseLayer</code></p> <p>The layer responsible for drawing the background of the cell.</p> Source code in <code>src/view/grid_world_view_v2/display_state_v2/cell/arrow_layer.py</code> <pre><code>class ArrowLayer(BaseLayer):\n    \"\"\"The layer responsible for drawing the background of the cell.\"\"\"\n\n    def draw(self):\n        \"\"\"Draw the arrow layer.\"\"\"\n        match self.options.display_mode:\n            case DisplayMode.action_value_global:\n                self.__draw_specific_arrows(\n                    self.config.action_values_normalised\n                )\n            case DisplayMode.action_value_local:\n                self.__draw_specific_arrows(\n                    self.__rescale_values_locally(\n                        self.config.action_values_raw\n                    ),\n                )\n            case _:\n                return\n\n    def __draw_specific_arrows(self, action_values: action_value_description):\n        for action, action_value in action_values.items():\n            if action_value is not None:\n                self.__draw_arrow(action, action_value)\n\n    def __draw_arrow(self, action: Action, action_value: float):\n        size = self.cell_layout.get_bounding_box_size(self.bounding_box) // 3\n        color = self.value_to_color(action_value)\n        icon = self.icon_loader.get_action_icon(action, size, color)\n\n        dir_x, dir_y = GridWorld.action_direction[action]\n\n        relative_position = ((dir_x + 1) / 2, (dir_y + 1) / 2)\n        self.draw_icon(icon, size, relative_position)\n\n    def __rescale_values_locally(\n        self, action_values: action_value_description\n    ) -&gt; action_value_description:\n        \"\"\"Rescale the action values in this cell 0-1.\n\n        this should only be based on the values in this cell rather than the\n        global range of values.\n\n        Args:\n            action_values (action_value_description): the action values of this\n                cell.\n\n        Returns:\n            action_value_description: the scaled action values in the range 0-1\n        \"\"\"\n        min_value = float(\"inf\")\n        max_value = float(\"-inf\")\n\n        for action_value in action_values.values():\n            if action_value is None:\n                continue\n            min_value = min(action_value, min_value)\n            max_value = max(action_value, max_value)\n\n        rescaled_values: action_value_description = {}\n        value_range = max_value - min_value\n        for action, action_value in action_values.items():\n            if action_value is None:\n                rescaled_values[action] = None\n                continue\n            rescaled_values[action] = (action_value - min_value) / value_range\n        return rescaled_values\n</code></pre>"},{"location":"reference/view/grid_world_view_v2/display_state_v2/cell/arrow_layer/#src.view.grid_world_view_v2.display_state_v2.cell.arrow_layer.ArrowLayer.__rescale_values_locally","title":"<code>__rescale_values_locally(action_values)</code>","text":"<p>Rescale the action values in this cell 0-1.</p> <p>this should only be based on the values in this cell rather than the global range of values.</p> <p>Parameters:</p> Name Type Description Default <code>action_values</code> <code>action_value_description</code> <p>the action values of this cell.</p> required <p>Returns:</p> Name Type Description <code>action_value_description</code> <code>action_value_description</code> <p>the scaled action values in the range 0-1</p> Source code in <code>src/view/grid_world_view_v2/display_state_v2/cell/arrow_layer.py</code> <pre><code>def __rescale_values_locally(\n    self, action_values: action_value_description\n) -&gt; action_value_description:\n    \"\"\"Rescale the action values in this cell 0-1.\n\n    this should only be based on the values in this cell rather than the\n    global range of values.\n\n    Args:\n        action_values (action_value_description): the action values of this\n            cell.\n\n    Returns:\n        action_value_description: the scaled action values in the range 0-1\n    \"\"\"\n    min_value = float(\"inf\")\n    max_value = float(\"-inf\")\n\n    for action_value in action_values.values():\n        if action_value is None:\n            continue\n        min_value = min(action_value, min_value)\n        max_value = max(action_value, max_value)\n\n    rescaled_values: action_value_description = {}\n    value_range = max_value - min_value\n    for action, action_value in action_values.items():\n        if action_value is None:\n            rescaled_values[action] = None\n            continue\n        rescaled_values[action] = (action_value - min_value) / value_range\n    return rescaled_values\n</code></pre>"},{"location":"reference/view/grid_world_view_v2/display_state_v2/cell/arrow_layer/#src.view.grid_world_view_v2.display_state_v2.cell.arrow_layer.ArrowLayer.draw","title":"<code>draw()</code>","text":"<p>Draw the arrow layer.</p> Source code in <code>src/view/grid_world_view_v2/display_state_v2/cell/arrow_layer.py</code> <pre><code>def draw(self):\n    \"\"\"Draw the arrow layer.\"\"\"\n    match self.options.display_mode:\n        case DisplayMode.action_value_global:\n            self.__draw_specific_arrows(\n                self.config.action_values_normalised\n            )\n        case DisplayMode.action_value_local:\n            self.__draw_specific_arrows(\n                self.__rescale_values_locally(\n                    self.config.action_values_raw\n                ),\n            )\n        case _:\n            return\n</code></pre>"},{"location":"reference/view/grid_world_view_v2/display_state_v2/cell/background_layer/","title":"Background Layer","text":""},{"location":"reference/view/grid_world_view_v2/display_state_v2/cell/background_layer/#src.view.grid_world_view_v2.display_state_v2.cell.background_layer.BackgroundLayer","title":"<code>BackgroundLayer</code>","text":"<p>             Bases: <code>BaseLayer</code></p> <p>The layer responsible for drawing the background of the cell.</p> Source code in <code>src/view/grid_world_view_v2/display_state_v2/cell/background_layer.py</code> <pre><code>class BackgroundLayer(BaseLayer):\n    \"\"\"The layer responsible for drawing the background of the cell.\"\"\"\n\n    default_background_color: rgb_type = (80, 80, 80)\n\n    def draw(self):\n        \"\"\"Draw the background layer.\"\"\"\n        fill, outline = self.__cell_mode_color()\n\n        self.drawing_context.rounded_rectangle(\n            self.bounding_box,\n            self.cell_layout.border_width,\n            fill=fill,\n            outline=outline,\n            width=self.cell_layout.border_width,\n        )\n\n    def __cell_mode_color(\n        self,\n    ) -&gt; Tuple[rgb_type, rgb_type]:\n        \"\"\"Get the color for the inner and outer background based on the mode.\n\n        Returns:\n            Tuple[str, str]: inner and outer color\n        \"\"\"\n        default_color = self.default_background_color\n        if self.options.display_mode is not DisplayMode.state_value:\n            return default_color, default_color\n        cell_value_color = self.__cell_color()\n\n        if self.config.cell_entity is CellEntity.empty:\n            return cell_value_color, cell_value_color\n\n        return default_color, cell_value_color\n\n    def __cell_color(self) -&gt; rgb_type:\n        \"\"\"Get the color the cell should be based upon the value.\n\n        red represents a low value and green represents a good value\n\n        Returns:\n            rgb_type: the hex color of the cell based on this value.\n        \"\"\"\n        cell_value = self.config.cell_value_normalised\n        if cell_value is None:\n            return self.default_background_color\n        return self.value_to_color(cell_value)\n</code></pre>"},{"location":"reference/view/grid_world_view_v2/display_state_v2/cell/background_layer/#src.view.grid_world_view_v2.display_state_v2.cell.background_layer.BackgroundLayer.__cell_color","title":"<code>__cell_color()</code>","text":"<p>Get the color the cell should be based upon the value.</p> <p>red represents a low value and green represents a good value</p> <p>Returns:</p> Name Type Description <code>rgb_type</code> <code>rgb_type</code> <p>the hex color of the cell based on this value.</p> Source code in <code>src/view/grid_world_view_v2/display_state_v2/cell/background_layer.py</code> <pre><code>def __cell_color(self) -&gt; rgb_type:\n    \"\"\"Get the color the cell should be based upon the value.\n\n    red represents a low value and green represents a good value\n\n    Returns:\n        rgb_type: the hex color of the cell based on this value.\n    \"\"\"\n    cell_value = self.config.cell_value_normalised\n    if cell_value is None:\n        return self.default_background_color\n    return self.value_to_color(cell_value)\n</code></pre>"},{"location":"reference/view/grid_world_view_v2/display_state_v2/cell/background_layer/#src.view.grid_world_view_v2.display_state_v2.cell.background_layer.BackgroundLayer.__cell_mode_color","title":"<code>__cell_mode_color()</code>","text":"<p>Get the color for the inner and outer background based on the mode.</p> <p>Returns:</p> Type Description <code>Tuple[rgb_type, rgb_type]</code> <p>Tuple[str, str]: inner and outer color</p> Source code in <code>src/view/grid_world_view_v2/display_state_v2/cell/background_layer.py</code> <pre><code>def __cell_mode_color(\n    self,\n) -&gt; Tuple[rgb_type, rgb_type]:\n    \"\"\"Get the color for the inner and outer background based on the mode.\n\n    Returns:\n        Tuple[str, str]: inner and outer color\n    \"\"\"\n    default_color = self.default_background_color\n    if self.options.display_mode is not DisplayMode.state_value:\n        return default_color, default_color\n    cell_value_color = self.__cell_color()\n\n    if self.config.cell_entity is CellEntity.empty:\n        return cell_value_color, cell_value_color\n\n    return default_color, cell_value_color\n</code></pre>"},{"location":"reference/view/grid_world_view_v2/display_state_v2/cell/background_layer/#src.view.grid_world_view_v2.display_state_v2.cell.background_layer.BackgroundLayer.draw","title":"<code>draw()</code>","text":"<p>Draw the background layer.</p> Source code in <code>src/view/grid_world_view_v2/display_state_v2/cell/background_layer.py</code> <pre><code>def draw(self):\n    \"\"\"Draw the background layer.\"\"\"\n    fill, outline = self.__cell_mode_color()\n\n    self.drawing_context.rounded_rectangle(\n        self.bounding_box,\n        self.cell_layout.border_width,\n        fill=fill,\n        outline=outline,\n        width=self.cell_layout.border_width,\n    )\n</code></pre>"},{"location":"reference/view/grid_world_view_v2/display_state_v2/cell/base_layer/","title":"Base Layer","text":""},{"location":"reference/view/grid_world_view_v2/display_state_v2/cell/base_layer/#src.view.grid_world_view_v2.display_state_v2.cell.base_layer.BaseLayer","title":"<code>BaseLayer</code>  <code>dataclass</code>","text":"<p>             Bases: <code>object</code></p> <p>Represents one layer of the cell's drawing.</p> Source code in <code>src/view/grid_world_view_v2/display_state_v2/cell/base_layer.py</code> <pre><code>@dataclass(slots=True, frozen=True)\nclass BaseLayer(object):\n    \"\"\"Represents one layer of the cell's drawing.\"\"\"\n\n    options: GlobalOptions\n    config: CellConfiguration\n    canvas: Image\n    drawing_context: ImageDraw\n    bounding_box: Tuple[int, int, int, int]\n    cell_layout: CellLayout\n    icon_loader = IconLoader()\n\n    def draw(self):\n        \"\"\"Draw this layer to the canvas.\n\n        Raises:\n            RuntimeError: if this method is not overridden.\n        \"\"\"\n        raise RuntimeError(\"Draw should be overridden by concrete class\")\n\n    def draw_icon(\n        self,\n        icon: Image,\n        size: int,\n        rel_pos: Tuple[float, float] = (0.5, 0.5),\n    ):\n        \"\"\"Draw an icon in the cell.\n\n        rel_pos is relative to the bounding box of this layer.\n\n        Args:\n            icon (Image): the icon to display\n            size (int): the size of the icon to display\n            rel_pos (Tuple[float, float], optional): the position in the cell.\n                Defaults to the centre.\n        \"\"\"\n        min_x, min_y, max_x, _max_y = self.bounding_box\n        rel_x, rel_y = rel_pos\n\n        space = max_x - min_x - size\n        location = (\n            min_x + int(rel_x * space),\n            min_y + int(rel_y * space),\n        )\n\n        icon_alpha = icon.getchannel(\"A\")\n        self.canvas.paste(icon, location, icon_alpha)\n\n    def value_to_color(self, worth: float) -&gt; rgb_type:\n        \"\"\"Convert a floating point value to a color.\n\n        Args:\n            worth (float): the value to represent in the range 0 to 1.\n\n        Returns:\n            rgb_type: the color as rgb values in the range 0-255\n        \"\"\"\n        hue = worth / 3  # Range from red to green\n        saturation = 1.0\n        lightness = 0.5\n        color_range = 255\n\n        red, green, blue = hls_to_rgb(hue, lightness, saturation)\n        return (\n            int(color_range * red),\n            int(color_range * green),\n            int(color_range * blue),\n        )\n</code></pre>"},{"location":"reference/view/grid_world_view_v2/display_state_v2/cell/base_layer/#src.view.grid_world_view_v2.display_state_v2.cell.base_layer.BaseLayer.draw","title":"<code>draw()</code>","text":"<p>Draw this layer to the canvas.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if this method is not overridden.</p> Source code in <code>src/view/grid_world_view_v2/display_state_v2/cell/base_layer.py</code> <pre><code>def draw(self):\n    \"\"\"Draw this layer to the canvas.\n\n    Raises:\n        RuntimeError: if this method is not overridden.\n    \"\"\"\n    raise RuntimeError(\"Draw should be overridden by concrete class\")\n</code></pre>"},{"location":"reference/view/grid_world_view_v2/display_state_v2/cell/base_layer/#src.view.grid_world_view_v2.display_state_v2.cell.base_layer.BaseLayer.draw_icon","title":"<code>draw_icon(icon, size, rel_pos=(0.5, 0.5))</code>","text":"<p>Draw an icon in the cell.</p> <p>rel_pos is relative to the bounding box of this layer.</p> <p>Parameters:</p> Name Type Description Default <code>icon</code> <code>Image</code> <p>the icon to display</p> required <code>size</code> <code>int</code> <p>the size of the icon to display</p> required <code>rel_pos</code> <code>Tuple[float, float]</code> <p>the position in the cell. Defaults to the centre.</p> <code>(0.5, 0.5)</code> Source code in <code>src/view/grid_world_view_v2/display_state_v2/cell/base_layer.py</code> <pre><code>def draw_icon(\n    self,\n    icon: Image,\n    size: int,\n    rel_pos: Tuple[float, float] = (0.5, 0.5),\n):\n    \"\"\"Draw an icon in the cell.\n\n    rel_pos is relative to the bounding box of this layer.\n\n    Args:\n        icon (Image): the icon to display\n        size (int): the size of the icon to display\n        rel_pos (Tuple[float, float], optional): the position in the cell.\n            Defaults to the centre.\n    \"\"\"\n    min_x, min_y, max_x, _max_y = self.bounding_box\n    rel_x, rel_y = rel_pos\n\n    space = max_x - min_x - size\n    location = (\n        min_x + int(rel_x * space),\n        min_y + int(rel_y * space),\n    )\n\n    icon_alpha = icon.getchannel(\"A\")\n    self.canvas.paste(icon, location, icon_alpha)\n</code></pre>"},{"location":"reference/view/grid_world_view_v2/display_state_v2/cell/base_layer/#src.view.grid_world_view_v2.display_state_v2.cell.base_layer.BaseLayer.value_to_color","title":"<code>value_to_color(worth)</code>","text":"<p>Convert a floating point value to a color.</p> <p>Parameters:</p> Name Type Description Default <code>worth</code> <code>float</code> <p>the value to represent in the range 0 to 1.</p> required <p>Returns:</p> Name Type Description <code>rgb_type</code> <code>rgb_type</code> <p>the color as rgb values in the range 0-255</p> Source code in <code>src/view/grid_world_view_v2/display_state_v2/cell/base_layer.py</code> <pre><code>def value_to_color(self, worth: float) -&gt; rgb_type:\n    \"\"\"Convert a floating point value to a color.\n\n    Args:\n        worth (float): the value to represent in the range 0 to 1.\n\n    Returns:\n        rgb_type: the color as rgb values in the range 0-255\n    \"\"\"\n    hue = worth / 3  # Range from red to green\n    saturation = 1.0\n    lightness = 0.5\n    color_range = 255\n\n    red, green, blue = hls_to_rgb(hue, lightness, saturation)\n    return (\n        int(color_range * red),\n        int(color_range * green),\n        int(color_range * blue),\n    )\n</code></pre>"},{"location":"reference/view/grid_world_view_v2/display_state_v2/cell/cell/","title":"Cell","text":""},{"location":"reference/view/grid_world_view_v2/display_state_v2/cell/cell/#src.view.grid_world_view_v2.display_state_v2.cell.cell.Cell","title":"<code>Cell</code>","text":"<p>             Bases: <code>object</code></p> <p>Widget to display an individual cell.</p> Source code in <code>src/view/grid_world_view_v2/display_state_v2/cell/cell.py</code> <pre><code>class Cell(object):\n    \"\"\"Widget to display an individual cell.\"\"\"\n\n    def __init__(\n        self,\n        options: GlobalOptions,\n        config: CellConfiguration,\n        bounding_box: Tuple[int, int, int, int],\n    ) -&gt; None:\n        \"\"\"Initialise the cell.\n\n        displays the cell as a rounded rectangle with icons.\n\n        Args:\n            options (GlobalOptions): the global configuration used in rendering\n                each cell.\n            config (CellConfiguration): the configuration of how this cell\n                should present.\n            bounding_box (Tuple[int, int, int, int]): the position and size of\n                this cell on the canvas.\n        \"\"\"\n        self.config = config\n        self.options = options\n        self.cell_layout = CellLayout(bounding_box)\n\n    def draw(\n        self,\n        canvas: Image,\n        drawing_context: ImageDraw,\n    ):\n        \"\"\"Draw the cell to the canvas.\n\n        Args:\n            canvas (Image): the image to draw to\n            drawing_context (ImageDraw): the drawing context\n        \"\"\"\n        BackgroundLayer(\n            self.options,\n            self.config,\n            canvas,\n            drawing_context,\n            self.cell_layout.bounding_box,\n            self.cell_layout,\n        ).draw()\n        MainIconLayer(\n            self.options,\n            self.config,\n            canvas,\n            drawing_context,\n            self.cell_layout.inset_bounding_box(\n                self.cell_layout.padding + self.cell_layout.border_width\n            ),\n            self.cell_layout,\n        ).draw()\n        ArrowLayer(\n            self.options,\n            self.config,\n            canvas,\n            drawing_context,\n            self.cell_layout.inset_bounding_box(self.cell_layout.padding),\n            self.cell_layout,\n        ).draw()\n</code></pre>"},{"location":"reference/view/grid_world_view_v2/display_state_v2/cell/cell/#src.view.grid_world_view_v2.display_state_v2.cell.cell.Cell.__init__","title":"<code>__init__(options, config, bounding_box)</code>","text":"<p>Initialise the cell.</p> <p>displays the cell as a rounded rectangle with icons.</p> <p>Parameters:</p> Name Type Description Default <code>options</code> <code>GlobalOptions</code> <p>the global configuration used in rendering each cell.</p> required <code>config</code> <code>CellConfiguration</code> <p>the configuration of how this cell should present.</p> required <code>bounding_box</code> <code>Tuple[int, int, int, int]</code> <p>the position and size of this cell on the canvas.</p> required Source code in <code>src/view/grid_world_view_v2/display_state_v2/cell/cell.py</code> <pre><code>def __init__(\n    self,\n    options: GlobalOptions,\n    config: CellConfiguration,\n    bounding_box: Tuple[int, int, int, int],\n) -&gt; None:\n    \"\"\"Initialise the cell.\n\n    displays the cell as a rounded rectangle with icons.\n\n    Args:\n        options (GlobalOptions): the global configuration used in rendering\n            each cell.\n        config (CellConfiguration): the configuration of how this cell\n            should present.\n        bounding_box (Tuple[int, int, int, int]): the position and size of\n            this cell on the canvas.\n    \"\"\"\n    self.config = config\n    self.options = options\n    self.cell_layout = CellLayout(bounding_box)\n</code></pre>"},{"location":"reference/view/grid_world_view_v2/display_state_v2/cell/cell/#src.view.grid_world_view_v2.display_state_v2.cell.cell.Cell.draw","title":"<code>draw(canvas, drawing_context)</code>","text":"<p>Draw the cell to the canvas.</p> <p>Parameters:</p> Name Type Description Default <code>canvas</code> <code>Image</code> <p>the image to draw to</p> required <code>drawing_context</code> <code>ImageDraw</code> <p>the drawing context</p> required Source code in <code>src/view/grid_world_view_v2/display_state_v2/cell/cell.py</code> <pre><code>def draw(\n    self,\n    canvas: Image,\n    drawing_context: ImageDraw,\n):\n    \"\"\"Draw the cell to the canvas.\n\n    Args:\n        canvas (Image): the image to draw to\n        drawing_context (ImageDraw): the drawing context\n    \"\"\"\n    BackgroundLayer(\n        self.options,\n        self.config,\n        canvas,\n        drawing_context,\n        self.cell_layout.bounding_box,\n        self.cell_layout,\n    ).draw()\n    MainIconLayer(\n        self.options,\n        self.config,\n        canvas,\n        drawing_context,\n        self.cell_layout.inset_bounding_box(\n            self.cell_layout.padding + self.cell_layout.border_width\n        ),\n        self.cell_layout,\n    ).draw()\n    ArrowLayer(\n        self.options,\n        self.config,\n        canvas,\n        drawing_context,\n        self.cell_layout.inset_bounding_box(self.cell_layout.padding),\n        self.cell_layout,\n    ).draw()\n</code></pre>"},{"location":"reference/view/grid_world_view_v2/display_state_v2/cell/cell_layout/","title":"Cell Layout","text":""},{"location":"reference/view/grid_world_view_v2/display_state_v2/cell/cell_layout/#src.view.grid_world_view_v2.display_state_v2.cell.cell_layout.CellLayout","title":"<code>CellLayout</code>","text":"<p>             Bases: <code>object</code></p> <p>Class for managing the layout and configuration of each cell.</p> Source code in <code>src/view/grid_world_view_v2/display_state_v2/cell/cell_layout.py</code> <pre><code>class CellLayout(object):\n    \"\"\"Class for managing the layout and configuration of each cell.\"\"\"\n\n    min_border_width: int = 6\n    min_padding: int = 2\n    padding_ratio: float = 0.1\n    border_ratio: float = 0.05\n\n    def __init__(self, bounding_box: Tuple[int, int, int, int]):\n        \"\"\"Initialise the cell layout.\n\n        Args:\n            bounding_box (Tuple[int, int, int, int]): the size of the cell.\n        \"\"\"\n        self.bounding_box = bounding_box\n        self.cell_size = self.get_bounding_box_size(bounding_box)\n        self.border_width = int(\n            max(self.border_ratio * self.cell_size, self.min_border_width)\n        )\n        self.padding = int(\n            max(self.padding_ratio * self.cell_size, self.min_padding)\n        )\n\n    def get_bounding_box_size(\n        self, bounding_box: Tuple[int, int, int, int]\n    ) -&gt; int:\n        \"\"\"Get the size of a bounding box.\n\n        Args:\n            bounding_box (Tuple[int, int, int, int]): the box to measure\n\n        Returns:\n            int: the minimum length along one edge.\n        \"\"\"\n        min_x, min_y, max_x, max_y = bounding_box\n\n        return min(max_x - min_x, max_y - min_y)\n\n    def contains_point(self, pos: Tuple[int, int]) -&gt; bool:\n        \"\"\"Determine weather this cell contains a point.\n\n        Checks its bounding box.\n\n        Args:\n            pos (Tuple[int, int]): the position to check\n\n        Returns:\n            bool: True if this point is in the bounding box\n        \"\"\"\n        pos_x, pos_y = pos\n        min_x, min_y, max_x, max_y = self.bounding_box\n        return min_x &lt;= pos_x &lt;= max_x and min_y &lt;= pos_y &lt;= max_y\n\n    def inset_bounding_box(\n        self, inset_amount: int\n    ) -&gt; Tuple[int, int, int, int]:\n        \"\"\"Get the bounding box that has been inset.\n\n        Args:\n            inset_amount (int): the amount to make the box smaller\n\n        Returns:\n            Tuple[int, int, int, int]: the new bounding box that has been inset\n        \"\"\"\n        min_x, min_y, max_x, max_y = self.bounding_box\n        return (\n            min_x + inset_amount,\n            min_y + inset_amount,\n            max_x - inset_amount,\n            max_y - inset_amount,\n        )\n</code></pre>"},{"location":"reference/view/grid_world_view_v2/display_state_v2/cell/cell_layout/#src.view.grid_world_view_v2.display_state_v2.cell.cell_layout.CellLayout.__init__","title":"<code>__init__(bounding_box)</code>","text":"<p>Initialise the cell layout.</p> <p>Parameters:</p> Name Type Description Default <code>bounding_box</code> <code>Tuple[int, int, int, int]</code> <p>the size of the cell.</p> required Source code in <code>src/view/grid_world_view_v2/display_state_v2/cell/cell_layout.py</code> <pre><code>def __init__(self, bounding_box: Tuple[int, int, int, int]):\n    \"\"\"Initialise the cell layout.\n\n    Args:\n        bounding_box (Tuple[int, int, int, int]): the size of the cell.\n    \"\"\"\n    self.bounding_box = bounding_box\n    self.cell_size = self.get_bounding_box_size(bounding_box)\n    self.border_width = int(\n        max(self.border_ratio * self.cell_size, self.min_border_width)\n    )\n    self.padding = int(\n        max(self.padding_ratio * self.cell_size, self.min_padding)\n    )\n</code></pre>"},{"location":"reference/view/grid_world_view_v2/display_state_v2/cell/cell_layout/#src.view.grid_world_view_v2.display_state_v2.cell.cell_layout.CellLayout.contains_point","title":"<code>contains_point(pos)</code>","text":"<p>Determine weather this cell contains a point.</p> <p>Checks its bounding box.</p> <p>Parameters:</p> Name Type Description Default <code>pos</code> <code>Tuple[int, int]</code> <p>the position to check</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if this point is in the bounding box</p> Source code in <code>src/view/grid_world_view_v2/display_state_v2/cell/cell_layout.py</code> <pre><code>def contains_point(self, pos: Tuple[int, int]) -&gt; bool:\n    \"\"\"Determine weather this cell contains a point.\n\n    Checks its bounding box.\n\n    Args:\n        pos (Tuple[int, int]): the position to check\n\n    Returns:\n        bool: True if this point is in the bounding box\n    \"\"\"\n    pos_x, pos_y = pos\n    min_x, min_y, max_x, max_y = self.bounding_box\n    return min_x &lt;= pos_x &lt;= max_x and min_y &lt;= pos_y &lt;= max_y\n</code></pre>"},{"location":"reference/view/grid_world_view_v2/display_state_v2/cell/cell_layout/#src.view.grid_world_view_v2.display_state_v2.cell.cell_layout.CellLayout.get_bounding_box_size","title":"<code>get_bounding_box_size(bounding_box)</code>","text":"<p>Get the size of a bounding box.</p> <p>Parameters:</p> Name Type Description Default <code>bounding_box</code> <code>Tuple[int, int, int, int]</code> <p>the box to measure</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>the minimum length along one edge.</p> Source code in <code>src/view/grid_world_view_v2/display_state_v2/cell/cell_layout.py</code> <pre><code>def get_bounding_box_size(\n    self, bounding_box: Tuple[int, int, int, int]\n) -&gt; int:\n    \"\"\"Get the size of a bounding box.\n\n    Args:\n        bounding_box (Tuple[int, int, int, int]): the box to measure\n\n    Returns:\n        int: the minimum length along one edge.\n    \"\"\"\n    min_x, min_y, max_x, max_y = bounding_box\n\n    return min(max_x - min_x, max_y - min_y)\n</code></pre>"},{"location":"reference/view/grid_world_view_v2/display_state_v2/cell/cell_layout/#src.view.grid_world_view_v2.display_state_v2.cell.cell_layout.CellLayout.inset_bounding_box","title":"<code>inset_bounding_box(inset_amount)</code>","text":"<p>Get the bounding box that has been inset.</p> <p>Parameters:</p> Name Type Description Default <code>inset_amount</code> <code>int</code> <p>the amount to make the box smaller</p> required <p>Returns:</p> Type Description <code>Tuple[int, int, int, int]</code> <p>Tuple[int, int, int, int]: the new bounding box that has been inset</p> Source code in <code>src/view/grid_world_view_v2/display_state_v2/cell/cell_layout.py</code> <pre><code>def inset_bounding_box(\n    self, inset_amount: int\n) -&gt; Tuple[int, int, int, int]:\n    \"\"\"Get the bounding box that has been inset.\n\n    Args:\n        inset_amount (int): the amount to make the box smaller\n\n    Returns:\n        Tuple[int, int, int, int]: the new bounding box that has been inset\n    \"\"\"\n    min_x, min_y, max_x, max_y = self.bounding_box\n    return (\n        min_x + inset_amount,\n        min_y + inset_amount,\n        max_x - inset_amount,\n        max_y - inset_amount,\n    )\n</code></pre>"},{"location":"reference/view/grid_world_view_v2/display_state_v2/cell/main_icon_layer/","title":"Main Icon Layer","text":""},{"location":"reference/view/grid_world_view_v2/display_state_v2/cell/main_icon_layer/#src.view.grid_world_view_v2.display_state_v2.cell.main_icon_layer.MainIconLayer","title":"<code>MainIconLayer</code>","text":"<p>             Bases: <code>BaseLayer</code></p> <p>The layer responsible for drawing the background of the cell.</p> Source code in <code>src/view/grid_world_view_v2/display_state_v2/cell/main_icon_layer.py</code> <pre><code>class MainIconLayer(BaseLayer):\n    \"\"\"The layer responsible for drawing the background of the cell.\"\"\"\n\n    def draw(self):\n        \"\"\"Draw the main icon.\"\"\"\n        size = self.cell_layout.get_bounding_box_size(self.bounding_box)\n        icon = self.__get_main_icon(size)\n        if icon is None:\n            return\n        self.draw_icon(icon, size)\n\n    def __get_main_icon(self, size: int) -&gt; Optional[Image]:\n        \"\"\"Get what the main icon should be based upon the cell config.\n\n        Args:\n            size (int): the size the icon should be.\n\n        Returns:\n            Image: the image that corresponds to what the main icon should be\n        \"\"\"\n        cell_entity = self.config.cell_entity\n        loader = self.icon_loader\n        match self.options.display_mode:\n            case DisplayMode.default | DisplayMode.state_value:\n                return loader.get_cell_entity_icon(cell_entity, size)\n            case (\n                DisplayMode.action_value_global | DisplayMode.action_value_local\n            ):\n                if cell_entity is CellEntity.goal:\n                    return loader.get_cell_entity_icon(cell_entity, size)\n                return None\n            case DisplayMode.best_action:\n                best_action = self.__get_best_action()\n                if best_action is None:\n                    return loader.get_cell_entity_icon(cell_entity, size)\n\n                return loader.get_action_icon(best_action, size)\n\n    def __get_best_action(self) -&gt; Optional[Action]:\n        \"\"\"Get the action that has the best value.\n\n        Returns:\n            Optional[Action]: the best action if there is one.\n        \"\"\"\n        action_values = self.config.action_values_raw\n        best_action_value = float(\"-inf\")\n        best_action = None\n        for action in Action:\n            action_value = action_values[action]\n            if action_value is None:\n                continue\n            if best_action_value is None:\n                best_action_value = action_value\n                best_action = action\n            elif action_value &gt; best_action_value:\n                best_action_value = action_value\n                best_action = action\n        return best_action\n</code></pre>"},{"location":"reference/view/grid_world_view_v2/display_state_v2/cell/main_icon_layer/#src.view.grid_world_view_v2.display_state_v2.cell.main_icon_layer.MainIconLayer.__get_best_action","title":"<code>__get_best_action()</code>","text":"<p>Get the action that has the best value.</p> <p>Returns:</p> Type Description <code>Optional[Action]</code> <p>Optional[Action]: the best action if there is one.</p> Source code in <code>src/view/grid_world_view_v2/display_state_v2/cell/main_icon_layer.py</code> <pre><code>def __get_best_action(self) -&gt; Optional[Action]:\n    \"\"\"Get the action that has the best value.\n\n    Returns:\n        Optional[Action]: the best action if there is one.\n    \"\"\"\n    action_values = self.config.action_values_raw\n    best_action_value = float(\"-inf\")\n    best_action = None\n    for action in Action:\n        action_value = action_values[action]\n        if action_value is None:\n            continue\n        if best_action_value is None:\n            best_action_value = action_value\n            best_action = action\n        elif action_value &gt; best_action_value:\n            best_action_value = action_value\n            best_action = action\n    return best_action\n</code></pre>"},{"location":"reference/view/grid_world_view_v2/display_state_v2/cell/main_icon_layer/#src.view.grid_world_view_v2.display_state_v2.cell.main_icon_layer.MainIconLayer.__get_main_icon","title":"<code>__get_main_icon(size)</code>","text":"<p>Get what the main icon should be based upon the cell config.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int</code> <p>the size the icon should be.</p> required <p>Returns:</p> Name Type Description <code>Image</code> <code>Optional[Image]</code> <p>the image that corresponds to what the main icon should be</p> Source code in <code>src/view/grid_world_view_v2/display_state_v2/cell/main_icon_layer.py</code> <pre><code>def __get_main_icon(self, size: int) -&gt; Optional[Image]:\n    \"\"\"Get what the main icon should be based upon the cell config.\n\n    Args:\n        size (int): the size the icon should be.\n\n    Returns:\n        Image: the image that corresponds to what the main icon should be\n    \"\"\"\n    cell_entity = self.config.cell_entity\n    loader = self.icon_loader\n    match self.options.display_mode:\n        case DisplayMode.default | DisplayMode.state_value:\n            return loader.get_cell_entity_icon(cell_entity, size)\n        case (\n            DisplayMode.action_value_global | DisplayMode.action_value_local\n        ):\n            if cell_entity is CellEntity.goal:\n                return loader.get_cell_entity_icon(cell_entity, size)\n            return None\n        case DisplayMode.best_action:\n            best_action = self.__get_best_action()\n            if best_action is None:\n                return loader.get_cell_entity_icon(cell_entity, size)\n\n            return loader.get_action_icon(best_action, size)\n</code></pre>"},{"location":"reference/view/grid_world_view_v2/display_state_v2/cell/main_icon_layer/#src.view.grid_world_view_v2.display_state_v2.cell.main_icon_layer.MainIconLayer.draw","title":"<code>draw()</code>","text":"<p>Draw the main icon.</p> Source code in <code>src/view/grid_world_view_v2/display_state_v2/cell/main_icon_layer.py</code> <pre><code>def draw(self):\n    \"\"\"Draw the main icon.\"\"\"\n    size = self.cell_layout.get_bounding_box_size(self.bounding_box)\n    icon = self.__get_main_icon(size)\n    if icon is None:\n        return\n    self.draw_icon(icon, size)\n</code></pre>"},{"location":"reference/view/icons/","title":"Icons","text":"<p>Package for loading icons into custom tkinter.</p>"},{"location":"reference/view/icons/load_icon/","title":"Load Icon","text":""},{"location":"reference/view/icons/load_icon/#src.view.icons.load_icon.Icon","title":"<code>Icon</code>","text":"<p>             Bases: <code>Enum</code></p> <p>Enumerates all possible icons available.</p> Source code in <code>src/view/icons/load_icon.py</code> <pre><code>class Icon(Enum):\n    \"\"\"Enumerates all possible icons available.\"\"\"\n\n    robot = \"robot\"\n    flag = \"flag\"\n    no_entry = \"do-not-enter\"\n    up_arrow = \"up-arrow\"\n    down_arrow = \"down-arrow\"\n    right_arrow = \"right-arrow\"\n    left_arrow = \"left-arrow\"\n    empty = \"empty\"\n</code></pre>"},{"location":"reference/view/icons/load_icon/#src.view.icons.load_icon.IconLoader","title":"<code>IconLoader</code>","text":"<p>             Bases: <code>object</code></p> <p>Load Icon images into the application.</p> Source code in <code>src/view/icons/load_icon.py</code> <pre><code>class IconLoader(object):\n    \"\"\"Load Icon images into the application.\"\"\"\n\n    _instance = None\n\n    # icon -&gt; normal icon, light icon\n    # avoid loading the same icon file multiple times\n    bitmap_cache: Dict[Icon, Image] = {}\n\n    # cache icon size and color because they will likely be used a lot\n    variant_cache: Dict[IconVariantSpecification, Image] = {}\n\n    default_color = (255, 255, 255)\n\n    def __new__(cls) -&gt; Self:\n        \"\"\"Create a config object.\n\n        Overridden to provide the singleton patten, there must only be one\n        IconLoader object. there should only be one cache so there is not need\n        for more than one loader\n\n        Returns:\n            Self: The config object with the loaded data\n        \"\"\"\n        # https://python-patterns.guide/gang-of-four/singleton/\n        if cls._instance is None:\n            cls._instance = super().__new__(cls)\n        return cls._instance\n\n    def get_path(self, icon: Icon) -&gt; str:\n        \"\"\"Get an icon's file path.\n\n        Args:\n            icon (Icon): the icon to find the path for.\n\n        Returns:\n            str: the absolute path to the icon file.\n        \"\"\"\n        return path.abspath(\n            path.join(path.dirname(__file__), f\"{icon.value}.png\")\n        )\n\n    rgb_component_max = 255\n\n    def get_coloured_icon(\n        self, image: Image, color: Tuple[int, int, int]\n    ) -&gt; Image:\n        \"\"\"Convert a black icon to a specific color.\n\n        sets all non-transparent pixels to the color.\n\n        Args:\n            image (Image): the image to convert,\n            color (str): must represent a valid color\n\n        Returns:\n            Image: the image with a white foreground\n        \"\"\"\n        np_color = np.array(color, dtype=int)\n\n        img_array = np.array(image.convert(\"RGBA\"))\n\n        rgb = img_array[:, :, :3]\n        alpha = img_array[:, :, 3]\n        non_transparent_pixels = alpha != 0\n        # set icon color to wight\n        rgb[non_transparent_pixels] = np_color\n\n        return Pillow.fromarray(img_array)\n\n    action_mapping: Dict[Action, Icon] = {\n        Action.up: Icon.up_arrow,\n        Action.down: Icon.down_arrow,\n        Action.left: Icon.left_arrow,\n        Action.right: Icon.right_arrow,\n    }\n\n    def get_action_icon(\n        self,\n        action: Action,\n        size: int,\n        color: Tuple[int, int, int] = default_color,\n    ) -&gt; Image:\n        \"\"\"Get the appropriate arrow icon for a given action.\n\n        Args:\n            action (Action): the action to represent\n            size (int): the size the icon should be displayed by tkinter\n            color (str): the color of the icon\n\n        Returns:\n            Image: the image pointing in that actions direction.\n        \"\"\"\n        return self.get_icon(self.action_mapping[action], size, color)\n\n    cell_entity_mapping = {\n        CellEntity.agent: Icon.robot,\n        CellEntity.goal: Icon.flag,\n        CellEntity.blocked: Icon.no_entry,\n        CellEntity.empty: Icon.empty,\n    }\n\n    def get_cell_entity_icon(\n        self,\n        entity: CellEntity,\n        size: int,\n        color: Tuple[int, int, int] = default_color,\n    ) -&gt; Image:\n        \"\"\"Get the appropriate icon for a given cell entity.\n\n        Args:\n            entity (CellEntity): the entity to represent\n            size (int): the size the icon should be displayed by tkinter\n            color (str): the color of the icon\n\n        Returns:\n            Image: the image of this cell entity\n        \"\"\"\n        return self.get_icon(self.cell_entity_mapping[entity], size, color)\n\n    def get_icon(\n        self,\n        icon: Icon,\n        size: int,\n        color: Tuple[int, int, int] = default_color,\n    ) -&gt; Image:\n        \"\"\"Get the custom tkinter image object for a given icon.\n\n        Args:\n            icon (Icon): the icon to display\n            size (int): the size the icon should be displayed by tkinter\n            color (str): the color of the icon\n\n        Returns:\n            Image: the image representing this icon\n        \"\"\"\n        size = max(size, 1)\n        cache_key = IconVariantSpecification(icon, size, color)\n        existing_image = self.variant_cache.get(cache_key, None)\n        if existing_image is not None:\n            return existing_image\n\n        image_raw = self.__get_icon_raw_files(icon)\n\n        coloured_icon = self.get_coloured_icon(image_raw, color)\n        # resize image\n        coloured_icon.thumbnail((size, size))\n\n        self.variant_cache[cache_key] = coloured_icon\n\n        return coloured_icon\n\n    def __get_icon_raw_files(self, icon: Icon) -&gt; Image:\n        cached_file = self.bitmap_cache.get(icon, None)\n        if cached_file is not None:\n            return cached_file\n\n        icon_raw = Pillow.open(self.get_path(icon))\n\n        self.bitmap_cache[icon] = icon_raw\n        return icon_raw\n</code></pre>"},{"location":"reference/view/icons/load_icon/#src.view.icons.load_icon.IconLoader.__new__","title":"<code>__new__()</code>","text":"<p>Create a config object.</p> <p>Overridden to provide the singleton patten, there must only be one IconLoader object. there should only be one cache so there is not need for more than one loader</p> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The config object with the loaded data</p> Source code in <code>src/view/icons/load_icon.py</code> <pre><code>def __new__(cls) -&gt; Self:\n    \"\"\"Create a config object.\n\n    Overridden to provide the singleton patten, there must only be one\n    IconLoader object. there should only be one cache so there is not need\n    for more than one loader\n\n    Returns:\n        Self: The config object with the loaded data\n    \"\"\"\n    # https://python-patterns.guide/gang-of-four/singleton/\n    if cls._instance is None:\n        cls._instance = super().__new__(cls)\n    return cls._instance\n</code></pre>"},{"location":"reference/view/icons/load_icon/#src.view.icons.load_icon.IconLoader.get_action_icon","title":"<code>get_action_icon(action, size, color=default_color)</code>","text":"<p>Get the appropriate arrow icon for a given action.</p> <p>Parameters:</p> Name Type Description Default <code>action</code> <code>Action</code> <p>the action to represent</p> required <code>size</code> <code>int</code> <p>the size the icon should be displayed by tkinter</p> required <code>color</code> <code>str</code> <p>the color of the icon</p> <code>default_color</code> <p>Returns:</p> Name Type Description <code>Image</code> <code>Image</code> <p>the image pointing in that actions direction.</p> Source code in <code>src/view/icons/load_icon.py</code> <pre><code>def get_action_icon(\n    self,\n    action: Action,\n    size: int,\n    color: Tuple[int, int, int] = default_color,\n) -&gt; Image:\n    \"\"\"Get the appropriate arrow icon for a given action.\n\n    Args:\n        action (Action): the action to represent\n        size (int): the size the icon should be displayed by tkinter\n        color (str): the color of the icon\n\n    Returns:\n        Image: the image pointing in that actions direction.\n    \"\"\"\n    return self.get_icon(self.action_mapping[action], size, color)\n</code></pre>"},{"location":"reference/view/icons/load_icon/#src.view.icons.load_icon.IconLoader.get_cell_entity_icon","title":"<code>get_cell_entity_icon(entity, size, color=default_color)</code>","text":"<p>Get the appropriate icon for a given cell entity.</p> <p>Parameters:</p> Name Type Description Default <code>entity</code> <code>CellEntity</code> <p>the entity to represent</p> required <code>size</code> <code>int</code> <p>the size the icon should be displayed by tkinter</p> required <code>color</code> <code>str</code> <p>the color of the icon</p> <code>default_color</code> <p>Returns:</p> Name Type Description <code>Image</code> <code>Image</code> <p>the image of this cell entity</p> Source code in <code>src/view/icons/load_icon.py</code> <pre><code>def get_cell_entity_icon(\n    self,\n    entity: CellEntity,\n    size: int,\n    color: Tuple[int, int, int] = default_color,\n) -&gt; Image:\n    \"\"\"Get the appropriate icon for a given cell entity.\n\n    Args:\n        entity (CellEntity): the entity to represent\n        size (int): the size the icon should be displayed by tkinter\n        color (str): the color of the icon\n\n    Returns:\n        Image: the image of this cell entity\n    \"\"\"\n    return self.get_icon(self.cell_entity_mapping[entity], size, color)\n</code></pre>"},{"location":"reference/view/icons/load_icon/#src.view.icons.load_icon.IconLoader.get_coloured_icon","title":"<code>get_coloured_icon(image, color)</code>","text":"<p>Convert a black icon to a specific color.</p> <p>sets all non-transparent pixels to the color.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>Image</code> <p>the image to convert,</p> required <code>color</code> <code>str</code> <p>must represent a valid color</p> required <p>Returns:</p> Name Type Description <code>Image</code> <code>Image</code> <p>the image with a white foreground</p> Source code in <code>src/view/icons/load_icon.py</code> <pre><code>def get_coloured_icon(\n    self, image: Image, color: Tuple[int, int, int]\n) -&gt; Image:\n    \"\"\"Convert a black icon to a specific color.\n\n    sets all non-transparent pixels to the color.\n\n    Args:\n        image (Image): the image to convert,\n        color (str): must represent a valid color\n\n    Returns:\n        Image: the image with a white foreground\n    \"\"\"\n    np_color = np.array(color, dtype=int)\n\n    img_array = np.array(image.convert(\"RGBA\"))\n\n    rgb = img_array[:, :, :3]\n    alpha = img_array[:, :, 3]\n    non_transparent_pixels = alpha != 0\n    # set icon color to wight\n    rgb[non_transparent_pixels] = np_color\n\n    return Pillow.fromarray(img_array)\n</code></pre>"},{"location":"reference/view/icons/load_icon/#src.view.icons.load_icon.IconLoader.get_icon","title":"<code>get_icon(icon, size, color=default_color)</code>","text":"<p>Get the custom tkinter image object for a given icon.</p> <p>Parameters:</p> Name Type Description Default <code>icon</code> <code>Icon</code> <p>the icon to display</p> required <code>size</code> <code>int</code> <p>the size the icon should be displayed by tkinter</p> required <code>color</code> <code>str</code> <p>the color of the icon</p> <code>default_color</code> <p>Returns:</p> Name Type Description <code>Image</code> <code>Image</code> <p>the image representing this icon</p> Source code in <code>src/view/icons/load_icon.py</code> <pre><code>def get_icon(\n    self,\n    icon: Icon,\n    size: int,\n    color: Tuple[int, int, int] = default_color,\n) -&gt; Image:\n    \"\"\"Get the custom tkinter image object for a given icon.\n\n    Args:\n        icon (Icon): the icon to display\n        size (int): the size the icon should be displayed by tkinter\n        color (str): the color of the icon\n\n    Returns:\n        Image: the image representing this icon\n    \"\"\"\n    size = max(size, 1)\n    cache_key = IconVariantSpecification(icon, size, color)\n    existing_image = self.variant_cache.get(cache_key, None)\n    if existing_image is not None:\n        return existing_image\n\n    image_raw = self.__get_icon_raw_files(icon)\n\n    coloured_icon = self.get_coloured_icon(image_raw, color)\n    # resize image\n    coloured_icon.thumbnail((size, size))\n\n    self.variant_cache[cache_key] = coloured_icon\n\n    return coloured_icon\n</code></pre>"},{"location":"reference/view/icons/load_icon/#src.view.icons.load_icon.IconLoader.get_path","title":"<code>get_path(icon)</code>","text":"<p>Get an icon's file path.</p> <p>Parameters:</p> Name Type Description Default <code>icon</code> <code>Icon</code> <p>the icon to find the path for.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>the absolute path to the icon file.</p> Source code in <code>src/view/icons/load_icon.py</code> <pre><code>def get_path(self, icon: Icon) -&gt; str:\n    \"\"\"Get an icon's file path.\n\n    Args:\n        icon (Icon): the icon to find the path for.\n\n    Returns:\n        str: the absolute path to the icon file.\n    \"\"\"\n    return path.abspath(\n        path.join(path.dirname(__file__), f\"{icon.value}.png\")\n    )\n</code></pre>"},{"location":"reference/view/icons/load_icon/#src.view.icons.load_icon.IconVariantSpecification","title":"<code>IconVariantSpecification</code>  <code>dataclass</code>","text":"<p>             Bases: <code>object</code></p> <p>Specifies a particular variant of an icon for cacheing purposes.</p> Source code in <code>src/view/icons/load_icon.py</code> <pre><code>@dataclass(frozen=True)\nclass IconVariantSpecification(object):\n    \"\"\"Specifies a particular variant of an icon for cacheing purposes.\"\"\"\n\n    icon_type: Icon\n    size: int\n    color: rgb_type\n</code></pre>"}]}